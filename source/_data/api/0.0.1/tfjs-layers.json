{
  "docs": {
    "headings": [
      {
        "name": "Constraints",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Constraints",
                  "subheading": "Classes",
                  "namespace": "constraints"
                },
                "symbolName": "Constraint",
                "namespace": "constraints",
                "documentation": "Base class for functions that impose constraints on weight values",
                "fileName": "#31",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/constraints.ts#L31-L38",
                "methods": [],
                "isClass": true
              }
            ]
          },
          {
            "name": "",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints",
                  "useDocsFrom": "MaxNorm",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "maxNorm",
                "namespace": "constraints",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MaxNormConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.maxValue",
                    "documentation": "Maximum norm for incoming weights",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.axis",
                    "documentation": "Axis along which to calculate norms.\n\n  For instance, in a `Dense` layer the weight matrix\n  has shape `[inputDim, outputDim]`,\n  set `axis` to `0` to constrain each weight vector\n  of length `[inputDim,]`.\n  In a `Conv2D` layer with `dataFormat=\"channels_last\"`,\n  the weight tensor has shape\n  `[rows, cols, inputDepth, outputDepth]`,\n  set `axis` to `[0, 1, 2]`\n  to constrain the weights of each filter tensor of size\n  `[rows, cols, inputDepth]`.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Constraint",
                "documentation": "MaxNorm weight constraint.\n\nConstrains the weights incident to each hidden unit\nto have a norm less than or equal to a desired value.\n\nReferences\n       - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting\nSrivastava, Hinton, et al.\n2014](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
                "fileName": "#467",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L467-L475",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints",
                  "useDocsFrom": "UnitNorm",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "unitNorm",
                "namespace": "constraints",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "UnitNormConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.axis",
                    "documentation": "Axis along which to calculate norms.\n\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Constraint",
                "documentation": "Constrains the weights incident to each hidden unit to have unit norm.",
                "fileName": "#477",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L477-L485",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints",
                  "useDocsFrom": "NonNeg",
                  "subheading": ""
                },
                "symbolName": "nonNeg",
                "namespace": "constraints",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Constraint",
                "documentation": "Constains the weight to be non-negative.",
                "fileName": "#487",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L487-L491",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints",
                  "useDocsFrom": "MinMaxNormConfig",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "minMaxNorm",
                "namespace": "constraints",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MinMaxNormConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.minValue",
                    "documentation": "Minimum norm for incoming weights",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.maxValue",
                    "documentation": "Maximum norm for incoming weights",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.axis",
                    "documentation": "Axis along which to calculate norms.\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.rate",
                    "documentation": "Rate for enforcing the constraint: weights will be rescaled to yield:\n`(1 - rate) * norm + rate * norm.clip(minValue, maxValue)`.\nEffectively, this means that rate=1.0 stands for strict\nenforcement of the constraint, while rate<1.0 means that\nweights will be rescaled at each step to slowly move\ntowards a value inside the desired interval.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Constraint",
                "documentation": "",
                "fileName": "#493",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L493-L501",
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Initializers",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Initializers",
                  "subheading": "Classes",
                  "namespace": "initializers"
                },
                "symbolName": "Initializer",
                "namespace": "initializers",
                "documentation": "Initializer base class.",
                "fileName": "#47",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/initializers.ts#L47-L68",
                "methods": [],
                "isClass": true
              }
            ]
          },
          {
            "name": "",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "Zeros",
                  "subheading": ""
                },
                "symbolName": "zeros",
                "namespace": "initializers",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Initializer",
                "documentation": "Initializer that generates tensors initialized to 0.",
                "fileName": "#505",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L505-L512",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "Ones",
                  "subheading": ""
                },
                "symbolName": "ones",
                "namespace": "initializers",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Initializer",
                "documentation": "Initializer that generates tensors initialized to 1.",
                "fileName": "#514",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L514-L518",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "Constant",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "constant",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ConstantConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.value",
                    "documentation": "The value for each element in the variable. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates values initialized to some constant.",
                "fileName": "#520",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L520-L529",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "RandomUniform",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "randomUniform",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "RandomUniformConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.minval",
                    "documentation": "Lower bound of the range of random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.maxval",
                    "documentation": "Upper bound of the range of random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Used to seed the random generator. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a uniform\ndistribution.\n\nValues will be distributed uniformly between the configured minval and\nmaxval.",
                "fileName": "#531",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L531-L540",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "RandomNormal",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "randomNormal",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "RandomNormalConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.mean",
                    "documentation": "Mean of the random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.stddev",
                    "documentation": "Standard deviation of the random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Used to seed the random generator. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a normal\ndistribution.",
                "fileName": "#542",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L542-L551",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "TruncatedNormal",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "truncatedNormal",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "TruncatedNormalConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.mean",
                    "documentation": "Mean of the random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.stddev",
                    "documentation": "Standard deviation of the random values to generate. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Used to seed the random generator. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a truncated normal.\ndistribution.\n\nThese values are similar to values from a `RandomNormal` except that values\nmore than two standard deviations from the mean are discarded and re-drawn.\nThis is the recommended initializer for neural network weights and filters.",
                "fileName": "#553",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L553-L562",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "Identity",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "identity",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "IdentityConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.gain",
                    "documentation": "Multiplicative factor to apply to the identity matrix.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates the identity matrix.\nOnly use for square 2D matrices.",
                "fileName": "#564",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L564-L573",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "VarianceScaling",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "varianceScaling",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "VarianceScalingConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.scale",
                    "documentation": "Scaling factor (positive float). ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.mode",
                    "documentation": "Fanning mode for inputs and outputs. ",
                    "type": "FanMode",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.distribution",
                    "documentation": "Probabilistic distribution of the values. ",
                    "type": "Distribution",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Random number generator seed. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer capable of adapting its scale to the shape of weights.\nWith distribution=NORMAL, samples are drawn from a truncated normal\ndistribution centered on zero, with `stddev = sqrt(scale / n)` where n is:\n   - number of input units in the weight tensor, if mode = FAN_IN.\n   - number of output units, if mode = FAN_OUT.\n   - average of the numbers of input and output units, if mode = FAN_AVG.\nWith distribution=UNIFORM,\nsamples are drawn from a uniform distribution\nwithin [-limit, limit], with `limit = sqrt(3 * scale / n)`.",
                "fileName": "#575",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L575-L584",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "GlorotUniform",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "glorotUniform",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SeedOnlyInitializerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Random number generator seed. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Glorot uniform initializer, also called Xavier uniform initializer.\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.",
                "fileName": "#586",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L586-L595",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "GlorotNormal",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "glorotNormal",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SeedOnlyInitializerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Random number generator seed. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Glorot normal initializer, also called Xavier normal initializer.\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor.\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf",
                "fileName": "#597",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L597-L606",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "HeNormal",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "heNormal",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SeedOnlyInitializerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Random number generator seed. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "He normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
                "fileName": "#608",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L608-L617",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers",
                  "useDocsFrom": "LeCunNormal",
                  "configParamIndices": [
                    0
                  ],
                  "subheading": ""
                },
                "symbolName": "leCunNormal",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SeedOnlyInitializerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.seed",
                    "documentation": "Random number generator seed. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Initializer",
                "documentation": "LeCun normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(1 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReferences:\n   [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)\n   [Efficient Backprop](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf)",
                "fileName": "#620",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L620-L629",
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Regularizers",
        "description": "",
        "subheadings": [
          {
            "name": "",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers",
                  "subheading": ""
                },
                "symbolName": "L1L2",
                "namespace": "regularizers",
                "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
                "fileName": "#51",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/regularizers.ts#L51-L92",
                "methods": [],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers",
                  "useDocsFrom": "L1L2",
                  "subheading": ""
                },
                "symbolName": "l1l2",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L1L2Config",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "L1L2",
                "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
                "fileName": "#633",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L633-L637",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers",
                  "useDocsFrom": "L1L2",
                  "subheading": ""
                },
                "symbolName": "l1",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L1Config",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "L1L2",
                "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
                "fileName": "#639",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L639-L643",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers",
                  "useDocsFrom": "L1L2",
                  "subheading": ""
                },
                "symbolName": "l2",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L2Config",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "L1L2",
                "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
                "fileName": "#645",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L645-L649",
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Layers",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Classes"
                },
                "symbolName": "Layer",
                "documentation": "Abstract base layer class.",
                "fileName": "#323",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/topology.ts#L323-L1165",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "apply",
                    "paramStr": "(inputs, kwargs?)",
                    "parameters": [
                      {
                        "name": "inputs",
                        "documentation": "Can be a tensor or list/tuple of tensors.",
                        "type": "Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "kwargs",
                        "documentation": "Additional keyword arguments to be passed to `call()`.",
                        "type": "any",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[]",
                    "documentation": "Wrapper around this.call(), for handling internal references.\n\nThis is a replacement for __call__() in Python.\n\nIf a `SymbolicTensor` is passed:\n   - We call this.addInboundNode().\n   - If necessary, we `build` the layer to match\n       the shape of the input(s).\n   - We update the shape of every input tensor with\n       its new shape (obtained via self.computeOutputShape).\n       This is done as part of addInboundNode().\n   - We update the history of the output tensor(s)\n       with the current layer.\n       This is done as part of addInboundNode().",
                    "fileName": "#772",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/topology.ts#L772-L886",
                    "isFunction": true
                  }
                ],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Classes"
                },
                "symbolName": "RNNCell",
                "documentation": "Porting Note: This is a common parent class for RNN cells. There is no\n   equivalent of this in PyKeras. Having a common parent class forgoes the\n   need for `has_attr(cell, ...)` checks or its TypeScript equivalent.",
                "fileName": "#648",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/layers/recurrent.ts#L648-L655",
                "methods": [],
                "isClass": true
              }
            ]
          },
          {
            "name": "Convolutional",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "Conv1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "conv1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ConvLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.kernelSize",
                    "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                    "type": "number|number[]",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.filters",
                    "documentation": "The dimensionality of the output space (i.e. the number output of\nfilters in the convolution).",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "The strides of the convolution. If strides is a number, strides in both\ndimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                    "type": "number|number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "Padding mode.",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "Format of the data, e.g., CHANNEL_LAST.\n   The ordering of the dimensions in the inputs.\n   `channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)` while `channels_first` corresponds to\n   inputs with shape `(batch, channels, ...)`.\n   Defaults to \"channels_last\".",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dilationRate",
                    "documentation": "An integer or array of integers, specifying\n   the dilation rate to use for dilated convolution.\n   Currently, specifying any `dilationRate` value != 1 is\n   incompatible with specifying any `strides` value != 1.",
                    "type": "number|number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied\n   (ie. \"linear\" activation: `a(x) = x`).",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.useBias",
                    "documentation": "Whether the layer uses a bias vector. Defaults to false.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelInitializer",
                    "documentation": "Initializer for the `kernel` weights matrix.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasInitializer",
                    "documentation": "Initializer for the bias vector.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelConstraint",
                    "documentation": "Constraint for the kernel weights.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasConstraint",
                    "documentation": "Constraint for the bias vector.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelRegularizer",
                    "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasRegularizer",
                    "documentation": "Regularizer function applied to the bias vector.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activityRegularizer",
                    "documentation": "Regularizer function applied to the activation.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "1D convolution layer (e.g., temporal convolution).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input over a single spatial (or temporal) dimension\nto produce a tensor of outputs.\nIf `use_bias` is True, a bias vector is created and added to the outputs.\nFinally, if `activation` is not `null` or `undefined`,\nit is applied to the outputs as well.\nWhen using this layer as the first layer in a model,\nprovide an `inputShape` argument Array or `null`, e.g.\n`[10, 128]` for sequences of 10 vectors of 128-dimensional vectors,\nor `[null, 128]` for variable-length sequences of 128-dimensional vectors.",
                "fileName": "#101",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L101-L110",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "Conv2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "conv2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ConvLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.kernelSize",
                    "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                    "type": "number|number[]",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.filters",
                    "documentation": "The dimensionality of the output space (i.e. the number output of\nfilters in the convolution).",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "The strides of the convolution. If strides is a number, strides in both\ndimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                    "type": "number|number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "Padding mode.",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "Format of the data, e.g., CHANNEL_LAST.\n   The ordering of the dimensions in the inputs.\n   `channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)` while `channels_first` corresponds to\n   inputs with shape `(batch, channels, ...)`.\n   Defaults to \"channels_last\".",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dilationRate",
                    "documentation": "An integer or array of integers, specifying\n   the dilation rate to use for dilated convolution.\n   Currently, specifying any `dilationRate` value != 1 is\n   incompatible with specifying any `strides` value != 1.",
                    "type": "number|number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied\n   (ie. \"linear\" activation: `a(x) = x`).",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.useBias",
                    "documentation": "Whether the layer uses a bias vector. Defaults to false.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelInitializer",
                    "documentation": "Initializer for the `kernel` weights matrix.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasInitializer",
                    "documentation": "Initializer for the bias vector.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelConstraint",
                    "documentation": "Constraint for the kernel weights.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasConstraint",
                    "documentation": "Constraint for the bias vector.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelRegularizer",
                    "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasRegularizer",
                    "documentation": "Regularizer function applied to the bias vector.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activityRegularizer",
                    "documentation": "Regularizer function applied to the activation.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `None`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat=DataFormat.CHANNEL_LAST`.",
                "fileName": "#112",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L112-L121",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "DepthwiseConv2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "depthwiseConv2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "DepthwiseConv2DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.kernelSize",
                    "documentation": "An integer or Array of 2 integers, specifying the width and height of the\n2D convolution window. Can be a single integer to specify the same value\nfor all spatial dimensions.",
                    "type": "number|[number, number]",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.depthMultiplier",
                    "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal to\n`filtersIn * depthMultiplier`.\nDefault: 1.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.depthwiseInitializer",
                    "documentation": "Initializer for the depthwise kernel matrix.\nDefault: GlorotNormal.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.depthwiseConstraint",
                    "documentation": "Constraint for the depthwise kernel matrix.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.depthwiseRegularizer",
                    "documentation": "Regulzarizer function for the depthwise kernel matrix.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Depthwise separable 2D convolution.\n\nDepthwise Separable convolutions consists in performing just the first step\nin a depthwise spatial convolution (which acts on each input channel\nseparately). The `depthMultplier` argument controls how many output channels\nare generated per input channel in the depthwise step.",
                "fileName": "#125",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L125-L134",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Core",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Activation",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "activation",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ActivationLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Name of activation function to use. See [activations](../activations.ts).",
                    "type": "string",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Applies an activation function to an output.",
                "fileName": "#137",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L137-L146",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Dense",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "dense",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "DenseLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.units",
                    "documentation": "Positive integer, dimensionality of the output space. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Activation function to use (see [activations](../activations.md)).\nIf you don't specify anything, no activation is applied (ie. \"linear\"\nactivation: `a(x) = x`).",
                    "type": "ActivationIdentifier",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.useBias",
                    "documentation": "Whether the layer uses a bias vector. ",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelInitializer",
                    "documentation": "Initializer for the `kernel` weights matrix (see\n[initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasInitializer",
                    "documentation": "Initializer for the bias vector (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.inputDim",
                    "documentation": "If inputShape is not specified, and inputDim is, then the expected\ninputShape is [inputDim].",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelConstraint",
                    "documentation": "kernelConstraint: Constraint for the kernel weights",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasConstraint",
                    "documentation": "biasConstraint: Constraint for the bias vector",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelRegularizer",
                    "documentation": "kernelRegularizer:  Regularizer function applied to the `kernel` weights\nmatrix",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasRegularizer",
                    "documentation": "biasRegularizer:  Regularizer function applied to the bias vector",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activityRegularizer",
                    "documentation": "activityRegularizer:  Regularizer function applied to the activation",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Just your regular densely-connected NN layer.\n   `Dense` implements the operation:\n   `output = activation(dot(input, kernel) + bias)`\n   where `activation` is the element-wise activation function\n   passed as the `activation` argument, `kernel` is a weights matrix\n   created by the layer, and `bias` is a bias vector created by the layer\n   (only applicable if `useBias` is `true`).\n   Note: if the input to the layer has a rank greater than 2, then\n   it is flattened prior to the initial dot product with `kernel`.\n\nInput shape\n   nD tensor with shape: `(batchSize, ..., inputDim)`.\n   The most common situation would be\n   a 2D input with shape `(batchSize, inputDim)`.\nOutput shape\n   nD tensor with shape: `(batchSize, ..., units)`.\n   For instance, for a 2D input with shape `(batchSize, inputDim)`,\n   the output would have shape `(batchSize, units)`.",
                "fileName": "#148",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L148-L157",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Dropout",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "dropout",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "DropoutLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.rate",
                    "documentation": "float between 0 and 1. Fraction of the input units to drop. ",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.noiseShape",
                    "documentation": "Integer array representing the shape of the\nbinary dropout mask that will be multiplied with the input.\nFor instance, if your inputs have shape\n`(batchSize, timesteps, features)` and\nyou want the dropout mask to be the same for all timesteps,\nyou can use `noise_shape=(batch_size, 1, features)`.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.seed",
                    "documentation": "An integer to use as random seed. ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Applies Dropout to the input.\n\nDropout consists in randomly setting\na fraction `rate` of input units to 0 at each update during training time,\nwhich helps prevent overfitting.\n\nReferences\n- [Dropout: A Simple Way to Prevent Neural Networks from\nOverfitting](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
                "fileName": "#159",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L159-L168",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Flatten",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "flatten",
                "namespace": "layers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "LayerConfig",
                    "optional": true,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchInputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchSize",
                    "documentation": "If inputShape is specified, but not batchInputShape, batchSize is used\nto construct the batchInputShape: [batchSize].concat(inputShape)",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dtype",
                    "documentation": "DType for this layer. If not specified, defaults to K.floatx(). Only\napplicable to input layers.",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "Optional name for this layer. ",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.trainable",
                    "documentation": "Whether this layer is trainable. If not specified, defaults to true. ",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.updatable",
                    "documentation": "",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.weights",
                    "documentation": "If defined, the layer's initial weight values will be set to this argument.",
                    "type": "Tensor[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.inputDType",
                    "documentation": "Legacy support. Do not use for new code. ",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Flattens the input. Does not affect the batch size.\n\nA `Flatten` layer flattens each batch sample in its inputs to 1D (hence the\noutput is 2D total).\n\nFor example:\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst flattenLayer = tf.layers.flatten();\n// Inspect the inferred output shape of the flatten layer, which\n// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the\n// flattening. (The 1st dimension is the undermined batch size.)\nconsole.log(flattenLayer.apply(input).shape);\n```",
                "fileName": "#170",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L170-L179",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "RepeatVector",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "repeatVector",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "RepeatVectorLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.n",
                    "documentation": "Integer, repetition factor.",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Repeat the input n times.",
                "fileName": "#181",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L181-L190",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Embedding",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "embedding",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "EmbeddingLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputDim",
                    "documentation": "inputDim:\n     int > 0. Size of the vocabulary, i.e. maximum integer index + 1.",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.outputDim",
                    "documentation": "outputDim:\n     int >= 0. Dimension of the dense embedding.",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.embeddingsInitializer",
                    "documentation": "embeddingsInitializer:\n     Initializer for the `embeddings` matrix\n     (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.embeddingsRegularizer",
                    "documentation": "embeddingsRegularizer:\n     Regularizer function applied to the `embeddings` matrix.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activityRegularizer",
                    "documentation": "activityRegularizer:\n     Regularizer function applied to the activation.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.embeddingsConstraint",
                    "documentation": "embeddingsConstraint: Constraint function applied to\n    the `embeddings` matrix\n    (see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.maskZero",
                    "documentation": "mask_zero: Whether or not the input value 0 is a special \"padding\"\n     value that should be masked out.\n     This is useful when using [recurrent layers](recurrent.md)\n     which may take variable length input.\n     If this is `True` then all subsequent layers\n     in the model need to support masking or an exception will be raised.\n     If mask_zero is set to True, as a consequence, index 0 cannot be\n     used in the vocabulary (input_dim should equal size of\n     vocabulary + 1).",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.inputLength",
                    "documentation": "inputLength:\n     Length of input sequences, when it is constant.\n     This argument is required if you are going to connect\n     `Flatten` then `Dense` layers upstream\n     (without it, the shape of the dense outputs cannot be computed).",
                    "type": "number|number[]",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Turns positive integers (indexes) into dense vectors of fixed size.\neg. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]\n\nInput shape: 2D tensor with shape: `[batchSize, sequenceLength]`.\n\nOutput shape: 3D tensor with shape: `[batchSize, sequenceLength, outputDim]`.",
                "fileName": "#192",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L192-L201",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Merge",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Add",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "add",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MergeLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that adds a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#205",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L205-L214",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Average",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "average",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MergeLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that averages a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#216",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L216-L225",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Concatenate",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "concatenate",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ConcatenateLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.axis",
                    "documentation": "Axis along which to concatenate.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that concatenates a list of inputs.\n\nIt takes a list of tensors, all of the same shape except for the\nconcatenation axis, and returns a single tensor, the concatenation\nof all inputs.",
                "fileName": "#227",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L227-L236",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Maximum",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maximum",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MergeLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that computes the maximum (element-wise) a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#238",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L238-L247",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Minimum",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "minimum",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MergeLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that computes the minimum (element-wise) a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#249",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L249-L258",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Multiply",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "multiply",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MergeLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer that multiplies (element-wise) an Array of inputs.\n\nIt takes as input an Array of tensors, all of the same\nshape, and returns a single tensor (also of the same shape).",
                "fileName": "#260",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L260-L269",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Normalization",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Normalization",
                  "namespace": "layers",
                  "useDocsFrom": "BatchNormalization",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "batchNormalization",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "BatchNormalizationLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.axis",
                    "documentation": "Integer, the axis that should be normalized (typically the features axis).\nFor instance, after a `Conv2D` layer with `data_format=\"channels_first\"`,\nset `axis=1` in `BatchNormalization`.\nDefault: -1.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.momentum",
                    "documentation": "Momentum of the moving average.\nDefault: 0.99.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.epsilon",
                    "documentation": "Small float added to the variance to avoid dividing by zero.\nDefault: 1e-3.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.center",
                    "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefault: true.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.scale",
                    "documentation": "If `true`, multiply by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear (also e.g. `nn.relu`),\nthis can be disabled since the scaling will be done by the next layer.\nDefault: true.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.betaInitializer",
                    "documentation": "Initializer for the beta weight.\nDefault: 'Zeros'.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.gammaInitializer",
                    "documentation": "Initializer for the gamma weight.\nDefault: 'Ones'.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.movingMeanInitializer",
                    "documentation": "Initializer for the moving mean.\nDefault: 'Zeros'",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.movingVarianceInitializer",
                    "documentation": "Initializer for the moving variance.\nDefault: 'Ones'.",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.betaConstraint",
                    "documentation": "Optional constraint for the beta weight.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.gammaConstraint",
                    "documentation": "Optional constraint for gamma weight.",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.betaRegularizer",
                    "documentation": "Optional regularizer for the beta weight.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.gammaRegularizer",
                    "documentation": "Optional regularizer for the gamma weight.",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Batch normalization layer (Ioffe and Szegedy, 2014).\n\nNormalize the activations of the previous layer at each batch,\ni.e. applies a transformation that maintains the mean activation\nclose to 0 and the activation standard deviation close to 1.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape` (Array of integers, does\n   not include the sample axis) when calling the constructor of this class,\n   if this layer is used as a first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Batch Normalization: Accelerating Deep Network Training by Reducing\nInternal Covariate Shift](https://arxiv.org/abs/1502.03167)",
                "fileName": "#273",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L273-L282",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Pooling",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "AvgPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "avgPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "Pooling1DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.poolSize",
                    "documentation": "Integer size of the window to pool over.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "Period at which to sample the pooled values.\nIf None, it will default to `poolSize`.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "PaddingMode.VALID or PaddingMode.SAME ",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Average pooling operation for spatial data.\n\n  Input shape:  `[batchSize, inLength, channels]`\n\n  Output shape: `[batchSize, pooledLength, channels]`",
                "fileName": "#285",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L285-L294",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "AvgPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "avgPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "Pooling2DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.poolSize",
                    "documentation": "Integer or tuple of 2 integers, factors by which to downscale\n[vertical, horizontal].\n\n[2, 2] will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                    "type": "number|[number, number]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "Integer, tuple of 2 integers, or None.\n\nIf None, it will default to `poolSize`.",
                    "type": "[number, number]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Average pooling operation for spatial data.\n\nInput shape\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, rows, cols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, rows, cols]`\n\nOutput shape\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, pooleRows, pooledCols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, pooleRows, pooledCols]`",
                "fileName": "#296",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L296-L305",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalAveragePooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalAveragePooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "LayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchInputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchSize",
                    "documentation": "If inputShape is specified, but not batchInputShape, batchSize is used\nto construct the batchInputShape: [batchSize].concat(inputShape)",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dtype",
                    "documentation": "DType for this layer. If not specified, defaults to K.floatx(). Only\napplicable to input layers.",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "Optional name for this layer. ",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.trainable",
                    "documentation": "Whether this layer is trainable. If not specified, defaults to true. ",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.updatable",
                    "documentation": "",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.weights",
                    "documentation": "If defined, the layer's initial weight values will be set to this argument.",
                    "type": "Tensor[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.inputDType",
                    "documentation": "Legacy support. Do not use for new code. ",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Global average pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape:2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#307",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L307-L316",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalAveragePooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalAveragePooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "GlobalPooling2DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels[` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Global average pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#318",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L318-L327",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalMaxPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalMaxPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "LayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchInputShape",
                    "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both inputShape and batchInputShape are defined, batchInputShape\nwill be used. Only applicable to input layers.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchSize",
                    "documentation": "If inputShape is specified, but not batchInputShape, batchSize is used\nto construct the batchInputShape: [batchSize].concat(inputShape)",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dtype",
                    "documentation": "DType for this layer. If not specified, defaults to K.floatx(). Only\napplicable to input layers.",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "Optional name for this layer. ",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.trainable",
                    "documentation": "Whether this layer is trainable. If not specified, defaults to true. ",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.updatable",
                    "documentation": "",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.weights",
                    "documentation": "If defined, the layer's initial weight values will be set to this argument.",
                    "type": "Tensor[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.inputDType",
                    "documentation": "Legacy support. Do not use for new code. ",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Global max pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape:2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#329",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L329-L338",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalMaxPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalMaxPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "GlobalPooling2DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels[` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Global max pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#340",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L340-L349",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "MaxPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maxPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "Pooling1DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.poolSize",
                    "documentation": "Integer size of the window to pool over.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "Period at which to sample the pooled values.\nIf None, it will default to `poolSize`.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "PaddingMode.VALID or PaddingMode.SAME ",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Max pooling operation for temporal data.\n\nInput shape:  `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`",
                "fileName": "#351",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L351-L360",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "MaxPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maxPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "Pooling2DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.poolSize",
                    "documentation": "Integer or tuple of 2 integers, factors by which to downscale\n[vertical, horizontal].\n\n[2, 2] will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                    "type": "number|[number, number]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.strides",
                    "documentation": "Integer, tuple of 2 integers, or None.\n\nIf None, it will default to `poolSize`.",
                    "type": "[number, number]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.padding",
                    "documentation": "",
                    "type": "PaddingMode",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dataFormat",
                    "documentation": "",
                    "type": "DataFormat",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Max pooling operation for spatial data.\n\nInput shape\n   - If `dataFormat === CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, rows, cols, channels]`\n   - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n       `[batchSize, channels, rows, cols]`\n\nOutput shape\n   - If `dataFormat=CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, pooleRows, pooledCols, channels]`\n   - If `dataFormat=CHANNEL_FIRST`:\n       4D tensor with shape:\n       `[batchSize, channels, pooleRows, pooledCols]`",
                "fileName": "#362",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L362-L371",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Recurrent",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "GRU",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "gru",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "GRULayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.implementation",
                    "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Gated Recurrent Unit - Cho et al. 2014.",
                "fileName": "#375",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L375-L384",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "GRUCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "gruCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "GRUCellLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.recurrentActivation",
                    "documentation": "Activation function to use for the recurrent step.\n(see [activations](../activations.md)).\nDefault: hard sigmoid (`hardSigomid`).\nIf you pass `null`, no activation is applied\n(ie. \"linear\" activation: `a(x) = x`).",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.implementation",
                    "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "RNNCell",
                "documentation": "Cell class for the GRU layer.",
                "fileName": "#386",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L386-L395",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "LSTM",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "lstm",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "LSTMLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.unitForgetBias",
                    "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'Zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.implementation",
                    "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Long-Short Term Memory layer - Hochreiter 1997.",
                "fileName": "#397",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L397-L406",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "LSTMCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "lstmCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "LSTMCellLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.recurrentActivation",
                    "documentation": "Activation function to use for the recurrent step.\n(see [activations](../activations.md)).\nDefault: hard sigmoid (`hardSigomid`).\nIf you pass `null`, no activation is applied\n(ie. \"linear\" activation: `a(x) = x`).",
                    "type": "ActivationIdentifier",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.unitForgetBias",
                    "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'Zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.implementation",
                    "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "RNNCell",
                "documentation": "Cell class for the LSTM layer.",
                "fileName": "#408",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L408-L417",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "SimpleRNN",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "simpleRNN",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SimpleRNNLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.units",
                    "documentation": "units: Positive integer, dimensionality of the output space.",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Activation function to use (see [activations](../activations.md)).\nDefault: hyperbolic tangent (`tanh`).\nIf you pass `null`, no activation will be applied\n(i.e., \"linear\" activation: `a(x) = x`).",
                    "type": "ActivationIdentifier",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.useBias",
                    "documentation": "Whether the layer uses a bias vector.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelInitializer",
                    "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentInitializer",
                    "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state\n(see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasInitializer",
                    "documentation": "Initializer for the bias vector (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelRegularizer",
                    "documentation": "Regularizer function applied to the `kernel` weights matrix\n(see [regularizer](../regularizers.md)).",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentRegularizer",
                    "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.\n(see [regularizer](../regularizers.md))",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasRegularizer",
                    "documentation": "Regularizer function applied to the bias vector.\n(see [regularizer](../regularizers.md))",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelConstraint",
                    "documentation": "Constraint function applied to the `kernel` weights matrix.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentConstraint",
                    "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasConstraint",
                    "documentation": "Constraintfunction applied to the bias vector.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dropout",
                    "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentDropout",
                    "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Fully-connected RNN where the output is to be fed back to input.",
                "fileName": "#419",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L419-L428",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "SimpleRNNCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "simpleRNNCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SimpleRNNCellLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.units",
                    "documentation": "units: Positive integer, dimensionality of the output space.",
                    "type": "number",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.activation",
                    "documentation": "Activation function to use (see [activations](../activations.md)).\nDefault: hyperbolic tangent (`tanh`).\nIf you pass `null`,  'linear' activation will be applied.",
                    "type": "ActivationIdentifier",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.useBias",
                    "documentation": "Whether the layer uses a bias vector.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelInitializer",
                    "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentInitializer",
                    "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state\n(see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasInitializer",
                    "documentation": "Initializer for the bias vector (see [initializers](../initializers.md)).",
                    "type": "InitializerIdentifier|Initializer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelRegularizer",
                    "documentation": "Regularizer function applied to the `kernel` weights matrix\n(see [regularizer](../regularizers.md)).",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentRegularizer",
                    "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.\n(see [regularizer](../regularizers.md))",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasRegularizer",
                    "documentation": "Regularizer function applied to the bias vector.\n(see [regularizer](../regularizers.md))",
                    "type": "RegularizerIdentifier|Regularizer",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.kernelConstraint",
                    "documentation": "Constraint function applied to the `kernel` weights matrix.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentConstraint",
                    "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.biasConstraint",
                    "documentation": "Constraintfunction applied to the bias vector.\n(see [constraints](../constraints.md)).",
                    "type": "ConstraintIdentifier|Constraint",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dropout",
                    "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.recurrentDropout",
                    "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "RNNCell",
                "documentation": "",
                "fileName": "#430",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L430-L439",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Wrapper",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers",
                  "useDocsFrom": "Bidirectional",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "bidirectional",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "BidirectionalLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.layer",
                    "documentation": "The instance of an `RNN` layer to be wrapped.",
                    "type": "RNN",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.mergeMode",
                    "documentation": "Mode by which outputs of the forward and backward RNNs are combinied.\nIf `null` or `undefined`, the output will not be combined, they will be\nreturned as an `Array`.",
                    "type": "BidirectionalMergeMode",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "",
                "fileName": "#443",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L443-L452",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers",
                  "useDocsFrom": "TimeDistributed",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "timeDistributed",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "WrapperLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.layer",
                    "documentation": "The layer to be wrapped.",
                    "type": "Layer",
                    "optional": false,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "This wrapper applies a layer to every temporal slice of an input.\n\nThe input should be at least 3D,  and the dimension of the index `1` will be\nconsidered to be the temporal dimension.\n\nConsider a batch of 32 samples, where each sample is a sequence of 10 vectors\nof 16 dimensions. The batch input shape of the layer is then `[32,  10,\n16]`, and the `inputShape`, not including the sample dimension, is\n`[10, 16]`.\n\nYou can then use `TimeDistributed` to apply a `Dense` layer to each of the 10\ntimesteps, independently:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: new Dense({units: 8}),\n   inputShape: [10, 16],\n});\n\n// Now model.outputShape = [null, 10, 8].\n// The output will then have shape `[32, 10, 8]`.\n\n// In subsequent layers, there is no need for `inputShape`:\nmodel.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: 32})});\n// Now model.outputShape = [null, 10, 32].\n```\n\nThe output will then have shape `[32, 10, 32]`.\n\n`TimeDistributed` can be used with arbitrary layers, not just `Dense`, for\ninstance a `Conv2D` layer.\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: new Conv2D({filter: 64, kernelSize: [3, 3]}),\n   inputShape: [10, 299, 299, 3]\n});\n```",
                "fileName": "#454",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L454-L463",
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Models",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "SymbolicTensor",
                "documentation": "`SymbolicTensor` is a symbolic `Tensor` without any concrete value.\nIt can be used during the building phase of models that involve no actual\nexecution of the computation defined in the model.",
                "fileName": "#66",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/types.ts#L66-L104",
                "methods": [],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Model",
                "documentation": "The `Model` class adds training & evaluation routines to a `Container`.\n\nA `Model` is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a `Model, use `model`.\n\nWhen creating a `Model`, specify its input(s) and output(s). Inputs are\n`SymbolicTensor`s provided by `Input` layers. Outputs are `SymbolicTensor`s\nprovided by other layers that perform mathematical and neural-network\noperations.\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with of 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\n\nSee also:\n   `Sequential`, `loadModel`.",
                "fileName": "#612",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L612-L1578",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "compile",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelCompileConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "",
                    "fileName": "#643",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L643-L837",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluate",
                    "paramStr": "(x, y, batchSize?, verbose?, sampleWeight?, steps?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "Tensor of test data, or list of Tensors if the model has\nmultiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "Tensor of target data, or list of Tensors if the model has\nmultiple outputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to true.",
                        "type": "ModelLoggingVerbosity",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "sampleWeight",
                        "documentation": "Tensor of weights to weight the contribution\nof different samples to the loss and metrics.",
                        "type": "Tensor",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "steps",
                        "documentation": "Integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. When `steps` is not\nprovided, will perform evaluation on all exapmles in `x` and `y` and\ndeclare evaluation finished.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Scalar|Scalar[]",
                    "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.",
                    "fileName": "#887",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L887-L905",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predict",
                    "paramStr": "(x, batchSize?, verbose?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "The input data, as an Tensor (or `Array` of `Tensor`s if the\nmodel has multiple outputs).",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "Integer. If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to false.",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor\n      |Tensor[]",
                    "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nPorting Note: the \"step\" mode of predict() is currently not supported.\nThis is because the TensorFow.js core backend is imperative only.",
                    "fileName": "#1024",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1024-L1033",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predictOnBatch",
                    "paramStr": "(x)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": ": Input samples, as an Tensor",
                        "type": "Tensor",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]",
                    "documentation": "Returns predictions for a single batch of samples.",
                    "fileName": "#1041",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1041-L1047",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fit",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelFitConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise",
                    "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).",
                    "fileName": "#1385",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1385-L1577",
                    "isFunction": true
                  }
                ],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Sequential",
                "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n`sequential` is a factory function that creates an instance of\n`Sequential`.\n\nNote: The first layer passed to a Sequential model should have a defined\ninput shape. What that means is that it should have received an `inputShape`\nor `batchInputShape` argument, or for some type of layers (recurrent,\nDense...) an `inputDim` argument.\n\nExamples:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, inputShape: [50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output, which equals\n// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the\n// 2nd is the output size of the model's last layer.\nconsole.log(model.outputs[0].shape);\n```\n\nIt is also possible to specify a batch size (with potentially undetermined\nbatch dimension) for the first layer using the `batchInputShape` key. The\nfollowing example is equivalent to the above:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output.\nconsole.log(model.outputs[0].shape);\n```\n\nYou can also use an `Array` of already-constructed `Layer`s to create\na `Sequential` model:\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 32, inputShape: [50]}),\n            tf.layers.dense({units: 4})]\n});\nconsole.log(model.outputs[0].shape);\n```",
                "fileName": "#205",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L205-L535",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "add",
                    "paramStr": "(layer)",
                    "parameters": [
                      {
                        "name": "layer",
                        "documentation": "Layer instance.",
                        "type": "Layer",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Adds a layer instance on top of the layer stack.",
                    "fileName": "#239",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L239-L314",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluate",
                    "paramStr": "(x, y, batchSize?, verbose?, sampleWeight?, steps?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "Tensor of test data, or list of Tensors if the model has\nmultiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "Tensor of target data, or list of Tensors if the model has\nmultiple outputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to true.",
                        "type": "ModelLoggingVerbosity",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "sampleWeight",
                        "documentation": "Tensor of weights to weight the contribution\nof different samples to the loss and metrics.",
                        "type": "Tensor",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "steps",
                        "documentation": "Optional integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Scalar|Scalar[]",
                    "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.",
                    "fileName": "#432",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L432-L442",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predict",
                    "paramStr": "(x, batchSize?, verbose?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "The input data, as an Tensor (or list of Tensors if the model\nhas multiple outputs).",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "Integer. If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to false.",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor\n      |Tensor[]",
                    "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.",
                    "fileName": "#455",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L455-L462",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fit",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelFitConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise",
                    "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).",
                    "fileName": "#502",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L502-L510",
                    "isFunction": true
                  }
                ],
                "isClass": true
              }
            ]
          },
          {
            "name": "Creation",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation",
                  "useDocsFrom": "Model",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "model",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "ContainerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputs",
                    "documentation": "",
                    "type": "SymbolicTensor|SymbolicTensor[]",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.outputs",
                    "documentation": "",
                    "type": "SymbolicTensor|SymbolicTensor[]",
                    "optional": false,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Model",
                "documentation": "The `Model` class adds training & evaluation routines to a `Container`.\n\nA `Model` is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a `Model, use `model`.\n\nWhen creating a `Model`, specify its input(s) and output(s). Inputs are\n`SymbolicTensor`s provided by `Input` layers. Outputs are `SymbolicTensor`s\nprovided by other layers that perform mathematical and neural-network\noperations.\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with of 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\n\nSee also:\n   `Sequential`, `loadModel`.",
                "fileName": "#44",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L44-L52",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation",
                  "useDocsFrom": "Sequential",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "sequential",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SequentialConfig",
                    "optional": true,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.layers",
                    "documentation": "Stack of layers for the model. ",
                    "type": "Layer[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "The name of this model. ",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Sequential",
                "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n`sequential` is a factory function that creates an instance of\n`Sequential`.\n\nNote: The first layer passed to a Sequential model should have a defined\ninput shape. What that means is that it should have received an `inputShape`\nor `batchInputShape` argument, or for some type of layers (recurrent,\nDense...) an `inputDim` argument.\n\nExamples:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, inputShape: [50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output, which equals\n// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the\n// 2nd is the output size of the model's last layer.\nconsole.log(model.outputs[0].shape);\n```\n\nIt is also possible to specify a batch size (with potentially undetermined\nbatch dimension) for the first layer using the `batchInputShape` key. The\nfollowing example is equivalent to the above:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output.\nconsole.log(model.outputs[0].shape);\n```\n\nYou can also use an `Array` of already-constructed `Layer`s to create\na `Sequential` model:\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 32, inputShape: [50]}),\n            tf.layers.dense({units: 4})]\n});\nconsole.log(model.outputs[0].shape);\n```",
                "fileName": "#54",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L54-L62",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Loading",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Loading",
                  "useDocsFrom": "loadModelInternal"
                },
                "symbolName": "loadModel",
                "paramStr": "(modelConfigPath)",
                "parameters": [
                  {
                    "name": "modelConfigPath",
                    "documentation": "A path to the `ModelAndWeightsConfig` JSON describing\nthe model in the canonical TensorFlow.js format.\n\nThis provides the most convenient way to load a TensorFlow.js saved model.\n\nThe content of `model.json` is assumed to be a JSON object with the\nfollowing fields and values:\n- 'modelTopology': A JSON object that can be\n- a model architecture JSON consistent with the format of the return\nvalue of `keras.Model.to_json()`, or\n- a full model JSON in the format of `keras.models.save_model()`.\n- 'weightsManifest': A TensorFlow.js weights manifest.\nSee the Python converter function `save_model()` for more details.\n\nIt is also assumed that model weights can be accessed from relative paths\ndescribed by the `paths` fields in weights manifest.",
                    "type": "string",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Promise",
                "documentation": "Load a model, including its topology and optionally weights.",
                "fileName": "#64",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L64-L71",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Inputs",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Inputs",
                  "useDocsFrom": "Input",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "input",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "InputConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.shape",
                    "documentation": "A shape, not including the batch size. For instance, `shape=[32]`\nindicates that the expected input will be batches of 32-dimensional\nvectors.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchShape",
                    "documentation": "A shape tuple (integer), including the batch size. For instance,\n`batchShape=[10, 32]` indicates that the expected input will be batches of\n10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\narbitrary number of 32-dimensional vectors.",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "An optional name string for the layer. Should be unique in a model (do not\nreuse the same name twice). It will be autogenerated if it isn't provided.",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dtype",
                    "documentation": "",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.sparse",
                    "documentation": "A boolean specifying whether the placeholder to be created is sparse.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "SymbolicTensor",
                "documentation": "`Input()` is used to instantiate a SymbolicTensor, and represents\nthe input to a model.\n\nExample:\n\n```js\n// Simple logistic regression:\nx = tf.input({shape: [32]});\ny = tf.layers.dense({units: 16, activation: 'softmax'}).apply(x);\nmodel = tf.model({inputs: x, outputs: y});\n```",
                "fileName": "#73",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L73-L81",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Inputs",
                  "useDocsFrom": "InputLayer",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "inputLayer",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "InputLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "config.inputShape",
                    "documentation": "Input shape, not including the batch axis. ",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchSize",
                    "documentation": "Optional input batch size (integer or null). ",
                    "type": "number",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.batchInputShape",
                    "documentation": "Batch input shape, including the batch axis. ",
                    "type": "number[]",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.dtype",
                    "documentation": "Datatype of the input.  ",
                    "type": "'float32'|'int32'|'bool'",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.sparse",
                    "documentation": "Whether the placeholder created is meant to be sparse.",
                    "type": "boolean",
                    "optional": true,
                    "isConfigParam": true
                  },
                  {
                    "name": "config.name",
                    "documentation": "Name of the layer. ",
                    "type": "string",
                    "optional": true,
                    "isConfigParam": true
                  }
                ],
                "returnType": "Layer",
                "documentation": "Layer to be used as an entry point into a graph.",
                "fileName": "#83",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L83-L91",
                "isFunction": true
              }
            ]
          }
        ]
      }
    ]
  },
  "docLinkAliases": {}
}