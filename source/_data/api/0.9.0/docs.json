{
  "headings": [
    {
      "name": "Tensors",
      "description": "<p>Tensors are the core datastructure of TensorFlow.js\nThey are a generalization of vectors and matrices to potentially\nhigher dimensions.</p>",
      "subheadings": [
        {
          "name": "Creation",
          "description": "<p>We have utility functions for common cases like Scalar, 1D,\n2D, 3D and 4D tensors, as well a number of functions to initialize\ntensors in ways useful for machine learning.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\n```js\n// Pass an array of values to create a vector.\ntf.tensor([1, 2, 3, 4]).print();\n```\n\n```js\n// Pass a nested array of values to make a matrix or a higher\n// dimensional tensor.\ntf.tensor([[1, 2], [3, 4]]).print();\n```\n\n```js\n// Pass a flat array and specify a shape yourself.\ntf.tensor([1, 2, 3, 4], [2, 2]).print();\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L59-L78",
              "isFunction": true,
              "displayName": "tf.tensor",
              "urlHash": "tensor"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "scalar",
              "paramStr": "(value, dtype?)",
              "parameters": [
                {
                  "name": "value",
                  "documentation": "The value of the scalar.",
                  "type": "number|boolean",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Scalar](#class:Tensor)",
              "documentation": "Creates rank-0 [tf.Tensor](#class:Tensor) (scalar) with the provided value and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.scalar()](#scalar) as it makes the code more readable.\n\n```js\ntf.scalar(3.14).print();\n```",
              "fileName": "#93",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L93-L101",
              "isFunction": true,
              "displayName": "tf.scalar",
              "urlHash": "scalar"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor1d",
              "paramStr": "(values, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be array of numbers,\nor a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Creates rank-1 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor1d()](#tensor1d) as it makes the code more readable.\n\n```js\ntf.tensor1d([1, 2, 3]).print();\n```",
              "fileName": "#117",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L117-L125",
              "isFunction": true,
              "displayName": "tf.tensor1d",
              "urlHash": "tensor1d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor2d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. If not provided, it is inferred from\n`values`.",
                  "type": "[number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Creates rank-2 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor2d()](#tensor2d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor2d([[1, 2], [3, 4]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n```",
              "fileName": "#148",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L148-L160",
              "isFunction": true,
              "displayName": "tf.tensor2d",
              "urlHash": "tensor2d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor3d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. If not provided,  it is inferred from\n`values`.",
                  "type": "[number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)",
              "documentation": "Creates rank-3 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor3d()](#tensor3d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n```",
              "fileName": "#183",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L183-L195",
              "isFunction": true,
              "displayName": "tf.tensor3d",
              "urlHash": "tensor3d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor4d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "[number, number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Creates rank-4 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor4d()](#tensor4d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n```",
              "fileName": "#218",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L218-L230",
              "isFunction": true,
              "displayName": "tf.tensor4d",
              "urlHash": "tensor4d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "buffer",
              "paramStr": "(shape, dtype?, values?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The dtype of the buffer. Defaults to 'float32'.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": "The values of the buffer as [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray). Defaults to\nzeros.",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.TensorBuffer](#class:TensorBuffer)",
              "documentation": "Creates an empty [tf.TensorBuffer](#class:TensorBuffer) with the specified `shape` and `dtype`.\n\nThe values are stored in cpu as [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray). Fill the buffer using\n`buffer.set()`, or by modifying directly `buffer.values`. When done,\ncall `buffer.toTensor()` to get an immutable [tf.Tensor](#class:Tensor) with those values.\n\nWhen done, call `buffer.toTensor()` to get an immutable [tf.Tensor](#class:Tensor) with\nthose values.\n\n```js\n// Create a buffer and set values at particular indices.\nconst buffer = tf.buffer([2, 2]);\nbuffer.set(3, 0, 0);\nbuffer.set(5, 1, 0);\n\n// Convert the buffer back to a tensor.\nbuffer.toTensor().print();\n```",
              "fileName": "#1085",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L1085-L1090",
              "isFunction": true,
              "displayName": "tf.buffer",
              "urlHash": "buffer"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "clone",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to clone.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a new tensor with the same values and shape as the specified\ntensor.\n\n```js   * const x = tf.tensor([1, 2]);\nx.clone().print();\n```",
              "fileName": "#336",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L336-L347",
              "isFunction": true,
              "displayName": "tf.clone",
              "urlHash": "clone"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "fill",
              "paramStr": "(shape, value, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "value",
                  "documentation": "The scalar value to fill the tensor with.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Defaults to\n'float'.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) filled with a scalar value.\n\n```js\ntf.fill([2, 2], 4).print();\n```",
              "fileName": "#282",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L282-L291",
              "isFunction": true,
              "displayName": "tf.fill",
              "urlHash": "fill"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "fromPixels",
              "paramStr": "(pixels, numChannels?)",
              "parameters": [
                {
                  "name": "pixels",
                  "documentation": "The input image to construct the tensor from.",
                  "type": "[ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)|[HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)|[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement)|[HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numChannels",
                  "documentation": "The number of channels of the output tensor. The\nsupported image types are all 4-channel by default, a numChannels value\nless than 4 allows you to ignore channels.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) from an image.\n\n```js\nconst image = new ImageData(1, 1);\nimage.data[0] = 100;\nimage.data[1] = 150;\nimage.data[2] = 200;\nimage.data[3] = 255;\n\ntf.fromPixels(image).print();\n```",
              "fileName": "#567",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L567-L577",
              "isFunction": true,
              "displayName": "tf.fromPixels",
              "urlHash": "fromPixels"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "linspace",
              "paramStr": "(start, stop, num)",
              "parameters": [
                {
                  "name": "start",
                  "documentation": "The start value of the sequence.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stop",
                  "documentation": "The end value of the sequence.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "num",
                  "documentation": "The number of values to generate.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Return an evenly spaced sequence of numbers over the given interval.\n\n```js\ntf.linspace(0, 9, 10).print();\n```",
              "fileName": "#991",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L991-L1007",
              "isFunction": true,
              "displayName": "tf.linspace",
              "urlHash": "linspace"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "oneHot",
              "paramStr": "(indices, depth, onValue?, offValue?)",
              "parameters": [
                {
                  "name": "indices",
                  "documentation": "1D Array of indices.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depth",
                  "documentation": "The depth of the one hot dimension.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "onValue",
                  "documentation": "A number used to fill in output when the index matches\nthe location.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "offValue",
                  "documentation": "A number used to fill in the output when the index does\nnot match the location.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Creates a one-hot [tf.Tensor](#class:Tensor). The locations represented by `indices` take\nvalue `onValue` (defaults to 1), while all other locations take value\n`offValue` (defaults to 0).\n\n```js\ntf.oneHot(tf.tensor1d([0, 1]), 3).print();\n```",
              "fileName": "#537",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L537-L547",
              "isFunction": true,
              "displayName": "tf.oneHot",
              "urlHash": "oneHot"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "ones",
              "paramStr": "(shape, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Defaults to\n'float'.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 1.\n\n```js\ntf.ones([2, 2]).print();\n```",
              "fileName": "#243",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L243-L249",
              "isFunction": true,
              "displayName": "tf.ones",
              "urlHash": "ones"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "onesLike",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 1 with the same shape as the\ngiven tensor.\n\n```js\nconst x = tf.tensor([1, 2]);\ntf.onesLike(x).print();\n```",
              "fileName": "#303",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L303-L307",
              "isFunction": true,
              "displayName": "tf.onesLike",
              "urlHash": "onesLike"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "print",
              "paramStr": "(x, verbose?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to be printed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "verbose",
                  "documentation": "Whether to print verbose information about the ` Tensor`,\nincluding dtype and size.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Prints information about the [tf.Tensor](#class:Tensor) including its data.\n\n```js\nconst verbose = true;\ntf.tensor2d([1, 2, 3, 4], [2, 2]).print(verbose);\n```",
              "fileName": "#1103",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L1103-L1106",
              "isFunction": true,
              "displayName": "tf.print",
              "urlHash": "print"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "randomNormal",
              "paramStr": "(shape, mean?, stdDev?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "The mean of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "stdDev",
                  "documentation": "The standard deviation of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a normal distribution.\n\n```js\ntf.randomNormal([2, 2]).print();\n```",
              "fileName": "#362",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L362-L377",
              "isFunction": true,
              "displayName": "tf.randomNormal",
              "urlHash": "randomNormal"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "randomUniform",
              "paramStr": "(shape, minval?, maxval?, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minval",
                  "documentation": "The lower bound on the range of random values to generate.\nDefaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "maxval",
                  "documentation": "The upper bound on the range of random values to generate.\nDefaults to 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor. Defaults to 'float32'.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a uniform distribution.\n\nThe generated values follow a uniform distribution in the range [minval,\nmaxval). The lower bound minval is included in the range, while the upper\nbound maxval is excluded.\n\n```js\ntf.randomUniform([2, 2]).print();\n```",
              "fileName": "#432",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L432-L442",
              "isFunction": true,
              "displayName": "tf.randomUniform",
              "urlHash": "randomUniform"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "range",
              "paramStr": "(start, stop, step?, dtype?)",
              "parameters": [
                {
                  "name": "start",
                  "documentation": "An integer start value",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stop",
                  "documentation": "An integer stop value",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "step",
                  "documentation": "An integer increment (will default to 1 or -1)",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor. Defaults to 'float32'.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Creates a new [tf.Tensor1D](#class:Tensor) filled with the numbers in the range provided.\n\nThe tensor is a is half-open interval meaning it includes start, but\nexcludes stop. Decrementing ranges and negative step values are also\nsupported.\n\n```js\ntf.range(0, 9, 2).print();\n```",
              "fileName": "#1025",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L1025-L1058",
              "isFunction": true,
              "displayName": "tf.range",
              "urlHash": "range"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "truncatedNormal",
              "paramStr": "(shape, mean?, stdDev?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "The mean of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "stdDev",
                  "documentation": "The standard deviation of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a truncated normal\ndistribution.\n\n```js\ntf.truncatedNormal([2, 2]).print();\n```\n\nThe generated values follow a normal distribution with specified mean and\nstandard deviation, except that values whose magnitude is more than 2\nstandard deviations from the mean are dropped and re-picked.",
              "fileName": "#397",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L397-L412",
              "isFunction": true,
              "displayName": "tf.truncatedNormal",
              "urlHash": "truncatedNormal"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "variable",
              "paramStr": "(initialValue, trainable?, name?, dtype?)",
              "parameters": [
                {
                  "name": "initialValue",
                  "documentation": "Initial value for the tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "trainable",
                  "documentation": "If true, optimizers are allowed to update it.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "name",
                  "documentation": "Name of the variable. Defaults to a unique id.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "If set, initialValue will be converted to the given type.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Variable](#class:Variable)",
              "documentation": "Creates a new variable with the provided initial value.\n```js\nconst x = tf.variable(tf.tensor([1, 2, 3]));\nx.assign(tf.tensor([4, 5, 6]));\n\nx.print();\n```",
              "fileName": "#954",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L954-L962",
              "isFunction": true,
              "displayName": "tf.variable",
              "urlHash": "variable"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "zeros",
              "paramStr": "(shape, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Can\nbe 'float32', 'int32' or 'bool'. Defaults to 'float'.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 0.\n\n```js\ntf.zeros([2, 2]).print();\n```",
              "fileName": "#262",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L262-L268",
              "isFunction": true,
              "displayName": "tf.zeros",
              "urlHash": "zeros"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "zerosLike",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor of required shape.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 0 with the same shape as the\ngiven tensor.\n\n```js\nconst x = tf.tensor([1, 2]);\ntf.zerosLike(x).print();\n```",
              "fileName": "#320",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L320-L324",
              "isFunction": true,
              "displayName": "tf.zerosLike",
              "urlHash": "zerosLike"
            }
          ]
        },
        {
          "name": "Classes",
          "description": "<p>\nThis section shows the main Tensor related classes in TensorFlow.js and\nthe methods we expose on them.\n</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "Tensor",
              "documentation": "A [tf.Tensor](#class:Tensor) object represents an immutable, multidimensional array of numbers\nthat has a shape and a data type.\n\nSee [tf.tensor()](#tensor) for details on how to create a [tf.Tensor](#class:Tensor).",
              "fileName": "#154",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L154-L901",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "flatten",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor1D](#class:Tensor)",
                  "documentation": "Flatten a Tensor to a 1D array. ",
                  "fileName": "#214",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L214-L218",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.flatten"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "asScalar",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Scalar](#class:Tensor)",
                  "documentation": "Converts a size-1 [tf.Tensor](#class:Tensor) to a [tf.Scalar](#class:Tensor). ",
                  "fileName": "#221",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L221-L226",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.asScalar"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "as1D",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor1D](#class:Tensor)",
                  "documentation": "Converts a [tf.Tensor](#class:Tensor) to a [tf.Tensor1D](#class:Tensor). ",
                  "fileName": "#229",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L229-L233",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.as1D"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "as2D",
                  "paramStr": "(rows, columns)",
                  "parameters": [
                    {
                      "name": "rows",
                      "documentation": "Number of rows in [tf.Tensor2D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "columns",
                      "documentation": "Number of columns in [tf.Tensor2D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor2D](#class:Tensor)",
                  "documentation": "Converts a [tf.Tensor](#class:Tensor) to a [tf.Tensor2D](#class:Tensor).",
                  "fileName": "#241",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L241-L245",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.as2D"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "as3D",
                  "paramStr": "(rows, columns, depth)",
                  "parameters": [
                    {
                      "name": "rows",
                      "documentation": "Number of rows in [tf.Tensor3D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "columns",
                      "documentation": "Number of columns in [tf.Tensor3D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "depth",
                      "documentation": "Depth of [tf.Tensor3D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor3D](#class:Tensor)",
                  "documentation": "Converts a [tf.Tensor](#class:Tensor) to a [tf.Tensor3D](#class:Tensor).",
                  "fileName": "#254",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L254-L258",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.as3D"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "as4D",
                  "paramStr": "(rows, columns, depth, depth2)",
                  "parameters": [
                    {
                      "name": "rows",
                      "documentation": "Number of rows in [tf.Tensor4D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "columns",
                      "documentation": "Number of columns in [tf.Tensor4D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "depth",
                      "documentation": "Depth of [tf.Tensor4D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "depth2",
                      "documentation": "4th dimension of [tf.Tensor4D](#class:Tensor).",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor4D](#class:Tensor)",
                  "documentation": "Converts a [tf.Tensor](#class:Tensor) to a [tf.Tensor4D](#class:Tensor).",
                  "fileName": "#268",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L268-L272",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.as4D"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "asType",
                  "paramStr": "(dtype)",
                  "parameters": [
                    {
                      "name": "dtype",
                      "documentation": "Data-type to cast the tensor to.",
                      "type": "'float32'|'int32'|'bool'",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "this",
                  "documentation": "Casts a [tf.Tensor](#class:Tensor) to a specified dtype.",
                  "fileName": "#279",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L279-L283",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.asType"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "buffer",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.TensorBuffer](#class:TensorBuffer)",
                  "documentation": "Returns a [tf.TensorBuffer](#class:TensorBuffer) that holds the underlying data. ",
                  "fileName": "#309",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L309-L312",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.buffer"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "data",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise",
                  "documentation": "Asynchronously downloads the values from the [tf.Tensor](#class:Tensor). Returns a promise of\n[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) that resolves when the computation has finished.",
                  "fileName": "#318",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L318-L322",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.data"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "dataSync",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)",
                  "documentation": "Synchronously downloads the values from the [tf.Tensor](#class:Tensor). This blocks the UI\nthread until the values are ready, which can cause performance issues.",
                  "fileName": "#328",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L328-L332",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.dataSync"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "dispose",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "void",
                  "documentation": "Disposes [tf.Tensor](#class:Tensor) from memory.",
                  "fileName": "#337",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L337-L344",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.dispose"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "toFloat",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "this",
                  "documentation": "Casts the array to type `float32` ",
                  "fileName": "#354",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L354-L357",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.toFloat"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "toInt",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "this",
                  "documentation": "Casts the array to type `int32` ",
                  "fileName": "#360",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L360-L363",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.toInt"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "toBool",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "this",
                  "documentation": "Casts the array to type `bool` ",
                  "fileName": "#366",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L366-L369",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.toBool"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "print",
                  "paramStr": "(verbose?)",
                  "parameters": [
                    {
                      "name": "verbose",
                      "documentation": "Whether to print verbose information about the tensor,\nincluding dtype and size.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Prints the [tf.Tensor](#class:Tensor). See [tf.print()](#print) for details.",
                  "fileName": "#377",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L377-L380",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.print"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "reshape",
                  "paramStr": "(newShape)",
                  "parameters": [
                    {
                      "name": "newShape",
                      "documentation": "An array of integers defining the output tensor shape.",
                      "type": "number[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Reshapes the tensor into the provided shape.\nSee [tf.reshape()](#reshape) for more details.",
                  "fileName": "#388",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L388-L392",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.reshape"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "reshapeAs",
                  "paramStr": "(x)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "The tensor of required shape.",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Reshapes the tensor into the shape of the provided tensor.",
                  "fileName": "#399",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L399-L403",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.reshapeAs"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "expandDims",
                  "paramStr": "(axis?)",
                  "parameters": [
                    {
                      "name": "axis",
                      "documentation": "The dimension index at which to insert shape of 1. Defaults to\n0 (the first dimension).",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Returns a [tf.Tensor](#class:Tensor) that has expanded rank, by inserting a dimension\ninto the tensor's shape. See [tf.expandDims()](#expandDims) for details.",
                  "fileName": "#412",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L412-L415",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.expandDims"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "squeeze",
                  "paramStr": "(axis?)",
                  "parameters": [
                    {
                      "name": "axis",
                      "documentation": "A list of numbers. If specified, only squeezes the\ndimensions listed. The dimension index starts at 0. It is an error to\nsqueeze a dimension that is not 1.",
                      "type": "number[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Returns a [tf.Tensor](#class:Tensor) with dimensions of size 1 removed from the shape.\nSee [tf.squeeze()](#squeeze) for more details.",
                  "fileName": "#425",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L425-L429",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.squeeze"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "clone",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Returns a copy of the tensor. See [tf.clone()](#clone) for details. ",
                  "fileName": "#432",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L432-L436",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.clone"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "toString",
                  "paramStr": "(verbose?)",
                  "parameters": [
                    {
                      "name": "verbose",
                      "documentation": "",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "string",
                  "documentation": "Returns a human-readable description of the tensor. Useful for logging. ",
                  "fileName": "#439",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L439-L442",
                  "isFunction": true,
                  "urlHash": "tf.Tensor.toString"
                }
              ],
              "isClass": true,
              "displayName": "tf.Tensor",
              "urlHash": "class:Tensor"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "Variable",
              "documentation": "A mutable [tf.Tensor](#class:Tensor), useful for persisting state, e.g. for training.",
              "fileName": "#917",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L917-L986",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "assign",
                  "paramStr": "(newValue)",
                  "parameters": [
                    {
                      "name": "newValue",
                      "documentation": "New tensor to be assigned to this variable.",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Assign a new [tf.Tensor](#class:Tensor) to this variable. The new [tf.Tensor](#class:Tensor) must have the\nsame shape and dtype as the old [tf.Tensor](#class:Tensor).",
                  "fileName": "#970",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L970-L985",
                  "isFunction": true,
                  "urlHash": "tf.Variable.assign"
                }
              ],
              "isClass": true,
              "inheritsFrom": "[tf.Tensor](#class:Tensor)",
              "displayName": "tf.Variable",
              "urlHash": "class:Variable"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "TensorBuffer",
              "documentation": "A mutable object, similar to [tf.Tensor](#class:Tensor), that allows users to set values\nat locations before converting to an immutable [tf.Tensor](#class:Tensor).\n\nSee [tf.buffer()](#buffer) for creating a tensor buffer.",
              "fileName": "#37",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L37-L136",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "set",
                  "paramStr": "(value, locs)",
                  "parameters": [
                    {
                      "name": "value",
                      "documentation": "The value to set.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "locs",
                      "documentation": "The location indices.",
                      "type": "number[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Sets a value in the buffer at a given location.",
                  "fileName": "#67",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L67-L78",
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.set"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "get",
                  "paramStr": "(locs)",
                  "parameters": [
                    {
                      "name": "locs",
                      "documentation": "The location indices.",
                      "type": "number[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "number",
                  "documentation": "Returns the value in the buffer at the provided location.",
                  "fileName": "#85",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L85-L95",
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.get"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "toTensor",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Creates an immutable [tf.Tensor](#class:Tensor) object from the buffer.",
                  "fileName": "#132",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tensor.ts#L132-L135",
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.toTensor"
                }
              ],
              "isClass": true,
              "displayName": "tf.TensorBuffer",
              "urlHash": "class:TensorBuffer"
            }
          ]
        },
        {
          "name": "Transformations",
          "description": "<p>This section describes some common Tensor\ntransformations for reshaping and type-casting.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "cast",
              "paramStr": "(x, dtype)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be casted.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The dtype to cast the input tensor to.",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Casts a [tf.Tensor](#class:Tensor) to a new dtype.\n\n```js\nconst x = tf.tensor1d([1.5, 2.5, 3]);\ntf.cast(x, 'int32').print();\n```",
              "fileName": "#646",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L646-L654",
              "isFunction": true,
              "displayName": "tf.cast",
              "urlHash": "cast"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "expandDims",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor whose dimensions to be expanded.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension index at which to insert shape of `1`. Defaults\nto 0 (the first dimension).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns a [tf.Tensor](#class:Tensor) that has expanded rank, by inserting a dimension\ninto the tensor's shape.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst axis = 1;\nx.expandDims(axis).print();\n```",
              "fileName": "#970",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L970-L977",
              "isFunction": true,
              "displayName": "tf.expandDims",
              "urlHash": "expandDims"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "pad",
              "paramStr": "(x, paddings, constantValue?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to pad.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "paddings",
                  "documentation": "An array of length `R` (the rank of the tensor), where each\nelement is a length-2 tuple of ints `[padBefore, padAfter]`, specifying\nhow much to pad along each dimension of the tensor.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "constantValue",
                  "documentation": "The pad value to use. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Pads a [tf.Tensor](#class:Tensor) with a given value and paddings.\n\nThis operation currently only implements the `CONSTANT` mode.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nx.pad([[1, 2]]).print();\n```",
              "fileName": "#839",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L839-L855",
              "isFunction": true,
              "displayName": "tf.pad",
              "urlHash": "pad"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "reshape",
              "paramStr": "(x, shape)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be reshaped.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Reshapes a [tf.Tensor](#class:Tensor) to a given shape.\n\nGiven a input tensor, returns a new tensor with the same values as the\ninput tensor with shape `shape`.\n\nIf one component of shape is the special value -1, the size of that\ndimension is computed so that the total size remains constant. In\nparticular, a shape of [-1] flattens into 1-D. At most one component of\nshape can be -1.\n\nIf shape is 1-D or higher, then the operation returns a tensor with shape\nshape filled with the values of tensor. In this case, the number of\nelements implied by shape must be the same as the number of elements in\ntensor.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nx.reshape([2, 2]).print();\n```",
              "fileName": "#603",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L603-L616",
              "isFunction": true,
              "displayName": "tf.reshape",
              "urlHash": "reshape"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "squeeze",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be squeezed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "An optional list of numbers. If specified, only\nsqueezes the dimensions listed. The dimension index starts at 0. It is\nan error to squeeze a dimension that is not 1.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Removes dimensions of size 1 from the shape of a [tf.Tensor](#class:Tensor).\n\n```js\nconst x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);\nx.squeeze().print();\n```",
              "fileName": "#631",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L631-L634",
              "isFunction": true,
              "displayName": "tf.squeeze",
              "urlHash": "squeeze"
            }
          ]
        },
        {
          "name": "Slicing and Joining",
          "description": "<p>TensorFlow.js provides several operations\nto slice or extract parts of a tensor, or join multiple\ntensors together.",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "concat",
              "paramStr": "(tensors, axis?)",
              "parameters": [
                {
                  "name": "tensors",
                  "documentation": "A list of tensors to concatenate.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis to concate along. Defaults to 0 (the first dim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Concatenates a list of [tf.Tensor](#class:Tensor)s along a given axis.\n\nThe tensors ranks and types must match, and their sizes must match in all\ndimensions except `axis`.\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\na.concat(b).print();  // or a.concat(b)\n```\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\nconst c = tf.tensor1d([5, 6]);\ntf.concat([a, b, c]).print();\n```\n\n```js\nconst a = tf.tensor2d([[1, 2], [10, 20]]);\nconst b = tf.tensor2d([[3, 4], [30, 40]]);\nconst axis = 1;\ntf.concat([a, b], axis).print();\n```",
              "fileName": "#146",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/concat.ts#L146-L160",
              "isFunction": true,
              "displayName": "tf.concat",
              "urlHash": "concat"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "gather",
              "paramStr": "(x, indices, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor whose slices to be gathered.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": "The indices of the values to extract.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis over which to select values. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Gather slices from tensor `x`'s axis `axis` according to `indices`.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst indices = tf.tensor1d([1, 3, 3]);\n\nx.gather(indices).print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\nconst indices = tf.tensor1d([1, 1, 0]);\n\nx.gather(indices).print();\n```",
              "fileName": "#759",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L759-L765",
              "isFunction": true,
              "displayName": "tf.gather",
              "urlHash": "gather"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "reverse",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be reversed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The set of dimensions to reverse. Must be in the\nrange [-rank(x), rank(x)). Defaults to all axes.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Reverses a [tf.Tensor](#class:Tensor) along a specified axis.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.reverse().print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.reverse(axis).print();\n```",
              "fileName": "#93",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reverse.ts#L93-L106",
              "isFunction": true,
              "displayName": "tf.reverse",
              "urlHash": "reverse"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "slice",
              "paramStr": "(x, begin, size)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input [tf.Tensor](#class:Tensor) to slice from.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "begin",
                  "documentation": "The coordinates to start the slice from. The length of this\narray should match the rank of `x`.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "The size of the slice. The length of this array should match\nthe rank of `x`.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Extracts a slice from a [tf.Tensor](#class:Tensor) starting at coordinates `begin`\nand is of size `size`.\n\nAlso available are stricter rank-specific methods with the same signature\nas this method that assert that `x` is of the given rank:\n   - `tf.slice1d`\n   - `tf.slice2d`\n   - `tf.slice3d`\n   - `tf.slice4d`\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.slice([1], [2]).print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nx.slice([1, 0], [1, 2]).print();\n```",
              "fileName": "#104",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/slice.ts#L104-L128",
              "isFunction": true,
              "displayName": "tf.slice",
              "urlHash": "slice"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "split",
              "paramStr": "(x, numOrSizeSplits, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to split.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numOrSizeSplits",
                  "documentation": "Either an integer indicating the number of\nsplits along the axis or an array of integers containing the sizes of each\noutput tensor along the axis. If a number then it must evenly divide\n`x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.",
                  "type": "number[]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension along which to split. Defaults to 0 (the first\ndim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "any",
              "documentation": "Splits a [tf.Tensor](#class:Tensor) into sub tensors.\n\nIf `numOrSizeSplits` is a number, splits `x` along dimension `axis`\ninto `numOrSizeSplits` smaller tensors.\nRequires that `numOrSizeSplits` evenly divides `x.shape[axis]`.\n\nIf `numOrSizeSplits` is a number array, splits `x` into\n`(numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the\nsame size as `x` except along dimension `axis` where the size is\n`numOrSizeSplits[i]`.\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);\nconst [a, b] = tf.split(x, 2, 1);\na.print();\nb.print();\n\nconst [c, d, e] = tf.split(x, [1, 2, 1], 1);\nc.print();\nd.print();\ne.print();\n```",
              "fileName": "#930",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L930-L954",
              "isFunction": true,
              "displayName": "tf.split",
              "urlHash": "split"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "stack",
              "paramStr": "(tensors, axis?)",
              "parameters": [
                {
                  "name": "tensors",
                  "documentation": "A list of tensor objects with the same shape and dtype.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis to stack along. Defaults to 0 (the first dim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Stacks a list of rank-`R` [tf.Tensor](#class:Tensor)s into one rank-`(R+1)` [tf.Tensor](#class:Tensor).\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\nconst c = tf.tensor1d([5, 6]);\ntf.stack([a, b, c]).print();\n```",
              "fileName": "#870",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L870-L896",
              "isFunction": true,
              "displayName": "tf.stack",
              "urlHash": "stack"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "tile",
              "paramStr": "(x, reps)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to transpose.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "reps",
                  "documentation": "Determines the number of replications per dimension.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Construct an tensor by repeating it the number of times given by reps.\n\nThis operation creates a new tensor by replicating [tf.input()](#input) `reps`\ntimes. The output tensor's i'th dimension has `input.shape[i] *\nreps[i]` elements, and the values of [tf.input()](#input) are replicated\n`reps[i]` times along the i'th dimension. For example, tiling\n`[a, b, c, d]` by `[2]` produces `[a, b, c, d, a, b, c, d]`.\n\n```js\nconst a = tf.tensor1d([1, 2]);\n\na.tile([2]).print();    // or a.tile([2])\n```\n\n```js\nconst a = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\na.tile([1, 2]).print();  // or a.tile([1, 2])\n```",
              "fileName": "#679",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/array_ops.ts#L679-L737",
              "isFunction": true,
              "displayName": "tf.tile",
              "urlHash": "tile"
            }
          ]
        }
      ]
    },
    {
      "name": "Models",
      "description": "<p>Models are one of the primary abstractions used in\nTensorFlow.js Layers.  Models can be trained, evaluated, and used\nfor prediction.  A model's state (topology, and optionally, trained\nweights) can be restored from various formats.</p>\n<p>Models are a collection of Layers, see Model Creation for\ndetails about how Layers can be connected.</p>",
      "subheadings": [
        {
          "name": "Creation",
          "description": "<p>There are two primary ways of creating models.</p>\n<ul><li>Sequential &mdash; Easiest, works if the models is a\nsimple stack of each layer's input resting on the top of the\nprevious layer's output.</li>\n<li>Model &mdash; Offers more control if the layers need to be\nwired together in graph-like ways &mdash; multiple 'towers',\nlayers that skip a layer, etc.</li></ul>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Creation",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "sequential",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "layers",
                  "documentation": "Stack of layers for the model. ",
                  "type": "[tf.layers.Layer](#class:layers.Layer)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "The name of this model. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.Sequential](#class:Sequential)",
              "documentation": "Creates a [tf.Sequential](#class:Sequential) model.  A sequential model is any model where the\noutputs of one layer are the inputs to the next layer, i.e. the model\ntopology is a simple 'stack' of layers, with no branching or skipping.\n\nThis means that the first layer passed to a Sequential model should have a\ndefined input shape. What that means is that it should have received an\n`inputShape` or `batchInputShape` argument, or for some type of layers\n(recurrent, Dense...) an `inputDim` argument.\n\nThe key difference between [tf.model()](#model) and [tf.sequential()](#sequential) is that [tf.sequential()](#sequential)\nis less generic, supporting only a linear stack of layers. [tf.model()](#model) is\nmore generic and supports an arbitrary graph (without cycles) of layers.\n\nExamples:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have an input shape defined.\nmodel.add(tf.layers.dense({units: 32, inputShape: [50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output, which equals\n// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the\n// 2nd is the output size of the model's last layer.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nIt is also possible to specify a batch size (with potentially undetermined\nbatch dimension, denoted by \"null\") for the first layer using the\n`batchInputShape` key. The following example is equivalent to the above:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nYou can also use an `Array` of already-constructed `Layer`s to create\na [tf.Sequential](#class:Sequential) model:\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 32, inputShape: [50]}),\n            tf.layers.dense({units: 4})]\n});\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
              "fileName": "#146",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L146-L149",
              "isFunction": true,
              "displayName": "tf.sequential",
              "urlHash": "sequential"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Creation",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "model",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputs",
                  "documentation": "",
                  "type": "[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "outputs",
                  "documentation": "",
                  "type": "[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.Model](#class:Model)",
              "documentation": "A model is a data structure that consists of `Layers` and defines inputs\nand outputs.\n\nThe key difference between [tf.model()](#model) and [tf.sequential()](#sequential) is that [tf.model()](#model)\nis more generic, supporting an arbitrary graph (without cycles) of layers.\n[tf.sequential()](#sequential) is less generic and supports only a linear stack of layers.\n\nWhen creating a [tf.Model](#class:Model), specify its input(s) and output(s). Layers\nare used to wire input(s) to output(s).\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\nSee also:\n   [tf.sequential()](#sequential), [tf.loadModel()](#loadModel).",
              "fileName": "#84",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L84-L87",
              "isFunction": true,
              "displayName": "tf.model",
              "urlHash": "model"
            }
          ]
        },
        {
          "name": "Inputs",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Inputs",
                "useDocsFrom": "Input",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "input",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "InputConfig",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "A shape, not including the batch size. For instance, `shape=[32]`\nindicates that the expected input will be batches of 32-dimensional\nvectors.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchShape",
                  "documentation": "A shape tuple (integer), including the batch size. For instance,\n`batchShape=[10, 32]` indicates that the expected input will be batches of\n10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\narbitrary number of 32-dimensional vectors.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "An optional name string for the layer. Should be unique in a model (do not\nreuse the same name twice). It will be autogenerated if it isn't provided.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "sparse",
                  "documentation": "A boolean specifying whether the placeholder to be created is sparse.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.SymbolicTensor](#class:SymbolicTensor)",
              "documentation": "Used to instantiate an input to a model as a [tf.SymbolicTensor](#class:SymbolicTensor).\n\nUsers should call the [tf.input()](#input) factory function for\nconsistency with other generator functions.\n\nExample:\n\n```js\n// Defines a simple logistic regression model with 32 dimensional input\n// and 3 dimensional output.\nconst x = tf.input({shape: [32]});\nconst y = tf.layers.dense({units: 3, activation: 'softmax'}).apply(x);\nconst model = tf.model({inputs: x, outputs: y});\nmodel.predict(tf.ones([2, 32])).print();\n```\n\nNote: [tf.input()](#input) is only necessary when using [tf.model()](#model). When using\n[tf.sequential()](#sequential), specify `inputShape` for the first layer or use `inputLayer`\nas the first layer.",
              "fileName": "#160",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L160-L168",
              "isFunction": true,
              "displayName": "tf.input",
              "urlHash": "input"
            }
          ]
        },
        {
          "name": "Loading",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading",
                "useDocsFrom": "loadModelInternal"
              },
              "symbolName": "loadModel",
              "paramStr": "(modelConfigPath)",
              "parameters": [
                {
                  "name": "modelConfigPath",
                  "documentation": "A path to the `ModelAndWeightsConfig` JSON describing\nthe model in the canonical TensorFlow.js format.\n\nThe content of the JSON file is assumed to be a JSON object with the\nfollowing fields and values:\n- 'modelTopology': A JSON object that can be either of:\n1. a model architecture JSON consistent with the format of the return\nvalue of `keras.Model.to_json()`\n2. a full model JSON in the format of `keras.models.save_model()`.\n- 'weightsManifest': A TensorFlow.js weights manifest.\n\nSee the Python converter function `save_model()` for more details.\n\nIt is also assumed that model weights can be accessed from relative paths\ndescribed by the `paths` fields in weights manifest.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise",
              "documentation": "Load a model, including its topology and optionally weights.  See the\nTutorial named \"How to import a Keras Model\" for usage examples.",
              "fileName": "#151",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L151-L158",
              "isFunction": true,
              "displayName": "tf.loadModel",
              "urlHash": "loadModel"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "Model",
              "documentation": "A [tf.Model](#class:Model) is a directed, acyclic graph of `Layer`s plus methods for\ntraining, evaluation, prediction and saving.\n\n[tf.Model](#class:Model) is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a [tf.Model](#class:Model), use [tf.model()](#model).\n\nSee also:\n   [tf.Sequential](#class:Sequential), [tf.loadModel()](#loadModel).",
              "fileName": "#621",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L621-L1634",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      0
                    ]
                  },
                  "symbolName": "compile",
                  "paramStr": "(config)",
                  "parameters": [
                    {
                      "name": "config",
                      "documentation": "a `ModelCompileConfig` specifying the loss, optimizer, and\nmetrics to be used for fitting and evaluating this model.",
                      "type": "Object",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "optimizer",
                      "documentation": "An instance of `tf.train.Optimizer` or a string name for an Optimizer.",
                      "type": "string|[tf.train.Optimizer](#class:train.Optimizer)",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "loss",
                      "documentation": "String (name of objective function) or objective function.\nIf the model has multiple outputs, you can use a different loss\non each output by passing a dictionary or an Array of losses.\nThe loss value that will be minimized by the model will then be the sum\nof all individual losses.",
                      "type": "string|string[]|{[outputName: string]: string}",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "metrics",
                      "documentation": "List of metrics to be evaluated by the model during training and testing.\nTypically you will use `metrics=['accuracy']`.\nTo specify different metrics for different outputs of a multi-output\nmodel, you could also pass a dictionary.",
                      "type": "string[]|{[outputName: string]: string}",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Configures and prepares the model for training and evaluation.  Compiling\noutfits the model with an optimizer, loss, and/or metrics.  Calling `fit`\nor `evaluate` on an un-compiled model will throw an error.",
                  "fileName": "#660",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L660-L858",
                  "isFunction": true,
                  "urlHash": "tf.Model.compile"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      2
                    ]
                  },
                  "symbolName": "evaluate",
                  "paramStr": "(x, y, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of test data, or an `Array` of [tf.Tensor](#class:Tensor)s if the model has\nmultiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target data, or an `Array` of [tf.Tensor](#class:Tensor)s if the model\nhas multiple outputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "A `ModelEvaluateConfig`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "Verbosity mode.",
                      "type": "ModelLoggingVerbosity",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "documentation": "Tensor of weights to weight the contribution of different samples to the\nloss and metrics.",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "steps",
                      "documentation": "integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Scalar](#class:Tensor)|[tf.Scalar](#class:Tensor)[]",
                  "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nconst result = model.evaluate(\n     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});\nresult.print();\n```",
                  "fileName": "#911",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L911-L928",
                  "isFunction": true,
                  "urlHash": "tf.Model.evaluate"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      1
                    ]
                  },
                  "symbolName": "predict",
                  "paramStr": "(x, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "The input data, as an Tensor, or an `Array` of [tf.Tensor](#class:Tensor)s if\nthe model has multiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "A `ModelPredictConfig` object containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "Verbosity mode. Defaults to false.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)\n      |[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nNote: the \"step\" mode of predict() is currently not supported.\n   This is because the TensorFlow.js core backend is imperative only.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predict(tf.ones([8, 10]), {batchSize: 4}).print();\n```",
                  "fileName": "#1053",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L1053-L1063",
                  "isFunction": true,
                  "urlHash": "tf.Model.predict"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "predictOnBatch",
                  "paramStr": "(x)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": ": Input samples, as an Tensor",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Returns predictions for a single batch of samples.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predictOnBatch(tf.ones([8, 10])).print();\n```",
                  "fileName": "#1077",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L1077-L1083",
                  "isFunction": true,
                  "urlHash": "tf.Model.predictOnBatch"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      2
                    ]
                  },
                  "symbolName": "fit",
                  "paramStr": "(x, y, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of training data, or an array of [tf.Tensor](#class:Tensor)s if the model\nhas multiple inputs. If all inputs in the model are named, you can also\npass a dictionary mapping input names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target (label) data, or an array of [tf.Tensor](#class:Tensor)s if the\nmodel has multiple outputs. If all outputs in the model are named, you\ncan also pass a dictionary mapping output names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "A `ModelFitConfig`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Number of samples per gradient update. If unspecified, it\nwill default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "epochs",
                      "documentation": "The number of times to iterate over the training data arrays. ",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "",
                      "type": "ModelLoggingVerbosity",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "callbacks",
                      "documentation": "List of callbacks to be called during training. ",
                      "type": "Callback[]|CustomCallbackConfig|CustomCallbackConfig[]",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSplit",
                      "documentation": "Float between 0 and 1: fraction of the training data\nto be used as validation data. The model will set apart this fraction of\nthe training data, will not train on it, and will evaluate the loss and\nany model metrics on this data at the end of each epoch.\nThe validation data is selected from the last samples in the `x` and `y`\ndata provided, before shuffling.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationData",
                      "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be a tuple [xVal, yVal] or a tuple [xVal, yVal,\nvalSampleWeights]. The model will not be trained on this data.\n`validationData` will override `validationSplit`.",
                      "type": "[\n    [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]\n  ]|[[tf.Tensor](#class:Tensor) | [tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]]",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "shuffle",
                      "documentation": "Whether to shuffle the training data before each epoch. Has\nno effect when `stepsPerEpoch` is not `null`.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "classWeight",
                      "documentation": "Optional dictionary mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.",
                      "type": "{[classIndex: string]: number}",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "documentation": "Optional array of the same length as x, containing\nweights to apply to the model's loss for each sample. In the case of\ntemporal data, you can pass a 2D array with shape (samples,\nsequenceLength), to apply a different weight to every timestep of every\nsample. In this case you should make sure to specify\nsampleWeightMode=\"temporal\" in compile().",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "initialEpoch",
                      "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun).",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "stepsPerEpoch",
                      "documentation": "Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. When training\nwith Input Tensors such as TensorFlow data tensors, the default `null` is\nequal to the number of unique samples in your dataset divided by the\nbatch size, or 1 if that cannot be determined.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSteps",
                      "documentation": "Only relevant if `stepsPerEpoch` is specified. Total number of steps\n(batches of samples) to validate before stopping.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise",
                  "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).\n\n```js\nconst model = tf.sequential({\n     layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nfor (let i = 1; i < 5 ; ++i) {\n   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n       batchSize: 4,\n       epochs: 3\n   });\n   console.log(\"Loss after Epoch \" + i + \" : \" + h.history.loss[0]);\n}\n```",
                  "fileName": "#1450",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/training.ts#L1450-L1633",
                  "isFunction": true,
                  "urlHash": "tf.Model.fit"
                }
              ],
              "isClass": true,
              "inheritsFrom": "Container",
              "displayName": "tf.Model",
              "urlHash": "class:Model"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "Sequential",
              "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n[tf.sequential()](#sequential) is a factory function that creates an instance of\n[tf.Sequential](#class:Sequential).",
              "fileName": "#167",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/models.ts#L167-L539",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "add",
                  "paramStr": "(layer)",
                  "parameters": [
                    {
                      "name": "layer",
                      "documentation": "Layer instance.",
                      "type": "[tf.layers.Layer](#class:layers.Layer)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Adds a layer instance on top of the layer stack.",
                  "fileName": "#201",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/models.ts#L201-L276",
                  "isFunction": true,
                  "urlHash": "tf.Sequential.add"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      2
                    ]
                  },
                  "symbolName": "evaluate",
                  "paramStr": "(x, y, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of test data, or an `Array` of [tf.Tensor](#class:Tensor)s if the model has\nmultiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target data, or an `Array` of [tf.Tensor](#class:Tensor)s if the model\nhas multiple outputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "A `ModelEvaluateConfig`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "Verbosity mode.",
                      "type": "ModelLoggingVerbosity",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "documentation": "Tensor of weights to weight the contribution of different samples to the\nloss and metrics.",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "steps",
                      "documentation": "integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Scalar](#class:Tensor)|[tf.Scalar](#class:Tensor)[]",
                  "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nconst result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n   batchSize: 4,\n});\nresult.print();\n```",
                  "fileName": "#398",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/models.ts#L398-L407",
                  "isFunction": true,
                  "urlHash": "tf.Sequential.evaluate"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      1
                    ]
                  },
                  "symbolName": "predict",
                  "paramStr": "(x, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "The input data, as an Tensor, or an `Array` of [tf.Tensor](#class:Tensor)s if\nthe model has multiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "Verbosity mode. Defaults to false.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)\n      |[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nNote: the \"step\" mode of predict() is currently not supported.\n   This is because the TensorFow.js core backend is imperative only.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predict(tf.ones([2, 10])).print();\n```",
                  "fileName": "#434",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/models.ts#L434-L441",
                  "isFunction": true,
                  "urlHash": "tf.Sequential.predict"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "configParamIndices": [
                      2
                    ]
                  },
                  "symbolName": "fit",
                  "paramStr": "(x, y, config?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of training data, or an array of [tf.Tensor](#class:Tensor)s if the model\nhas multiple inputs. If all inputs in the model are named, you can also\npass a dictionary mapping input names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target (label) data, or an array of [tf.Tensor](#class:Tensor)s if the\nmodel has multiple outputs. If all outputs in the model are named, you\ncan also pass a dictionary mapping output names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "A `ModelFitConfig`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "documentation": "Number of samples per gradient update. If unspecified, it\nwill default to 32.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "epochs",
                      "documentation": "The number of times to iterate over the training data arrays. ",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "documentation": "",
                      "type": "ModelLoggingVerbosity",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "callbacks",
                      "documentation": "List of callbacks to be called during training. ",
                      "type": "Callback[]|CustomCallbackConfig|CustomCallbackConfig[]",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSplit",
                      "documentation": "Float between 0 and 1: fraction of the training data\nto be used as validation data. The model will set apart this fraction of\nthe training data, will not train on it, and will evaluate the loss and\nany model metrics on this data at the end of each epoch.\nThe validation data is selected from the last samples in the `x` and `y`\ndata provided, before shuffling.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationData",
                      "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be a tuple [xVal, yVal] or a tuple [xVal, yVal,\nvalSampleWeights]. The model will not be trained on this data.\n`validationData` will override `validationSplit`.",
                      "type": "[\n    [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]\n  ]|[[tf.Tensor](#class:Tensor) | [tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]]",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "shuffle",
                      "documentation": "Whether to shuffle the training data before each epoch. Has\nno effect when `stepsPerEpoch` is not `null`.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "classWeight",
                      "documentation": "Optional dictionary mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.",
                      "type": "{[classIndex: string]: number}",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "documentation": "Optional array of the same length as x, containing\nweights to apply to the model's loss for each sample. In the case of\ntemporal data, you can pass a 2D array with shape (samples,\nsequenceLength), to apply a different weight to every timestep of every\nsample. In this case you should make sure to specify\nsampleWeightMode=\"temporal\" in compile().",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "initialEpoch",
                      "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun).",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "stepsPerEpoch",
                      "documentation": "Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. When training\nwith Input Tensors such as TensorFlow data tensors, the default `null` is\nequal to the number of unique samples in your dataset divided by the\nbatch size, or 1 if that cannot be determined.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSteps",
                      "documentation": "Only relevant if `stepsPerEpoch` is specified. Total number of steps\n(batches of samples) to validate before stopping.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise",
                  "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nconst history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n   batchSize: 4,\n   epochs: 3\n});\n```",
                  "fileName": "#503",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/models.ts#L503-L514",
                  "isFunction": true,
                  "urlHash": "tf.Sequential.fit"
                }
              ],
              "isClass": true,
              "inheritsFrom": "[tf.Model](#class:Model)",
              "displayName": "tf.Sequential",
              "urlHash": "class:Sequential"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "SymbolicTensor",
              "documentation": "[tf.SymbolicTensor](#class:SymbolicTensor) is a placeholder for a Tensor without any concrete value.\n\nThey are most often encountered when building a graph of `Layer`s for a\na [tf.Model](#class:Model) and the input data's shape, but not values are known.",
              "fileName": "#67",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/types.ts#L67-L111",
              "methods": [],
              "isClass": true,
              "inheritsFrom": "TensorInterface",
              "displayName": "tf.SymbolicTensor",
              "urlHash": "class:SymbolicTensor"
            }
          ]
        }
      ]
    },
    {
      "name": "Layers",
      "description": "<p>Layers are the primary building block for \nconstructing a Model.  Each layer will typically perform some\ncomputation to transform its input to its output.</p>\n<p>Layers will automatically take care of creating and initializing\nthe various internal variables/weights they need to function.</p>",
      "subheadings": [
        {
          "name": "Advanced Activation",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers",
                "useDocsFrom": "ELU",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "elu",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `1.0`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Exponetial Linear Unit (ELU).\n\nIt follows:\n`f(x) =  alpha * (exp(x) - 1.) for x < 0`,\n`f(x) = x for x >= 0`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Fast and Accurate Deep Network Learning by Exponential Linear Units\n(ELUs)](https://arxiv.org/abs/1511.07289v1)",
              "fileName": "#196",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L196-L205",
              "isFunction": true,
              "displayName": "tf.layers.elu",
              "urlHash": "layers.elu"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers",
                "useDocsFrom": "LeakyReLU",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "leakyReLU",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `0.3`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Leaky version of a rectified linear unit.\n\nIt allows a small gradient when the unit is not active:\n`f(x) = alpha * x for x < 0.`\n`f(x) = x for x >= 0.`\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#207",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L207-L216",
              "isFunction": true,
              "displayName": "tf.layers.leakyReLU",
              "urlHash": "layers.leakyReLU"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers",
                "useDocsFrom": "Softmax",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "softmax",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Integer, axis along which the softmax normalization is applied.\nDefaults to `-1` (i.e., the last axis).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Softmax activation layer.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#218",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L218-L227",
              "isFunction": true,
              "displayName": "tf.layers.softmax",
              "urlHash": "layers.softmax"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers",
                "useDocsFrom": "ThresholdedReLU",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "thresohldedReLU",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "theta",
                  "documentation": "Float >= 0. Threshold location of activation.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Thresholded Rectified Linear Unit.\n\nIt follows:\n`f(x) = x for x > theta`,\n`f(x) = 0 otherwise`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Zero-Bias Autoencoders and the Benefits of Co-Adapting\nFeatures](http://arxiv.org/abs/1402.3337)",
              "fileName": "#229",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L229-L238",
              "isFunction": true,
              "displayName": "tf.layers.thresohldedReLU",
              "urlHash": "layers.thresohldedReLU"
            }
          ]
        },
        {
          "name": "Basic",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "Activation",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "activation",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "activation",
                  "documentation": "Name of the activation function to use.",
                  "type": "'elu'|'hardsigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|string",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Applies an activation function to an output.",
              "fileName": "#300",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L300-L309",
              "isFunction": true,
              "displayName": "tf.layers.activation",
              "urlHash": "layers.activation"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "Dense",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "dense",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "documentation": "Positive integer, dimensionality of the output space. ",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function to use.\n\nIf unspecified, no activation is applied.",
                  "type": "'elu'|'hardsigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether to apply a bias. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the dense kernel weights matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "documentation": "If specified, defines inputShape as `[inputDim]`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint for the kernel weights.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraint for the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the dense kernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Creates a dense (fully connected) layer.\n\nThis layer implements the operation:\n   `output = activation(dot(input, kernel) + bias)`\n\n`activation` is the element-wise activation function\n   passed as the `activation` argument.\n\n`kernel` is a weights matrix created by the layer.\n\n`bias` is a bias vector created by the layer (only applicable if `useBias`\nis `true`).\n\n**Input shape:**\n\n   nD [tf.Tensor](#class:Tensor) with shape: `(batchSize, ..., inputDim)`.\n\n   The most common situation would be\n   a 2D input with shape `(batchSize, inputDim)`.\n\n**Output shape:**\n\n   nD tensor with shape: `(batchSize, ..., units)`.\n\n   For instance, for a 2D input with shape `(batchSize, inputDim)`,\n   the output would have shape `(batchSize, units)`.\n\nNote: if the input to the layer has a rank greater than 2, then it is\nflattened prior to the initial dot product with the kernel.",
              "fileName": "#311",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L311-L320",
              "isFunction": true,
              "displayName": "tf.layers.dense",
              "urlHash": "layers.dense"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "Dropout",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "dropout",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "documentation": "Float between 0 and 1. Fraction of the input units to drop. ",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "noiseShape",
                  "documentation": "Integer array representing the shape of the binary dropout mask that will\nbe multiplied with the input.\n\nFor instance, if your inputs have shape `(batchSize, timesteps, features)`\nand you want the dropout mask to be the same for all timesteps, you can use\n`noise_shape=(batch_size, 1, features)`.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "documentation": "An integer to use as random seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Applies\n[dropout](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf) to\nthe input.\n\nDropout consists in randomly setting a fraction `rate` of input units to 0 at\neach update during training time, which helps prevent overfitting.",
              "fileName": "#322",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L322-L331",
              "isFunction": true,
              "displayName": "tf.layers.dropout",
              "urlHash": "layers.dropout"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "Embedding",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "embedding",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputDim",
                  "documentation": "Integer > 0. Size of the vocabulary, i.e. maximum integer index + 1.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "outputDim",
                  "documentation": "Integer >= 0. Dimension of the dense embedding.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsInitializer",
                  "documentation": "Initializer for the `embeddings` matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsRegularizer",
                  "documentation": "Regularizer function applied to the `embeddings` matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsConstraint",
                  "documentation": "Constraint function applied to the `embeddings` matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "maskZero",
                  "documentation": "Whether the input value 0 is a special \"padding\" value that should be\nmasked out. This is useful when using recurrent layers which may take\nvariable length input.\n\nIf this is `True` then all subsequent layers in the model need to support\nmasking or an exception will be raised. If maskZero is set to `True`, as a\nconsequence, index 0 cannot be used in the vocabulary (inputDim should\nequal size of vocabulary + 1).",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "documentation": "Length of input sequences, when it is constant.\n\nThis argument is required if you are going to connect `flatten` then\n`dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed).",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Maps positive integers (indices) into dense vectors of fixed size.\neg. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]\n\n**Input shape:** 2D tensor with shape: `[batchSize, sequenceLength]`.\n\n**Output shape:** 3D tensor with shape: `[batchSize, sequenceLength,\noutputDim]`.",
              "fileName": "#355",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L355-L364",
              "isFunction": true,
              "displayName": "tf.layers.embedding",
              "urlHash": "layers.embedding"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "Flatten",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "flatten",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Flattens the input. Does not affect the batch size.\n\nA `Flatten` layer flattens each batch in its inputs to 1D (making the output\n2D).\n\nFor example:\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst flattenLayer = tf.layers.flatten();\n// Inspect the inferred output shape of the flatten layer, which\n// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the\n// flattening. (The 1st dimension is the undermined batch size.)\nconsole.log(JSON.stringify(flattenLayer.apply(input).shape));\n```",
              "fileName": "#333",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L333-L342",
              "isFunction": true,
              "displayName": "tf.layers.flatten",
              "urlHash": "layers.flatten"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers",
                "useDocsFrom": "RepeatVector",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "repeatVector",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "n",
                  "documentation": "The integer number of times to repeat the input.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Repeat the input n times.",
              "fileName": "#344",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L344-L353",
              "isFunction": true,
              "displayName": "tf.layers.repeatVector",
              "urlHash": "layers.repeatVector"
            }
          ]
        },
        {
          "name": "Convolutional",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "Conv1D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "conv1d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "kernelSize",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "type": "number|number[]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "Padding mode.",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether the layer uses a bias vector. Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraint for the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "1D convolution layer (e.g., temporal convolution).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input over a single spatial (or temporal) dimension\nto produce a tensor of outputs.\n\nIf `use_bias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model, provide an `inputShape`\nargument `Array` or `null`.\n\nFor example, `inputShape` would be:\n- `[10, 128]` for sequences of 10 vectors of 128-dimensional vectors\n- `[null, 128]` for variable-length sequences of 128-dimensional vectors.",
              "fileName": "#242",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L242-L251",
              "isFunction": true,
              "displayName": "tf.layers.conv1d",
              "urlHash": "layers.conv1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "Conv2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "conv2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "kernelSize",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "type": "number|number[]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "Padding mode.",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether the layer uses a bias vector. Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraint for the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat='channelsLast'`.",
              "fileName": "#253",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L253-L262",
              "isFunction": true,
              "displayName": "tf.layers.conv2d",
              "urlHash": "layers.conv2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "Conv2DTranspose",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "conv2dTranspose",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "kernelSize",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "type": "number|number[]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "Padding mode.",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether the layer uses a bias vector. Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraint for the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Transposed convolutional layer (sometimes called Deconvolution).\n\nThe need for transposed convolutions generally arises\nfrom the desire to use a transformation going in the opposite direction of a\nnormal convolution, i.e., from something that has the shape of the output of\nsome convolution to something that has the shape of its input while\nmaintaining a connectivity pattern that is compatible with said convolution.\n\nWhen using this layer as the first layer in a model, provide the\nconfiguration `inputShape` (`Array` of integers, does not include the sample\naxis), e.g., `inputShape: [128, 128, 3]` for 128x128 RGB pictures in\n`dataFormat: 'channelsLast'`.\n\nInput shape:\n   4D tensor with shape:\n   `[batch, channels, rows, cols]` if `dataFormat` is `'channelsFirst'`.\n   or 4D tensor with shape\n   `[batch, rows, cols, channels]` if `dataFormat` is `'channelsLast`.\n\nOutput shape:\n   4D tensor with shape:\n   `[batch, filters, newRows, newCols]` if `dataFormat` is `'channelsFirst'`.\n   or 4D tensor with shape:\n   `[batch, newRows, newCols, filters]` if `dataFormat` is `'channelsLast'`.\n\nReferences:\n   - [A guide to convolution arithmetic for deep\nlearning](https://arxiv.org/abs/1603.07285v1)\n   - [Deconvolutional\nNetworks](http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf)",
              "fileName": "#264",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L264-L273",
              "isFunction": true,
              "displayName": "tf.layers.conv2dTranspose",
              "urlHash": "layers.conv2dTranspose"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "DepthwiseConv2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "depthwiseConv2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "kernelSize",
                  "documentation": "An integer or Array of 2 integers, specifying the width and height of the\n2D convolution window. Can be a single integer to specify the same value\nfor all spatial dimensions.",
                  "type": "number|[number, number]",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthMultiplier",
                  "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal to\n`filtersIn * depthMultiplier`.\nDefault: 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseInitializer",
                  "documentation": "Initializer for the depthwise kernel matrix.\nDefault: GlorotNormal.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseConstraint",
                  "documentation": "Constraint for the depthwise kernel matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseRegularizer",
                  "documentation": "Regulzarizer function for the depthwise kernel matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Depthwise separable 2D convolution.\n\nDepthwise Separable convolutions consists in performing just the first step\nin a depthwise spatial convolution (which acts on each input channel\nseparately). The `depthMultplier` argument controls how many output channels\nare generated per input channel in the depthwise step.",
              "fileName": "#288",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L288-L297",
              "isFunction": true,
              "displayName": "tf.layers.depthwiseConv2d",
              "urlHash": "layers.depthwiseConv2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "SeparableConv2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "separableConv2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depthMultiplier",
                  "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal to\n`filtersIn * depthMultiplier`.\nDefault: 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseInitializer",
                  "documentation": "Initializer for the depthwise kernel matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseInitializer",
                  "documentation": "Initializer for the pointwise kernel matrix.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseRegularizer",
                  "documentation": "Regularizer function applied to the depthwise kernel matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseRegularizer",
                  "documentation": "Regularizer function applied to the pointwise kernel matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseConstraint",
                  "documentation": "Constraint function applied to the depthwise kernel matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseConstraint",
                  "documentation": "Constraint function applied to the pointwise kernel matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Depthwise separable 2D convolution.\n\nSeparable convolution consists of first performing\na depthwise spatial convolution\n(which acts on each input channel separately)\nfollowed by a pointwise convolution which mixes together the resulting\noutput channels. The `depthMultiplier` argument controls how many\noutput channels are generated per input channel in the depthwise step.\n\nIntuitively, separable convolutions can be understood as\na way to factorize a convolution kernel into two smaller kernels,\nor as an extreme version of an Inception block.\n\nInput shape:\n   4D tensor with shape:\n     `[batch, channels, rows, cols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, rows, cols, channels]` if data_format='channelsLast'.\n\nOutput shape:\n   4D tensor with shape:\n     `[batch, filters, newRows, newCols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, newRows, newCols, filters]` if data_format='channelsLast'.\n     `rows` and `cols` values might have changed due to padding.",
              "fileName": "#275",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L275-L284",
              "isFunction": true,
              "displayName": "tf.layers.separableConv2d",
              "urlHash": "layers.separableConv2d"
            }
          ]
        },
        {
          "name": "Merge",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Add",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "add",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that performs element-wise addition on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). The inputs are specified as an\n`Array` when the `apply` method of the `Add` layer instance is called. For\nexample:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst addLayer = tf.layers.add();\nconst sum = addLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(sum.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#368",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L368-L377",
              "isFunction": true,
              "displayName": "tf.layers.add",
              "urlHash": "layers.add"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Average",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "average",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that performs element-wise averaging on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst averageLayer = tf.layers.average();\nconst average = averageLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(average.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#379",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L379-L388",
              "isFunction": true,
              "displayName": "tf.layers.average",
              "urlHash": "layers.average"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Concatenate",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "concatenate",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Axis along which to concatenate.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that concatenates an `Array` of inputs.\n\nIt takes a list of tensors, all of the same shape except for the\nconcatenation axis, and returns a single tensor, the concatenation\nof all inputs. For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 3]});\nconst concatLayer = tf.layers.concatenate();\nconst output = concatLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(output.shape));\n// You get [null, 2, 5], with the first dimension as the undetermined batch\n// dimension. The last dimension (5) is the result of concatenating the\n// last dimensions of the inputs (2 and 3).\n```",
              "fileName": "#390",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L390-L399",
              "isFunction": true,
              "displayName": "tf.layers.concatenate",
              "urlHash": "layers.concatenate"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Maximum",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "maximum",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that computes the element-wise maximum an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst maxLayer = tf.layers.maximum();\nconst max = maxLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(max.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#401",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L401-L410",
              "isFunction": true,
              "displayName": "tf.layers.maximum",
              "urlHash": "layers.maximum"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Minimum",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "minimum",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that computes the element-wise minimum of an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst minLayer = tf.layers.minimum();\nconst min = minLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(min.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#412",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L412-L421",
              "isFunction": true,
              "displayName": "tf.layers.minimum",
              "urlHash": "layers.minimum"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers",
                "useDocsFrom": "Multiply",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "multiply",
              "namespace": "layers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Layer that multiplies (element-wise) an `Array` of inputs.\n\nIt takes as input an Array of tensors, all of the same\nshape, and returns a single tensor (also of the same shape).\nFor example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst input3 = tf.input({shape: [2, 2]});\nconst multiplyLayer = tf.layers.multiply();\nconst product = multiplyLayer.apply([input1, input2, input3]);\nconsole.log(product.shape);\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.",
              "fileName": "#423",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L423-L432",
              "isFunction": true,
              "displayName": "tf.layers.multiply",
              "urlHash": "layers.multiply"
            }
          ]
        },
        {
          "name": "Normalization",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Normalization",
                "namespace": "layers",
                "useDocsFrom": "BatchNormalization",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "batchNormalization",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The integer axis that should be normalized (typically the features axis).\nDefaults to -1.\n\nFor instance, after a `Conv2D` layer with `data_format=\"channels_first\"`,\nset `axis=1` in [tf.batchNormalization()](#batchNormalization).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "momentum",
                  "documentation": "Momentum of the moving average. Defaults to 0.99.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "epsilon",
                  "documentation": "Small float added to the variance to avoid dividing by zero. Defaults to\n1e-3.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "center",
                  "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefaults to `true`.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "scale",
                  "documentation": "If `true`, multiply by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear (also e.g. `nn.relu`),\nthis can be disabled since the scaling will be done by the next layer.\nDefaults to `true`.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "betaInitializer",
                  "documentation": "Initializer for the beta weight.\n  Defaults to 'zeros'.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "gammaInitializer",
                  "documentation": "Initializer for the gamma weight.\n  Defaults to [tf.ones()](#ones).",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "movingMeanInitializer",
                  "documentation": "Initializer for the moving mean.\nDefaults to [tf.zeros()](#zeros)",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "movingVarianceInitializer",
                  "documentation": "Initializer for the moving variance.\n  Defaults to 'Ones'.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "betaConstraint",
                  "documentation": "Constraint for the beta weight.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "gammaConstraint",
                  "documentation": "Constraint for gamma weight.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "betaRegularizer",
                  "documentation": "Regularizer for the beta weight.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "gammaRegularizer",
                  "documentation": "Regularizer for the gamma weight.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Batch normalization layer (Ioffe and Szegedy, 2014).\n\nNormalize the activations of the previous layer at each batch,\ni.e. applies a transformation that maintains the mean activation\nclose to 0 and the activation standard deviation close to 1.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape` (Array of integers, does\n   not include the sample axis) when calling the constructor of this class,\n   if this layer is used as a first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Batch Normalization: Accelerating Deep Network Training by Reducing\nInternal Covariate Shift](https://arxiv.org/abs/1502.03167)",
              "fileName": "#436",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L436-L445",
              "isFunction": true,
              "displayName": "tf.layers.batchNormalization",
              "urlHash": "layers.batchNormalization"
            }
          ]
        },
        {
          "name": "Pooling",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "AveragePooling1D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "averagePooling1d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "documentation": "Size of the window to pool over, should be an integer.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "Period at which to sample the pooled values.\n\nIf `null`, defaults to `poolSize`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "How to fill in data that's not an integer multiple of poolSize. ",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Average pooling operation for spatial data.\n\nInput shape: `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`\n\n`tf.avgPool1d` is an alias.",
              "fileName": "#461",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L461-L470",
              "isFunction": true,
              "displayName": "tf.layers.averagePooling1d",
              "urlHash": "layers.averagePooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "AveragePooling2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "averagePooling2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "documentation": "Factors by which to downscale in each dimension [vertical, horizontal].\nExpects an integer or an array of 2 integers.\n\nFor example, `[2, 2]` will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects an\ninteger or an array of 2 integers. Integer, tuple of 2 integers, or None.\n\nIf `null`, defaults to `poolSize`.",
                  "type": "[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "The padding type to use for the pooling layer. ",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "The data format to use for the pooling layer. ",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Average pooling operation for spatial data.\n\nInput shape:\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, rows, cols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, rows, cols]`\n\nOutput shape\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, pooleRows, pooledCols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, pooleRows, pooledCols]`\n\n`tf.avgPool2d` is an alias.",
              "fileName": "#480",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L480-L489",
              "isFunction": true,
              "displayName": "tf.layers.averagePooling2d",
              "urlHash": "layers.averagePooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "GlobalAveragePooling1D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "globalAveragePooling1d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Global average pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape:2D tensor with shape: `[batchSize, features]`.",
              "fileName": "#499",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L499-L508",
              "isFunction": true,
              "displayName": "tf.layers.globalAveragePooling1d",
              "urlHash": "layers.globalAveragePooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "GlobalAveragePooling2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "globalAveragePooling2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels[` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Global average pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
              "fileName": "#510",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L510-L519",
              "isFunction": true,
              "displayName": "tf.layers.globalAveragePooling2d",
              "urlHash": "layers.globalAveragePooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "GlobalMaxPooling1D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "globalMaxPooling1d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specifiedd,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name for this layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "documentation": "Whether this layer is trainable. Defaults to true. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "updatable",
                  "documentation": "Whether the weights of this layer are updatable by `fit`. ",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "documentation": "Initial weight values of the layer.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "documentation": "Legacy support. Do not use for new code. ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Global max pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape:2D tensor with shape: `[batchSize, features]`.",
              "fileName": "#521",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L521-L530",
              "isFunction": true,
              "displayName": "tf.layers.globalMaxPooling1d",
              "urlHash": "layers.globalMaxPooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "GlobalMaxPooling2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "globalMaxPooling2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels[` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Global max pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
              "fileName": "#532",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L532-L541",
              "isFunction": true,
              "displayName": "tf.layers.globalMaxPooling2d",
              "urlHash": "layers.globalMaxPooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "MaxPooling1D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "maxPooling1d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "documentation": "Size of the window to pool over, should be an integer.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "Period at which to sample the pooled values.\n\nIf `null`, defaults to `poolSize`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "How to fill in data that's not an integer multiple of poolSize. ",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Max pooling operation for temporal data.\n\nInput shape:  `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`",
              "fileName": "#543",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L543-L552",
              "isFunction": true,
              "displayName": "tf.layers.maxPooling1d",
              "urlHash": "layers.maxPooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers",
                "useDocsFrom": "MaxPooling2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "maxPooling2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "documentation": "Factors by which to downscale in each dimension [vertical, horizontal].\nExpects an integer or an array of 2 integers.\n\nFor example, `[2, 2]` will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects an\ninteger or an array of 2 integers. Integer, tuple of 2 integers, or None.\n\nIf `null`, defaults to `poolSize`.",
                  "type": "[number, number]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "documentation": "The padding type to use for the pooling layer. ",
                  "type": "'valid'|'same'|'casual'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "The data format to use for the pooling layer. ",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Max pooling operation for spatial data.\n\nInput shape\n   - If `dataFormat === CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, rows, cols, channels]`\n   - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n       `[batchSize, channels, rows, cols]`\n\nOutput shape\n   - If `dataFormat=CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, pooleRows, pooledCols, channels]`\n   - If `dataFormat=CHANNEL_FIRST`:\n       4D tensor with shape:\n       `[batchSize, channels, pooleRows, pooledCols]`",
              "fileName": "#554",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L554-L563",
              "isFunction": true,
              "displayName": "tf.layers.maxPooling2d",
              "urlHash": "layers.maxPooling2d"
            }
          ]
        },
        {
          "name": "Recurrent",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "GRU",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "gru",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "implementation",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Gated Recurrent Unit - Cho et al. 2014.\n\nThis is an `RNN` layer consisting of one `GRUCell`. However, unlike\nthe underlying `GRUCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.gru({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the `GRUCell`'s number of units.",
              "fileName": "#567",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L567-L576",
              "isFunction": true,
              "displayName": "tf.layers.gru",
              "urlHash": "layers.gru"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "GRUCell",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "gruCell",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigomid`).\n\nIf `null`, no activation is applied.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.RNNCell](#class:RNNCell)",
              "documentation": "Cell class for `GRU`.\n\n`GRUCell` is distinct from the `RNN` subclass `GRU` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `GRU` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.gruCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `GRUCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.gruCell({units: 4}),\n   tf.layers.gruCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the last `gruCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `GRUCell`, use the\n`tf.layers.gru`.",
              "fileName": "#578",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L578-L587",
              "isFunction": true,
              "displayName": "tf.layers.gruCell",
              "urlHash": "layers.gruCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "LSTM",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "lstm",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "unitForgetBias",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.",
                  "type": "1|2",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Long-Short Term Memory layer - Hochreiter 1997.\n\nThis is an `RNN` layer consisting of one `LSTMCell`. However, unlike\nthe underlying `LSTMCell`, the `apply` method of `LSTM` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst lstm = tf.layers.lstm({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = lstm.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the `LSTMCell`'s number of units.",
              "fileName": "#589",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L589-L598",
              "isFunction": true,
              "displayName": "tf.layers.lstm",
              "urlHash": "layers.lstm"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "LSTMCell",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "lstmCell",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigomid`).\n\nIf `null`, no activation is applied.",
                  "type": "'elu'|'hardsigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "unitForgetBias",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.",
                  "type": "1|2",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.RNNCell](#class:RNNCell)",
              "documentation": "Cell class for `LSTM`.\n\n`LSTMCell` is distinct from the `RNN` subclass `LSTM` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `LSTM` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.lstmCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `LSTMCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.lstmCell({units: 4}),\n   tf.layers.lstmCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the last `lstmCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `LSTMCell`, use the\n`tf.layers.lstm`.",
              "fileName": "#600",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L600-L609",
              "isFunction": true,
              "displayName": "tf.layers.lstmCell",
              "urlHash": "layers.lstmCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "RNN",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "rnn",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cell",
                  "documentation": "",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Base class for recurrent layers.\n\nInput shape:\n   3D tensor with shape `[batchSize, timeSteps, inputDim]`.\n\nOutput shape:\n   - if `returnState`, an Array of tensors (i.e., [tf.Tensor](#class:Tensor)s). The first\n     tensor is the output. The remaining tensors are the states at the\n     last time step, each with shape `[batchSize, units]`.\n   - if `returnSequences`, the output will have shape\n     `[batchSize, timeSteps, units]`.\n   - else, the output will have shape `[batchSize, units]`.\n\nMasking:\n   This layer supports masking for input data with a variable number\n   of timesteps. To introduce masks to your data,\n   use an embedding layer with the `mask_zero` parameter\n   set to `True`.\n\nNotes on using statefulness in RNNs:\n   You can set RNN layers to be 'stateful', which means that the states\n   computed for the samples in one batch will be reused as initial states\n   for the samples in the next batch. This assumes a one-to-one mapping\n   between samples in different successive batches.\n\n   To enable statefulness:\n     - specify `stateful: true` in the layer constructor.\n     - specify a fixed batch size for your model, by passing\n       if sequential model:\n         `batchInputShape=[...]` to the first layer in your model.\n       else for functional model with 1 or more Input layers:\n         `batchShape=[...]` to all the first layers in your model.\n       This is the expected shape of your inputs *including the batch size*.\n       It should be a tuple of integers, e.g. `(32, 10, 100)`.\n     - specify `shuffle=False` when calling fit().\n\n   To reset the states of your model, call `.reset_states()` on either\n   a specific layer, or on your entire model.\n\nNote on specifying the initial state of RNNs\n   You can specify the initial state of RNN layers symbolically by\n   calling them with the option `initialState`. The value of\n   `initialState` should be a tensor or list of tensors representing\n   the initial state of the RNN layer.\n\n   You can specify the initial state of RNN layers numerically by\n   calling `resetStates` with the keyword argument `states`. The value of\n   `states` should be a numpy array or list of numpy arrays representing\n   the initial state of the RNN layer.\n\nNote on passing external constants to RNNs\n   You can pass \"external\" constants to the cell using the `constants`\n   keyword argument of `RNN.call` method. This requires that the `cell.call`\n   method accepts the same keyword argument `constants`. Such constants\n   can be used to conditon the cell transformation on additional static inputs\n   (not changing over time), a.k.a an attention mechanism.",
              "fileName": "#633",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L633-L642",
              "isFunction": true,
              "displayName": "tf.layers.rnn",
              "urlHash": "layers.rnn"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "SimpleRNN",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "simpleRNN",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "documentation": "Positive integer, dimensionality of the output space.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent ([tf.tanh()](#tanh))\n\nIf you pass `null`, no activation will be applied.",
                  "type": "'elu'|'hardsigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether the layer uses a bias vector.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint function applied to the kernel weights matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraint function applied to the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Fully-connected RNN where the output is to be fed back to input.\n\nThis is an `RNN` layer consisting of one `SimpleRNNCell`. However, unlike\nthe underlying `SimpleRNNCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.simpleRNN({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the `SimpleRNNCell`'s number of units.\n```",
              "fileName": "#611",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L611-L620",
              "isFunction": true,
              "displayName": "tf.layers.simpleRNN",
              "urlHash": "layers.simpleRNN"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "SimpleRNNCell",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "simpleRNNCell",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "documentation": "units: Positive integer, dimensionality of the output space.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
                  "type": "'elu'|'hardsigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|string",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "documentation": "Whether the layer uses a bias vector.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "Initializer for the bias vector.",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|\n    'heNormal'|'identity'|'leCunNormal'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "type": "'l1l2'|string|Regularizer",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "Constraint function applied to the `kernel` weights matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "Constraintfunction applied to the bias vector.",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.RNNCell](#class:RNNCell)",
              "documentation": "Cell class for `SimpleRNN`.\n\n`SimpleRNNCell` is distinct from the `RNN` subclass `SimpleRNN` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `SimpleRNN` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.simpleRNNCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `SimpleRNNCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.simpleRNNCell({units: 4}),\n   tf.layers.simpleRNNCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of [tf.input()](#input), due to `returnSequences`: `true`;\n// 3rd dimension is the last `SimpleRNNCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `SimpleRNNCell`, use the\n`tf.layers.simpleRNN`.",
              "fileName": "#622",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L622-L631",
              "isFunction": true,
              "displayName": "tf.layers.simpleRNNCell",
              "urlHash": "layers.simpleRNNCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers",
                "useDocsFrom": "RNN",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "stackedRNNCells",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cells",
                  "documentation": "A `Array` of [tf.RNNCell](#class:RNNCell) instances.",
                  "type": "[tf.RNNCell](#class:RNNCell)[]",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.RNNCell](#class:RNNCell)",
              "documentation": "Base class for recurrent layers.\n\nInput shape:\n   3D tensor with shape `[batchSize, timeSteps, inputDim]`.\n\nOutput shape:\n   - if `returnState`, an Array of tensors (i.e., [tf.Tensor](#class:Tensor)s). The first\n     tensor is the output. The remaining tensors are the states at the\n     last time step, each with shape `[batchSize, units]`.\n   - if `returnSequences`, the output will have shape\n     `[batchSize, timeSteps, units]`.\n   - else, the output will have shape `[batchSize, units]`.\n\nMasking:\n   This layer supports masking for input data with a variable number\n   of timesteps. To introduce masks to your data,\n   use an embedding layer with the `mask_zero` parameter\n   set to `True`.\n\nNotes on using statefulness in RNNs:\n   You can set RNN layers to be 'stateful', which means that the states\n   computed for the samples in one batch will be reused as initial states\n   for the samples in the next batch. This assumes a one-to-one mapping\n   between samples in different successive batches.\n\n   To enable statefulness:\n     - specify `stateful: true` in the layer constructor.\n     - specify a fixed batch size for your model, by passing\n       if sequential model:\n         `batchInputShape=[...]` to the first layer in your model.\n       else for functional model with 1 or more Input layers:\n         `batchShape=[...]` to all the first layers in your model.\n       This is the expected shape of your inputs *including the batch size*.\n       It should be a tuple of integers, e.g. `(32, 10, 100)`.\n     - specify `shuffle=False` when calling fit().\n\n   To reset the states of your model, call `.reset_states()` on either\n   a specific layer, or on your entire model.\n\nNote on specifying the initial state of RNNs\n   You can specify the initial state of RNN layers symbolically by\n   calling them with the option `initialState`. The value of\n   `initialState` should be a tensor or list of tensors representing\n   the initial state of the RNN layer.\n\n   You can specify the initial state of RNN layers numerically by\n   calling `resetStates` with the keyword argument `states`. The value of\n   `states` should be a numpy array or list of numpy arrays representing\n   the initial state of the RNN layer.\n\nNote on passing external constants to RNNs\n   You can pass \"external\" constants to the cell using the `constants`\n   keyword argument of `RNN.call` method. This requires that the `cell.call`\n   method accepts the same keyword argument `constants`. Such constants\n   can be used to conditon the cell transformation on additional static inputs\n   (not changing over time), a.k.a an attention mechanism.",
              "fileName": "#644",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L644-L653",
              "isFunction": true,
              "displayName": "tf.layers.stackedRNNCells",
              "urlHash": "layers.stackedRNNCells"
            }
          ]
        },
        {
          "name": "Wrapper",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Wrapper",
                "namespace": "layers",
                "useDocsFrom": "Bidirectional",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "bidirectional",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "layer",
                  "documentation": "The instance of an `RNN` layer to be wrapped.",
                  "type": "RNN",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "mergeMode",
                  "documentation": "Mode by which outputs of the forward and backward RNNs are combinied.\nIf `null` or `undefined`, the output will not be combined, they will be\nreturned as an `Array`.",
                  "type": "BidirectionalMergeMode",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "",
              "fileName": "#657",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L657-L666",
              "isFunction": true,
              "displayName": "tf.layers.bidirectional",
              "urlHash": "layers.bidirectional"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Wrapper",
                "namespace": "layers",
                "useDocsFrom": "TimeDistributed",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "timeDistributed",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "layer",
                  "documentation": "The layer to be wrapped.",
                  "type": "[tf.layers.Layer](#class:layers.Layer)",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "This wrapper applies a layer to every temporal slice of an input.\n\nThe input should be at least 3D,  and the dimension of the index `1` will be\nconsidered to be the temporal dimension.\n\nConsider a batch of 32 samples, where each sample is a sequence of 10 vectors\nof 16 dimensions. The batch input shape of the layer is then `[32,  10,\n16]`, and the `inputShape`, not including the sample dimension, is\n`[10, 16]`.\n\nYou can then use `TimeDistributed` to apply a `Dense` layer to each of the 10\ntimesteps, independently:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.dense({units: 8}),\n   inputShape: [10, 16],\n}));\n\n// Now model.outputShape = [null, 10, 8].\n// The output will then have shape `[32, 10, 8]`.\n\n// In subsequent layers, there is no need for `inputShape`:\nmodel.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: 32})}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n// Now model.outputShape = [null, 10, 32].\n```\n\nThe output will then have shape `[32, 10, 32]`.\n\n`TimeDistributed` can be used with arbitrary layers, not just `Dense`, for\ninstance a `Conv2D` layer.\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.conv2d({filters: 64, kernelSize: [3, 3]}),\n   inputShape: [10, 299, 299, 3],\n}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
              "fileName": "#668",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L668-L677",
              "isFunction": true,
              "displayName": "tf.layers.timeDistributed",
              "urlHash": "layers.timeDistributed"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Classes",
                "namespace": "layers"
              },
              "symbolName": "Layer",
              "namespace": "layers",
              "documentation": "A layer is a grouping of operations and weights that can be composed to\ncreate a [tf.Model](#class:Model).\n\nLayers are constructed by using the functions under the\n[tf.layers](#Layers-Basic) namespace.",
              "fileName": "#333",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/topology.ts#L333-L1226",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "apply",
                  "paramStr": "(inputs, kwargs?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "a [tf.Tensor](#class:Tensor) or [tf.SymbolicTensor](#class:SymbolicTensor) or an Array of them.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "kwargs",
                      "documentation": "Additional keyword arguments to be passed to `call()`.",
                      "type": "any",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "documentation": "Builds or executes a `Layer's logic.\n\nWhen called with [tf.Tensor](#class:Tensor)(s), execute the `Layer`s computation and\nreturn Tensor(s). For example:\n\n```js\nconst denseLayer = tf.layers.dense({\n   units: 1,\n   kernelInitializer: 'zeros',\n   useBias: false\n});\n\n// Invoke the layer's apply() method with a [tf.Tensor](#class:Tensor) (with concrete\n// numeric values).\nconst input = tf.ones([2, 2]);\nconst output = denseLayer.apply(input);\n\n// The output's value is expected to be [[0], [0]], due to the fact that\n// the dense layer has a kernel initialized to all-zeros and does not have\n// a bias.\noutput.print();\n```\n\nWhen called with [tf.SymbolicTensor](#class:SymbolicTensor)(s), this will prepare the layer for\nfuture execution.  This entails internal book-keeping on shapes of\nexpected Tensors, wiring layers together, and initializing weights.\n\nCalling `apply` with [tf.SymbolicTensor](#class:SymbolicTensor)s are typically used during the\nbuilding of non-[tf.Sequential](#class:Sequential) models. For example:\n\n```js\nconst flattenLayer = tf.layers.flatten();\nconst denseLayer = tf.layers.dense({units: 1});\n\n// Use tf.layers.input() to obtain a SymbolicTensor as input to apply().\nconst input = tf.input({shape: [2, 2]});\nconst output1 = flattenLayer.apply(input);\n\n// output1.shape is [null, 4]. The first dimension is the undetermined\n// batch size. The second dimension comes from flattening the [2, 2]\n// shape.\nconsole.log(JSON.stringify(output1.shape));\n\n// The output SymbolicTensor of the flatten layer can be used to call\n// the apply() of the dense layer:\nconst output2 = denseLayer.apply(output1);\n\n// output2.shape is [null, 1]. The first dimension is the undetermined\n// batch size. The second dimension matches the number of units of the\n// dense layer.\nconsole.log(JSON.stringify(output2.shape));\n\n// The input and output and be used to construct a model that consists\n// of the flatten and dense layers.\nconst model = tf.model({inputs: input, outputs: output2});\n```",
                  "fileName": "#837",
                  "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/engine/topology.ts#L837-L957",
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.apply"
                }
              ],
              "isClass": true,
              "displayName": "tf.layers.Layer",
              "urlHash": "class:layers.Layer"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Classes"
              },
              "symbolName": "RNNCell",
              "documentation": "An RNNCell layer.",
              "fileName": "#653",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/layers/recurrent.ts#L653-L660",
              "methods": [],
              "isClass": true,
              "inheritsFrom": "Layer",
              "displayName": "tf.RNNCell",
              "urlHash": "class:RNNCell"
            }
          ]
        },
        {
          "name": "Inputs",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Inputs",
                "namespace": "layers",
                "useDocsFrom": "InputLayer",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "inputLayer",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": "Input shape, not including the batch axis. ",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "documentation": "Optional input batch size (integer or null). ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "documentation": "Batch input shape, including the batch axis. ",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "documentation": "Datatype of the input.  ",
                  "type": "'float32'|'int32'|'bool'",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "sparse",
                  "documentation": "Whether the placeholder created is meant to be sparse.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "documentation": "Name of the layer. ",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "An input layer is an entry point into a [tf.Model](#class:Model).\n\n`InputLayer` is generated automatically for [tf.Sequential](#class:Sequential) models by specifying\nthe `inputshape` or `batchInputShape` for the first layer.  It should not be\nspecified explicitly.\n\n```js\n// Define a model which simply adds two inputs.\nconst inputA = tf.input({shape: [3]});\nconst inputB = tf.input({shape: [3]});\nconst sum = tf.layers.add().apply([inputA, inputB]);\nconst model = tf.model({inputs: [inputA, inputB], outputs: sum});\nconst batchSize = 2;\nmodel.predict([tf.ones([batchSize, 3]), tf.ones([batchSize, 3])]).print();\n```",
              "fileName": "#180",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L180-L189",
              "isFunction": true,
              "displayName": "tf.layers.inputLayer",
              "urlHash": "layers.inputLayer"
            }
          ]
        },
        {
          "name": "Padding",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Padding",
                "namespace": "layers",
                "useDocsFrom": "ZeroPadding2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "zeroPadding2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "padding",
                  "documentation": "Integer, or `Array` of 2 integers, or `Array` of 2 `Array`s, each of\nwhich is an `Array` of 2 integers.\n- If integer, the same symmetric padding is applied to width and height.\n- If Array` of 2 integers, interpreted as two different symmetric values\n   for height and width:\n   `[symmetricHeightPad, symmetricWidthPad]`.\n- If `Array` of 2 `Array`s, interpreted as:\n   `[[topPad, bottomPad], [leftPad, rightPad]]`.",
                  "type": "number|[number, number]|[[number, number], [number, number]]",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "One of `'channelsLast'` (default) and `'channelsFirst'`.\n\nThe ordering of the dimensions in the inputs.\n`channelsLast` corresponds to inputs with shape\n`[batch, height, width, channels]` while `channelsFirst`\ncorresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "type": "'channelsFirst'|'channelsLast'",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.layers.Layer](#class:layers.Layer)",
              "documentation": "Zero-padding layer for 2D input (e.g., image).\n\nThis layer can add rows and columns of zeros\nat the top, bottom, left and right side of an image tensor.\n\nInput shape:\n   4D tensor with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, rows, cols, channels]`\n   - If `data_format` is `\"channels_first\"`:\n     `[batch, channels, rows, cols]`.\n\nOutput shape:\n   4D with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, paddedRows, paddedCols, channels]`\n    - If `dataFormat` is `\"channelsFirst\"`:\n     `[batch, channels, paddedRows, paddedCols]`.",
              "fileName": "#449",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L449-L458",
              "isFunction": true,
              "displayName": "tf.layers.zeroPadding2d",
              "urlHash": "layers.zeroPadding2d"
            }
          ]
        }
      ]
    },
    {
      "name": "Operations",
      "description": "",
      "subheadings": [
        {
          "name": "Arithmetic",
          "description": "<p>To perform mathematical computation on Tensors, we use\noperations. Tensors are immutable, so all operations always return\nnew Tensors and never modify input Tensors.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "add",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first [tf.Tensor](#class:Tensor) to add.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second [tf.Tensor](#class:Tensor) to add. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Adds two [tf.Tensor](#class:Tensor)s element-wise, A + B. Supports broadcasting.\n\nWe also expose `addStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.tensor1d([10, 20, 30, 40]);\n\na.add(b).print();  // or tf.add(a, b)\n```\n\n```js\n// Broadcast add a with b.\nconst a = tf.scalar(5);\nconst b = tf.tensor1d([10, 20, 30, 40]);\n\na.add(b).print();  // or tf.add(a, b)\n```",
              "fileName": "#51",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L51-L78",
              "isFunction": true,
              "displayName": "tf.add",
              "urlHash": "add"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "sub",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first [tf.Tensor](#class:Tensor) to subtract from.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second [tf.Tensor](#class:Tensor) to be subtracted. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Subtracts two [tf.Tensor](#class:Tensor)s element-wise, A - B. Supports broadcasting.\n\nWe also expose `subStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([10, 20, 30, 40]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\n\na.sub(b).print();  // or tf.sub(a, b)\n```\n\n```js\n// Broadcast subtract a with b.\nconst a = tf.tensor1d([10, 20, 30, 40]);\nconst b = tf.scalar(5);\n\na.sub(b).print();  // or tf.sub(a, b)\n```",
              "fileName": "#118",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L118-L146",
              "isFunction": true,
              "displayName": "tf.sub",
              "urlHash": "sub"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "mul",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor to multiply.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor to multiply. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Multiplies two [tf.Tensor](#class:Tensor)s element-wise, A * B. Supports broadcasting.\n\nWe also expose `mulStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.tensor1d([2, 3, 4, 5]);\n\na.mul(b).print();  // or tf.mul(a, b)\n```\n\n```js\n// Broadcast mul a with b.\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.scalar(5);\n\na.mul(b).print();  // or tf.mul(a, b)\n```",
              "fileName": "#249",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L249-L277",
              "isFunction": true,
              "displayName": "tf.mul",
              "urlHash": "mul"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "div",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor as the numerator.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor as the denominator. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Divides two [tf.Tensor](#class:Tensor)s element-wise, A / B. Supports broadcasting.\n\nWe also expose `divStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 9, 16]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\n\na.div(b).print();  // or tf.div(a, b)\n```\n\n```js\n// Broadcast div a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(2);\n\na.div(b).print();  // or tf.div(a, b)\n```",
              "fileName": "#319",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L319-L347",
              "isFunction": true,
              "displayName": "tf.div",
              "urlHash": "div"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "maximum",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the max of a and b (`a > b ? a : b`) element-wise.\nSupports broadcasting.\n\nWe also expose `maximumStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.maximum(b).print();  // or tf.maximum(a, b)\n```\n\n```js\n// Broadcast maximum a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.maximum(b).print();  // or tf.maximum(a, b)\n```",
              "fileName": "#505",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L505-L517",
              "isFunction": true,
              "displayName": "tf.maximum",
              "urlHash": "maximum"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "minimum",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the min of a and b (`a < b ? a : b`) element-wise.\nSupports broadcasting.\n\nWe also expose `minimumStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.minimum(b).print();  // or tf.minimum(a, b)\n```\n\n```js\n// Broadcast minimum a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.minimum(b).print();  // or tf.minimum(a, b)\n```",
              "fileName": "#453",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L453-L465",
              "isFunction": true,
              "displayName": "tf.minimum",
              "urlHash": "minimum"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "mod",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the mod of a and b element-wise.\n`floor(x / y) * y + mod(x, y) = x`\nSupports broadcasting.\n\nWe also expose `modStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.mod(b).print();  // or tf.mod(a, b)\n```\n\n```js\n// Broadcast a mod b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.mod(b).print();  // or tf.mod(a, b)\n```",
              "fileName": "#388",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L388-L413",
              "isFunction": true,
              "displayName": "tf.mod",
              "urlHash": "mod"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "pow",
              "paramStr": "(base, exp)",
              "parameters": [
                {
                  "name": "base",
                  "documentation": "The base [tf.Tensor](#class:Tensor) to pow element-wise.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "exp",
                  "documentation": "The exponent [tf.Tensor](#class:Tensor) to pow element-wise.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the power of one [tf.Tensor](#class:Tensor) to another. Supports broadcasting.\n\nGiven a [tf.Tensor](#class:Tensor) x and a [tf.Tensor](#class:Tensor) y, this operation computes x^y for\ncorresponding elements in x and y.\n\n```js\nconst a = tf.tensor([[2, 3], [4, 5]])\nconst b = tf.tensor([[1, 2], [3, 0]]).toInt();\n\na.pow(b).print();  // or tf.pow(a, b)\n```\n\n```js\nconst a = tf.tensor([[1, 2], [3, 4]])\nconst b = tf.tensor(2).toInt();\n\na.pow(b).print();  // or tf.pow(a, b)\n```\nWe also expose `powStrict` which has the same signature as this op and\nasserts that `base` and [tf.exp()](#exp) are the same shape (does not broadcast).",
              "fileName": "#188",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L188-L209",
              "isFunction": true,
              "displayName": "tf.pow",
              "urlHash": "pow"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "squaredDifference",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns (a - b) * (a - b) element-wise.\nSupports broadcasting.\n\nWe also expose `squaredDifferenceStrict` which has the same signature as\nthis op and asserts that `a` and `b` are the same shape (does not\nbroadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n```\n\n```js\n// Broadcast squared difference  a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n```",
              "fileName": "#558",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/binary_ops.ts#L558-L571",
              "isFunction": true,
              "displayName": "tf.squaredDifference",
              "urlHash": "squaredDifference"
            }
          ]
        },
        {
          "name": "Basic math",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "abs",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input [tf.Tensor](#class:Tensor).",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes absolute value element-wise: `abs(x)`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.abs().print();  // or tf.abs(x)\n```",
              "fileName": "#299",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L299-L306",
              "isFunction": true,
              "displayName": "tf.abs",
              "urlHash": "abs"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "acos",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes acos of the input [tf.Tensor](#class:Tensor) element-wise: `acos(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.acos().print();  // or tf.acos(x)\n```",
              "fileName": "#572",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L572-L583",
              "isFunction": true,
              "displayName": "tf.acos",
              "urlHash": "acos"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "acosh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the inverse hyperbolic cos of the input [tf.Tensor](#class:Tensor) element-wise:\n`acosh(x)`\n\n```js\nconst x = tf.tensor1d([10, 1, 3, 5.7]);\n\nx.acosh().print();  // or tf.acosh(x)\n```",
              "fileName": "#697",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L697-L707",
              "isFunction": true,
              "displayName": "tf.acosh",
              "urlHash": "acosh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "asin",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes asin of the input [tf.Tensor](#class:Tensor) element-wise: `asin(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.asin().print();  // or tf.asin(x)\n```",
              "fileName": "#550",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L550-L560",
              "isFunction": true,
              "displayName": "tf.asin",
              "urlHash": "asin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "asinh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes inverse hyperbolic sin of the input [tf.Tensor](#class:Tensor) element-wise:\n`asinh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.asinh().print();  // or tf.asinh(x)\n```",
              "fileName": "#674",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L674-L684",
              "isFunction": true,
              "displayName": "tf.asinh",
              "urlHash": "asinh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "atan",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes atan of the input [tf.Tensor](#class:Tensor) element-wise: `atan(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.atan().print();  // or tf.atan(x)\n```",
              "fileName": "#595",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L595-L602",
              "isFunction": true,
              "displayName": "tf.atan",
              "urlHash": "atan"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "atanh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes inverse hyperbolic tan of the input [tf.Tensor](#class:Tensor) element-wise:\n`atanh(x)`\n\n```js\nconst x = tf.tensor1d([0, .1, -.1, .7]);\n\nx.atanh().print();  // or tf.atanh(x)\n```",
              "fileName": "#720",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L720-L727",
              "isFunction": true,
              "displayName": "tf.atanh",
              "urlHash": "atanh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "ceil",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes ceiling of input [tf.Tensor](#class:Tensor) element-wise: `ceil(x)`\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3]);\n\nx.ceil().print();  // or tf.ceil(x)\n```",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L58-L66",
              "isFunction": true,
              "displayName": "tf.ceil",
              "urlHash": "ceil"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "clipByValue",
              "paramStr": "(x, clipValueMin, clipValueMax)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "clipValueMin",
                  "documentation": "Lower-bound of range to be clipped to.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "clipValueMax",
                  "documentation": "Upper-bound of range to be clipped to.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Clips values element-wise. `max(min(x, clipValueMax), clipValueMin)`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)\n```",
              "fileName": "#320",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L320-L340",
              "isFunction": true,
              "displayName": "tf.clipByValue",
              "urlHash": "clipByValue"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "cos",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes cos of the input [tf.Tensor](#class:Tensor) element-wise: `cos(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.cos().print();  // or tf.cos(x)\n```",
              "fileName": "#512",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L512-L519",
              "isFunction": true,
              "displayName": "tf.cos",
              "urlHash": "cos"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "cosh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic cos of the input [tf.Tensor](#class:Tensor) element-wise: `cosh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.cosh().print();  // or tf.cosh(x)\n```",
              "fileName": "#633",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L633-L640",
              "isFunction": true,
              "displayName": "tf.cosh",
              "urlHash": "cosh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "elu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential linear element-wise, `x > 0 ? e ^ x - 1 : 0`\n\n```js\nconst x = tf.tensor1d([-1, 1, -3, 2]);\n\nx.elu().print();  // or tf.elu(x)\n```",
              "fileName": "#372",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L372-L379",
              "isFunction": true,
              "displayName": "tf.elu",
              "urlHash": "elu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "exp",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential of the input [tf.Tensor](#class:Tensor) element-wise. `e ^ x`\n\n```js\nconst x = tf.tensor1d([1, 2, -3]);\n\nx.exp().print();  // or tf.exp(x)\n```",
              "fileName": "#140",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L140-L149",
              "isFunction": true,
              "displayName": "tf.exp",
              "urlHash": "exp"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "expm1",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential of the input [tf.Tensor](#class:Tensor) minus one element-wise.\n`e ^ x - 1`\n\n```js\nconst x = tf.tensor1d([1, 2, -3]);\n\nx.expm1().print();  // or tf.expm1(x)\n```",
              "fileName": "#162",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L162-L169",
              "isFunction": true,
              "displayName": "tf.expm1",
              "urlHash": "expm1"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "floor",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes floor of input [tf.Tensor](#class:Tensor) element-wise: `floor(x)`.\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3]);\n\nx.floor().print();  // or tf.floor(x)\n```",
              "fileName": "#78",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L78-L87",
              "isFunction": true,
              "displayName": "tf.floor",
              "urlHash": "floor"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "leakyRelu",
              "paramStr": "(x, alpha?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "The scaling factor for negative values, defaults to 0.2.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes leaky rectified linear element-wise.\n\nSee\n[http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](\n     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)\n```",
              "fileName": "#429",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L429-L437",
              "isFunction": true,
              "displayName": "tf.leakyRelu",
              "urlHash": "leakyRelu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "log",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes natural logarithm of the input [tf.Tensor](#class:Tensor) element-wise: `ln(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.E]);\n\nx.log().print();  // or tf.log(x)\n```",
              "fileName": "#181",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L181-L188",
              "isFunction": true,
              "displayName": "tf.log",
              "urlHash": "log"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "log1p",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes natural logarithm of the input [tf.Tensor](#class:Tensor) plus one\nelement-wise: `ln(1 + x)`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.E - 1]);\n\nx.log1p().print();  // or tf.log1p(x)\n```",
              "fileName": "#201",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L201-L208",
              "isFunction": true,
              "displayName": "tf.log1p",
              "urlHash": "log1p"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "neg",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes `-1 * x` element-wise.\n\n```js\nconst x = tf.tensor2d([1, 2, -2, 0], [2, 2]);\n\nx.neg().print();  // or tf.neg(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L39-L46",
              "isFunction": true,
              "displayName": "tf.neg",
              "urlHash": "neg"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "prelu",
              "paramStr": "(x, alpha)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "Scaling factor for negative values.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes leaky rectified linear element-wise with parametric alphas.\n\n`x < 0 ? alpha * x : f(x) = x`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\nconst alpha = tf.scalar(0.1);\n\nx.prelu(alpha).print();  // or tf.prelu(x, alpha)\n```",
              "fileName": "#453",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L453-L460",
              "isFunction": true,
              "displayName": "tf.prelu",
              "urlHash": "prelu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "reciprocal",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes reciprocal of x element-wise: `1 / x`\n\n```js\nconst x = tf.tensor1d([0, 1, 2]);\n\nx.reciprocal().print();  // or tf.reciprocal(x)\n```",
              "fileName": "#280",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L280-L287",
              "isFunction": true,
              "displayName": "tf.reciprocal",
              "urlHash": "reciprocal"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "relu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes rectified linear element-wise: `max(x, 0)`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.relu().print();  // or tf.relu(x)\n```",
              "fileName": "#352",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L352-L360",
              "isFunction": true,
              "displayName": "tf.relu",
              "urlHash": "relu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "round",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes round of input [tf.Tensor](#class:Tensor) element-wise: `round(x)`.\nIt implements banker's rounding.\n\n```js\nconst x = dl.tensor1d([.6, 1.1, -3.3]);\n\nx.round().print();  // or dl.round(x)\n```",
              "fileName": "#119",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L119-L128",
              "isFunction": true,
              "displayName": "tf.round",
              "urlHash": "round"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "rsqrt",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes reciprocal of square root of the input [tf.Tensor](#class:Tensor) element-wise:\n`y = 1 / sqrt(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, 4, -1]);\n\nx.rsqrt().print();  // or tf.rsqrt(x)\n```",
              "fileName": "#240",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L240-L249",
              "isFunction": true,
              "displayName": "tf.rsqrt",
              "urlHash": "rsqrt"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "selu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes scaled exponential linear element-wise.\n\n`x < 0 ? scale * alpha * (exp(x) - 1) : x`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.selu().print();  // or tf.selu(x)\n```",
              "fileName": "#393",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L393-L412",
              "isFunction": true,
              "displayName": "tf.selu",
              "urlHash": "selu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sigmoid",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes sigmoid element-wise, `1 / (1 + exp(-x))`\n\n```js\nconst x = tf.tensor1d([0, -1, 2, -3]);\n\nx.sigmoid().print();  // or tf.sigmoid(x)\n```",
              "fileName": "#472",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L472-L481",
              "isFunction": true,
              "displayName": "tf.sigmoid",
              "urlHash": "sigmoid"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sign",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns an element-wise indication of the sign of a number.\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);\n\nx.sign().print();  // or tf.sign(x)\n```",
              "fileName": "#99",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L99-L106",
              "isFunction": true,
              "displayName": "tf.sign",
              "urlHash": "sign"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sin",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes sin of the input Tensor element-wise: `sin(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.sin().print();  // or tf.sin(x)\n```",
              "fileName": "#493",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L493-L500",
              "isFunction": true,
              "displayName": "tf.sin",
              "urlHash": "sin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sinh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic sin of the input [tf.Tensor](#class:Tensor) element-wise: `sinh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.sinh().print();  // or tf.sinh(x)\n```",
              "fileName": "#614",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L614-L621",
              "isFunction": true,
              "displayName": "tf.sinh",
              "urlHash": "sinh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sqrt",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes square root of the input [tf.Tensor](#class:Tensor) element-wise: `y = sqrt(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, 4, -1]);\n\nx.sqrt().print();  // or tf.sqrt(x)\n```",
              "fileName": "#220",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L220-L227",
              "isFunction": true,
              "displayName": "tf.sqrt",
              "urlHash": "sqrt"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "square",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes square of `x` element-wise: `x ^ 2`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);\n\nx.square().print();  // or tf.square(x)\n```",
              "fileName": "#261",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L261-L268",
              "isFunction": true,
              "displayName": "tf.square",
              "urlHash": "square"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "step",
              "paramStr": "(x, alpha?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "The gradient when input is negative.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes step of the input [tf.Tensor](#class:Tensor) element-wise: `x > 0 ? 1 : alpha * x`\n\n```js\nconst x = tf.tensor1d([0, 2, -1, -3]);\n\nx.step(.5).print();  // or tf.step(x, .5)\n```",
              "fileName": "#740",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L740-L748",
              "isFunction": true,
              "displayName": "tf.step",
              "urlHash": "step"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "tan",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes tan of the input [tf.Tensor](#class:Tensor) element-wise, `tan(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.tan().print();  // or tf.tan(x)\n```",
              "fileName": "#531",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L531-L538",
              "isFunction": true,
              "displayName": "tf.tan",
              "urlHash": "tan"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "tanh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic tangent of the input [tf.Tensor](#class:Tensor) element-wise: `tanh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, 70]);\n\nx.tanh().print();  // or tf.tanh(x)\n```",
              "fileName": "#652",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/unary_ops.ts#L652-L661",
              "isFunction": true,
              "displayName": "tf.tanh",
              "urlHash": "tanh"
            }
          ]
        },
        {
          "name": "Matrices",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "matMul",
              "paramStr": "(a, b, transposeA?, transposeB?)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "First matrix in dot product operation.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "Second matrix in dot product operation.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "transposeA",
                  "documentation": "If true, `a` is transposed before multiplication.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "transposeB",
                  "documentation": "If true, `b` is transposed before multiplication.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Computes the dot product of two matrices, A * B. These must be matrices.\n\n```js\nconst a = tf.tensor2d([1, 2], [1, 2]);\nconst b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\na.matMul(b).print();  // or tf.matMul(a, b)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/matmul.ts#L39-L70",
              "isFunction": true,
              "displayName": "tf.matMul",
              "urlHash": "matMul"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "norm",
              "paramStr": "(x, ord?, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input array.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "ord",
                  "documentation": "Optional. Order of the norm. Supported norm types are\nfollowing:\n\n| ord        | norm for matrices         | norm for vectors\n|------------|---------------------------|---------------------\n|'euclidean' |Frobenius norm             |2-norm\n|'fro'       |Frobenius norm\t           |\n|Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n|-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n|1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n|2           |                           |sum(abs(x)^2)^1/2*",
                  "type": "number|'euclidean'|'fro'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Optional. If axis is null (the default), the input is\nconsidered a vector and a single vector norm is computed over the entire\nset of values in the Tensor, i.e. norm(x, ord) is equivalent\nto norm(x.reshape([-1]), ord). If axis is a integer, the input\nis considered a batch of vectors, and axis determines the axis in x\nover which to compute vector norms. If axis is a 2-tuple of integer it is\nconsidered a batch of matrices and axis determines the axes in NDArray\nover which to compute a matrix norm.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "Optional. If true, the norm have the same dimensionality\nas the input.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the norm of scalar, vectors, and matrices.\nThis function can compute several different vector norms (the 1-norm, the\nEuclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\nand matrix norms (Frobenius, 1-norm, and inf-norm).\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.norm().print();  // or tf.norm(x)\n```",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/norm.ts#L62-L74",
              "isFunction": true,
              "displayName": "tf.norm",
              "urlHash": "norm"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "outerProduct",
              "paramStr": "(v1, v2)",
              "parameters": [
                {
                  "name": "v1",
                  "documentation": "The first vector in the outer product operation.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "v2",
                  "documentation": "The second vector in the dot product operation.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Computes the outer product of two vectors, v1 and v2.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([3, 4, 5]);\n\ntf.outerProduct(a, b).print();\n```",
              "fileName": "#151",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/matmul.ts#L151-L160",
              "isFunction": true,
              "displayName": "tf.outerProduct",
              "urlHash": "outerProduct"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "transpose",
              "paramStr": "(x, perm?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to transpose.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "perm",
                  "documentation": "The permutation of the dimensions of a.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Transposes the [tf.Tensor](#class:Tensor). Permutes the dimensions according to `perm`.\n\nThe returned [tf.Tensor](#class:Tensor)'s dimension `i` will correspond to the input\ndimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\nwhere `n` is the rank of the input [tf.Tensor](#class:Tensor). Hence by default, this\noperation performs a regular matrix transpose on 2-D input [tf.Tensor](#class:Tensor)s.\n\n```js\nconst a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n\na.transpose().print();  // or tf.transpose(a)\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/transpose.ts#L43-L59",
              "isFunction": true,
              "displayName": "tf.transpose",
              "urlHash": "transpose"
            }
          ]
        },
        {
          "name": "Convolution",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "avgPool",
              "paramStr": "(x, filterSize, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size, a tuple `[filterHeight, filterWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm:\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the 2D average pooling of an image.",
              "fileName": "#213",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/pool.ts#L213-L249",
              "isFunction": true,
              "displayName": "tf.avgPool",
              "urlHash": "avgPool"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv1d",
              "paramStr": "(input, filter, stride, pad, dataFormat?, dilation?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor, of rank 3 or rank 2, of shape\n`[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 3, of shape\n`[filterWidth, inDepth, outDepth]`.",
                  "type": "[tf.Tensor3D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stride",
                  "documentation": "The number of entries by which the filter is moved right at\neach step.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\nthe data is stored in the order of [batch, in_width, in_channels]. Only\n\"NWC\" is currently supported.",
                  "type": "'NWC'|'NCW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilation",
                  "documentation": "The dilation rate in which we sample input values in\natrous convolution. Defaults to `1`. If it is greater than 1, then\nstride must be `1`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)",
              "documentation": "Computes a 1D convolution over the input x.",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/conv.ts#L53-L110",
              "isFunction": true,
              "displayName": "tf.conv1d",
              "urlHash": "conv1d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv2d",
              "paramStr": "(x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 4, of shape\n`[filterHeight, filterWidth, inDepth, outDepth]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels]. Only \"NHWC\" is currently supported.",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nin atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\nnumber, then `dilationHeight == dilationWidth`. If it is greater than\n1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes a 2D convolution over the input x.",
              "fileName": "#143",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/conv.ts#L143-L207",
              "isFunction": true,
              "displayName": "tf.conv2d",
              "urlHash": "conv2d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv2dTranspose",
              "paramStr": "(x, filter, outputShape, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input image, of rank 4 or rank 3, of shape\n`[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 4, of shape\n`[filterHeight, filterWidth, outDepth, inDepth]`.\n`inDepth` must match `inDepth` in `x`.",
                  "type": "[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "outputShape",
                  "documentation": "Output shape, of rank 4 or rank 3:\n`[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.",
                  "type": "[number, number, number, number]|[number, number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the original convolution:\n`[strideHeight, strideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm used in the non-transpose version\nof the op.",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the transposed 2D convolution of an image, also known as a\ndeconvolution.",
              "fileName": "#375",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/conv.ts#L375-L384",
              "isFunction": true,
              "displayName": "tf.conv2dTranspose",
              "urlHash": "conv2dTranspose"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "depthwiseConv2d",
              "paramStr": "(input, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter tensor, rank 4, of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`. If strides is a single number, then `strideHeight ==\nstrideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels]. Only \"NHWC\" is currently supported.",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nin atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\nnumber, then `dilationHeight == dilationWidth`. If it is greater than\n1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Depthwise 2D convolution.\n\nGiven a 4D [tf.input()](#input) array and a `filter` array of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n`inChannels` convolutional filters of depth 1, this op applies a\ndifferent filter to each input channel (expanding from 1 channel to\n`channelMultiplier` channels for each), then concatenates the results\ntogether. The output has `inChannels * channelMultiplier` channels.\n\nSee\n[https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\nfor more details.",
              "fileName": "#430",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/conv.ts#L430-L481",
              "isFunction": true,
              "displayName": "tf.depthwiseConv2d",
              "urlHash": "depthwiseConv2d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "maxPool",
              "paramStr": "(x, filterSize, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size, a tuple `[filterHeight, filterWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the 2D max pooling of an image.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/pool.ts#L45-L80",
              "isFunction": true,
              "displayName": "tf.maxPool",
              "urlHash": "maxPool"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "minPool",
              "paramStr": "(input, filterSize, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size, a tuple `[filterHeight, filterWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "The rounding mode used when computing output\ndimensions if pad is a number. If none is provided, it will not round\nand error if the output is of fractional size.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the 2D min pooling of an image.",
              "fileName": "#163",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/pool.ts#L163-L192",
              "isFunction": true,
              "displayName": "tf.minPool",
              "urlHash": "minPool"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "separableConv2d",
              "paramStr": "(input, depthwiseFilter, pointwiseFilter, strides, pad, dilation?, dataFormat?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depthwiseFilter",
                  "documentation": "The depthwise filter tensor, rank 4, of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\nthe filter used in the first step.",
                  "type": "[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pointwiseFilter",
                  "documentation": "The pointwise filter tensor, rank 4, of shape\n`[1, 1, inChannels * channelMultiplier, outChannels]`. This is\nthe filter used in the second step.",
                  "type": "[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`. If strides is a single number, then `strideHeight ==\nstrideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dilation",
                  "documentation": "",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels]. Only \"NHWC\" is currently supported.",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "2-D convolution with separable filters.\n\nPerforms a depthwise convolution that acts separately on channels followed\nby a pointwise convolution that mixes channels. Note that this is\nseparability between dimensions [1, 2] and 3, not spatial separability\nbetween dimensions 1 and 2.\n\nSee\n[https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\nfor more details.",
              "fileName": "#526",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/conv.ts#L526-L584",
              "isFunction": true,
              "displayName": "tf.separableConv2d",
              "urlHash": "separableConv2d"
            }
          ]
        },
        {
          "name": "Reduction",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "argMax",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension to reduce. By default it reduces\nacross all axes and returns the flat index",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the indices of the maximum values along an `axis`.\n\nThe result has the same shape as [tf.input()](#input) with the dimension along `axis`\nremoved.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.argMax().print();  // or tf.argMax(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n\nconst axis = 1;\nx.argMax(axis).print();  // or tf.argMax(x, axis)\n```",
              "fileName": "#354",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L354-L365",
              "isFunction": true,
              "displayName": "tf.argMax",
              "urlHash": "argMax"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "argMin",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension to reduce. By default it reduces\nacross all axes and returns the flat index.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the indices of the minimum values along an `axis`.\n\nThe result has the same shape as [tf.input()](#input) with the dimension along `axis`\nremoved.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.argMin().print();  // or tf.argMin(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n\nconst axis = 1;\nx.argMin(axis).print();  // or tf.argMin(x, axis)\n```",
              "fileName": "#319",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L319-L329",
              "isFunction": true,
              "displayName": "tf.argMin",
              "urlHash": "argMin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "logSumExp",
              "paramStr": "(input, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. If null (the default),\nreduces all dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with length\nof 1. Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the log(sum(exp(elements across the reduction dimensions)).\n\nReduces the input along the dimensions given in `axis`. Unless `keepDims`\nis true, the rank of the array is reduced by 1 for each entry in `axis`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axis` has no entries, all dimensions are reduced, and an array with a\nsingle element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.logSumExp().print();  // or tf.logSumExp(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.logSumExp(axis).print();  // or tf.logSumExp(a, axis)\n```",
              "fileName": "#55",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L55-L72",
              "isFunction": true,
              "displayName": "tf.logSumExp",
              "urlHash": "logSumExp"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "max",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the maximum of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in `axes`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axes` has no entries, all dimensions are reduced, and an [tf.Tensor](#class:Tensor) with\na single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.max().print();  // or tf.max(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.max(axis).print();  // or tf.max(x, axis)\n```",
              "fileName": "#276",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L276-L293",
              "isFunction": true,
              "displayName": "tf.max",
              "urlHash": "max"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "mean",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the mean of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces `x` along the dimensions given in `axis`. Unless `keepDims` is\ntrue, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in `axis`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axis` has no entries, all dimensions are reduced, and a [tf.Tensor](#class:Tensor) with\na single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.mean().print();  // or tf.logSumExp(a)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.mean(axis).print();  // or tf.mean(x, axis)\n```",
              "fileName": "#167",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L167-L201",
              "isFunction": true,
              "displayName": "tf.mean",
              "urlHash": "mean"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "min",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the minimum value from the input.\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the array is reduced by 1 for each entry in `axes`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axes` has no entries, all dimensions are reduced, and an array with a\nsingle element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.min().print();  // or tf.min(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.min(axis).print();  // or tf.min(x, axis)\n```",
              "fileName": "#230",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L230-L247",
              "isFunction": true,
              "displayName": "tf.min",
              "urlHash": "min"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "sum",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to compute the sum over.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the sum of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in `axes`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf axes has no entries, all dimensions are reduced, and a [tf.Tensor](#class:Tensor) with a\nsingle element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.sum().print();  // or tf.logSumExp(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.sum(axis).print();  // or tf.sum(x, axis)\n```",
              "fileName": "#101",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L101-L138",
              "isFunction": true,
              "displayName": "tf.sum",
              "urlHash": "sum"
            }
          ]
        },
        {
          "name": "Normalization",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "batchNormalization",
              "paramStr": "(x, mean, variance, varianceEpsilon?, scale?, offset?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "A mean Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "variance",
                  "documentation": "A variance Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "varianceEpsilon",
                  "documentation": "A small float number to avoid dividing by 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scale",
                  "documentation": "A scale Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "offset",
                  "documentation": "An offset Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Batch normalization.\n\nAs described in\n[http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).\n\nMean, variance, scale, and offset can be of two\nshapes:\n   - The same shape as the input.\n   - In the common case, the depth dimension is the last dimension of x, so\n     the values would be an [tf.Tensor1D](#class:Tensor) of shape [depth].",
              "fileName": "#180",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/batchnorm.ts#L180-L203",
              "isFunction": true,
              "displayName": "tf.batchNormalization",
              "urlHash": "batchNormalization"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "localResponseNormalization",
              "paramStr": "(x, radius?, bias?, alpha?, beta?, normRegion?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. The 4-D input tensor is treated as a 3-D array\nof 1D vectors (along the last dimension), and each vector is\nnormalized independently.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "radius",
                  "documentation": "The number of adjacent channels or spatial locations of the\n1D normalization window. In Tensorflow this param is called\n'depth_radius' because only 'acrossChannels' mode is supported.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "bias",
                  "documentation": "A constant bias term for the basis.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "A scale factor, usually positive.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta",
                  "documentation": "An exponent.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "normRegion",
                  "documentation": "Default is 'acrossChannels'.",
                  "type": "'acrossChannels'|'withinChannel'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Normalizes the activation of a local neighborhood across or within\nchannels.",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/lrn.ts#L40-L68",
              "isFunction": true,
              "displayName": "tf.localResponseNormalization",
              "urlHash": "localResponseNormalization"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "moments",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) along with to compute mean and\nvariance. By default it reduces all dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, the moments have the same dimensionality as the\ninput.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{mean: [tf.Tensor](#class:Tensor), variance: [tf.Tensor](#class:Tensor)}",
              "documentation": "Calculates the mean and variance of `x`. The mean and variance are\ncalculated by aggregating the contents of `x` across `axes`. If `x` is\n1-D and `axes = [0]` this is just the mean and variance of a vector.",
              "fileName": "#379",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/reduction_ops.ts#L379-L392",
              "isFunction": true,
              "displayName": "tf.moments",
              "urlHash": "moments"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "softmax",
              "paramStr": "(logits, dim?)",
              "parameters": [
                {
                  "name": "logits",
                  "documentation": "The logits array.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dim",
                  "documentation": "The dimension softmax would be performed on. Defaults to `-1`\nwhich indicates the last dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the softmax normalized vector given the logits.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\n\na.softmax().print();  // or tf.softmax(a)\n```\n\n```js\nconst a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n\na.softmax().print();  // or tf.softmax(a)\n```",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/softmax.ts#L47-L77",
              "isFunction": true,
              "displayName": "tf.softmax",
              "urlHash": "softmax"
            }
          ]
        },
        {
          "name": "Images",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "resizeBilinear",
              "namespace": "image",
              "paramStr": "(images, size, alignCorners?)",
              "parameters": [
                {
                  "name": "images",
                  "documentation": "The images, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "The new shape `[newHeight, newWidth]` to resize the\nimages to. Each channel is resized individually.",
                  "type": "[number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alignCorners",
                  "documentation": "Defaults to False. If true, rescale\ninput by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\ncorners of images and resized images. If false, rescale by\n`new_height / height`. Treat similarly the width dimension.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Bilinear resize a batch of 3D images to a new shape.",
              "fileName": "#37",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/image_ops.ts#L37-L65",
              "isFunction": true,
              "displayName": "tf.image.resizeBilinear",
              "urlHash": "image.resizeBilinear"
            }
          ]
        },
        {
          "name": "RNN",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "RNN"
              },
              "symbolName": "basicLSTMCell",
              "paramStr": "(forgetBias, lstmKernel, lstmBias, data, c, h)",
              "parameters": [
                {
                  "name": "forgetBias",
                  "documentation": "Forget bias for the cell.",
                  "type": "[tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "lstmKernel",
                  "documentation": "The weights for the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "lstmBias",
                  "documentation": "The bias for the cell.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "data",
                  "documentation": "The input to the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "c",
                  "documentation": "Previous cell state.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "h",
                  "documentation": "Previous cell output.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[[tf.Tensor2D](#class:Tensor), [tf.Tensor2D](#class:Tensor)]",
              "documentation": "Computes the next state and output of a BasicLSTMCell.\n\nReturns `[newC, newH]`.\n\nDerived from tf.contrib.rnn.BasicLSTMCell.",
              "fileName": "#80",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/lstm.ts#L80-L102",
              "isFunction": true,
              "displayName": "tf.basicLSTMCell",
              "urlHash": "basicLSTMCell"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "RNN"
              },
              "symbolName": "multiRNNCell",
              "paramStr": "(lstmCells, data, c, h)",
              "parameters": [
                {
                  "name": "lstmCells",
                  "documentation": "Array of LSTMCell functions.",
                  "type": "(data: [tf.Tensor2D](#class:Tensor), c: [tf.Tensor2D](#class:Tensor), h: [tf.Tensor2D](#class:Tensor)): [[tf.Tensor2D](#class:Tensor), [tf.Tensor2D](#class:Tensor)][]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "data",
                  "documentation": "The input to the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "c",
                  "documentation": "Array of previous cell states.",
                  "type": "[tf.Tensor2D](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "h",
                  "documentation": "Array of previous cell outputs.",
                  "type": "[tf.Tensor2D](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[[tf.Tensor2D](#class:Tensor)[], [tf.Tensor2D](#class:Tensor)[]]",
              "documentation": "Computes the next states and outputs of a stack of LSTMCells.\n\nEach cell output is used as input to the next cell.\n\nReturns `[cellState, cellOutput]`.\n\nDerived from tf.contrib.rn.MultiRNNCell.",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/lstm.ts#L44-L64",
              "isFunction": true,
              "displayName": "tf.multiRNNCell",
              "urlHash": "multiRNNCell"
            }
          ]
        },
        {
          "name": "Logical",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "equal",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a == b) element-wise. Supports broadcasting.\n\nWe also expose `equalStrict` which has the same signature as this op\nand asserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#97",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L97-L103",
              "isFunction": true,
              "displayName": "tf.equal",
              "urlHash": "equal"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "greater",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a > b) element-wise. Supports broadcasting.\n\nWe also expose `greaterStrict` which has the same signature as this\nop and asserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#144",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L144-L150",
              "isFunction": true,
              "displayName": "tf.greater",
              "urlHash": "greater"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "greaterEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a >= b) element-wise. Supports broadcasting.\n\nWe also expose `greaterEqualStrict` which has the same signature as this\nop and asserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#167",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L167-L174",
              "isFunction": true,
              "displayName": "tf.greaterEqual",
              "urlHash": "greaterEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "less",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a < b) element-wise. Supports broadcasting.\n\nWe also expose `lessStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#66",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L66-L72",
              "isFunction": true,
              "displayName": "tf.less",
              "urlHash": "less"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "lessEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a <= b) element-wise. Supports broadcasting.\n\nWe also expose `lessEqualStrict` which has the same signature as this op\nand asserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#120",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L120-L127",
              "isFunction": true,
              "displayName": "tf.lessEqual",
              "urlHash": "lessEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalAnd",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of a AND b element-wise. Supports broadcasting.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/logical_ops.ts#L45-L54",
              "isFunction": true,
              "displayName": "tf.logicalAnd",
              "urlHash": "logicalAnd"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalNot",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be of dtype 'bool'.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `NOT x` element-wise.",
              "fileName": "#32",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/logical_ops.ts#L32-L37",
              "isFunction": true,
              "displayName": "tf.logicalNot",
              "urlHash": "logicalNot"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalOr",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `a OR b` element-wise. Supports broadcasting.",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/logical_ops.ts#L62-L71",
              "isFunction": true,
              "displayName": "tf.logicalOr",
              "urlHash": "logicalOr"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalXor",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `a XOR b` element-wise. Supports broadcasting.",
              "fileName": "#79",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/logical_ops.ts#L79-L88",
              "isFunction": true,
              "displayName": "tf.logicalXor",
              "urlHash": "logicalXor"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "notEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a != b) element-wise. Supports broadcasting.\n\nWe also expose `notEqualStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).",
              "fileName": "#35",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/compare.ts#L35-L41",
              "isFunction": true,
              "displayName": "tf.notEqual",
              "urlHash": "notEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "where",
              "paramStr": "(condition, a, b)",
              "parameters": [
                {
                  "name": "condition",
                  "documentation": "The input condition. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "a",
                  "documentation": "If `condition` is rank 1, `a` may have a higher rank but\nits first dimension must match the size of `condition`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "A tensor with the same shape and type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the elements, either `a` or `b` depending on the `condition`.\n\nIf the condition is true, select from `a`, otherwise select from `b`.",
              "fileName": "#100",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/logical_ops.ts#L100-L125",
              "isFunction": true,
              "displayName": "tf.where",
              "urlHash": "where"
            }
          ]
        }
      ]
    },
    {
      "name": "Training",
      "description": "<p>We also provide an API to do perform training, and\ncompute gradients. We compute gradients eagerly, users provide a function\nthat is a combination of operations and we automatically differentiate\nthat function's output with respect to its inputs.\n<p>For those familiar with TensorFlow, the API we expose exactly mirrors\nthe TensorFlow Eager API.\n</p>",
      "subheadings": [
        {
          "name": "Gradients",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "grad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function f(x), to compute gradient for.",
                  "type": "(x: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(x: [tf.Tensor](#class:Tensor), dy?: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
              "documentation": "Provided `f(x)`, returns another function `g(x, dy?)`, which gives the\ngradient of `f(x)` with respect to `x`.\n\nIf `dy` is provided, the gradient of `f(x).mul(dy).sum()` with respect to\n`x` is computed instead. `f(x)` must take a single tensor `x` and return a\nsingle tensor `y`. If `f()` takes multiple inputs, use [tf.grads()](#grads) instead.\n\n```js\n// f(x) = x ^ 2\nconst f = x => x.square();\n// f'(x) = 2x\nconst g = tf.grad(f);\n\nconst x = tf.tensor1d([2, 3]);\ng(x).print();\n```\n\n```js\n// f(x) = x ^ 3\nconst f = x => x.pow(tf.scalar(3, 'int32'));\n// f'(x) = 3x ^ 2\nconst g = tf.grad(f);\n// f''(x) = 6x\nconst gg = tf.grad(g);\n\nconst x = tf.tensor1d([2, 3]);\ngg(x).print();\n```",
              "fileName": "#76",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L76-L98",
              "isFunction": true,
              "displayName": "tf.grad",
              "urlHash": "grad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "grads",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function `f(x1, x2,...)` to compute gradients for.",
                  "type": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(args: [tf.Tensor](#class:Tensor)[], dy?: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)[]",
              "documentation": "Provided `f(x1, x2,...)`, returns another function `g([x1, x2,...], dy?)`,\nwhich gives an array of gradients of `f()` with respect to each input\n[`x1`,`x2`,...].\n\nIf `dy` is passed when calling `g()`, the gradient of\n`f(x1,...).mul(dy).sum()` with respect to each input is computed instead.\nThe provided `f` must take one or more tensors and return a single tensor\n`y`. If `f()` takes a single input, we recommend using [tf.grad()](#grad) instead.\n\n```js\n// f(a, b) = a * b\nconst f = (a, b) => a.mul(b);\n// df / da = b, df / db = a\nconst g = tf.grads(f);\n\nconst a = tf.tensor1d([2, 3]);\nconst b = tf.tensor1d([-2, -3]);\nconst [da, db] = g([a, b]);\nconsole.log('da');\nda.print();\nconsole.log('db');\ndb.print();\n```",
              "fileName": "#127",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L127-L150",
              "isFunction": true,
              "displayName": "tf.grads",
              "urlHash": "grads"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "customGrad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to evaluate in forward mode, which should return\n`{value: Tensor, gradFunc: (dy) => Tensor[]}`, where `gradFunc` returns\nthe custom gradients of `f` with respect to its inputs.",
                  "type": "(a: [tf.Tensor](#class:Tensor), b: [tf.Tensor](#class:Tensor),...) => {\nvalue: [tf.Tensor](#class:Tensor),\ngradFunc: (dy: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]\n}",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
              "documentation": "Overrides the gradient computation of a function `f`.\n\nTakes a function\n`f(...inputs) => {value: Tensor, gradFunc: dy => Tensor[]}` and returns\nanother function `g(...inputs)` which takes the same inputs as `f`. When\ncalled, `g` returns `f().value`. In backward mode, custom gradients with\nrespect to each input of `f` are computed using `f().gradFunc`.\n\n```js\nconst customOp = tf.customGrad(x => {\n   // Override gradient of our custom x ^ 2 op to be dy * abs(x);\n   return {value: x.square(), gradFunc: dy => [dy.mul(x.abs())]};\n});\n\nconst x = tf.tensor1d([-1, -2, 3]);\nconst dx = tf.grad(x => customOp(x));\n\nconsole.log(`f(x):`);\ncustomOp(x).print();\nconsole.log(`f'(x):`);\ndx(x).print();\n```",
              "fileName": "#353",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L353-L357",
              "isFunction": true,
              "displayName": "tf.customGrad",
              "urlHash": "customGrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "valueAndGrad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "",
                  "type": "(x: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(x: [tf.Tensor](#class:Tensor), dy?: [tf.Tensor](#class:Tensor)) => {\n        value: [tf.Tensor](#class:Tensor);\n        grad: [tf.Tensor](#class:Tensor);\n      }",
              "documentation": "Like [tf.grad()](#grad), but also returns the value of `f()`. Useful when `f()`\nreturns a metric you want to show.\n\nThe result is a rich object with the following properties:\n- grad: The gradient of `f(x)` w.r.t `x` (result of [tf.grad()](#grad)).\n- value: The value returned by `f(x)`.\n\n```js\n// f(x) = x ^ 2\nconst f = x => x.square();\n// f'(x) = 2x\nconst g = tf.valueAndGrad(f);\n\nconst x = tf.tensor1d([2, 3]);\nconst {value, grad} = g(x);\n\nconsole.log('value');\nvalue.print();\nconsole.log('grad');\ngrad.print();\n```",
              "fileName": "#175",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L175-L195",
              "isFunction": true,
              "displayName": "tf.valueAndGrad",
              "urlHash": "valueAndGrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "valueAndGrads",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "",
                  "type": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(args: [tf.Tensor](#class:Tensor)[], dy?: [tf.Tensor](#class:Tensor)) => {\n        grads: [tf.Tensor](#class:Tensor)[];\n        value: [tf.Tensor](#class:Tensor);\n      }",
              "documentation": "Like [tf.grads()](#grads), but returns also the value of `f()`. Useful when `f()`\nreturns a metric you want to show.\n\nThe result is a rich object with the following properties:\n- grads: The gradients of `f()` w.r.t each input (result of [tf.grads()](#grads)).\n- value: The value returned by `f(x)`.\n\n```js\n// f(a, b) = a * b\nconst f = (a, b) => a.mul(b);\n// df/da = b, df/db = a\nconst g = tf.valueAndGrads(f);\n\nconst a = tf.tensor1d([2, 3]);\nconst b = tf.tensor1d([-2, -3]);\nconst {value, grads} = g([a, b]);\n\nconst [da, db] = grads;\n\nconsole.log('value');\nvalue.print();\n\nconsole.log('da');\nda.print();\nconsole.log('db');\ndb.print();\n```",
              "fileName": "#226",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L226-L252",
              "isFunction": true,
              "displayName": "tf.valueAndGrads",
              "urlHash": "valueAndGrads"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "variableGrads",
              "paramStr": "(f, varList?)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to execute. f() should return a scalar.",
                  "type": "() => [tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "varList",
                  "documentation": "The list of trainable variables. Defaults to all variables.",
                  "type": "[tf.Variable](#class:Variable)[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{value: [tf.Scalar](#class:Tensor), grads: {[name: string]: [tf.Tensor](#class:Tensor)}}",
              "documentation": "Computes and returns the gradient of f(x) with respect to the list of\ntrainable variables provided by `varList`. If no list is provided, it\ndefaults to all trainable variables.\n\n```js\nconst a = tf.variable(tf.tensor1d([3, 4]));\nconst b = tf.variable(tf.tensor1d([5, 6]));\nconst x = tf.tensor1d([1, 2]);\n\n// f(a, b) = a * x ^ 2 + b * x\nconst f = () => a.mul(x.square()).add(b.mul(x)).sum();\n// df/da = x ^ 2, df/db = x\nconst {value, grads} = tf.variableGrads(f);\n\nObject.keys(grads).forEach(varName => grads[varName].print());\n```",
              "fileName": "#275",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/gradients.ts#L275-L323",
              "isFunction": true,
              "displayName": "tf.variableGrads",
              "urlHash": "variableGrads"
            }
          ]
        },
        {
          "name": "Optimizers",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "sgd",
              "namespace": "train",
              "paramStr": "(learningRate)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the SGD algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.SGDOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.SGDOptimizer](#class:train.Optimizer) that uses stochastic gradient descent.\n\n```js\n// Fit a quadratic function by learning the coefficients a, b, c.\nconst xs = tf.tensor1d([0, 1, 2, 3]);\nconst ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);\n\nconst a = tf.scalar(Math.random()).variable();\nconst b = tf.scalar(Math.random()).variable();\nconst c = tf.scalar(Math.random()).variable();\n\n// y = a * x^2 + b * x + c.\nconst f = x => a.mul(x.square()).add(b.mul(x)).add(c);\nconst loss = (pred, label) => pred.sub(label).square().mean();\n\nconst learningRate = 0.01;\nconst optimizer = tf.train.sgd(learningRate);\n\n// Train the model.\nfor (let i = 0; i < 10; i++) {\n   optimizer.minimize(() => loss(f(xs), ys));\n}\n\n// Make predictions.\nconsole.log(\n     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);\nconst preds = f(xs).dataSync();\npreds.forEach((pred, i) => {\n   console.log(`x: ${i}, pred: ${pred}`);\n});\n```",
              "fileName": "#64",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L64-L67",
              "isFunction": true,
              "displayName": "tf.train.sgd",
              "urlHash": "train.sgd"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "momentum",
              "namespace": "train",
              "paramStr": "(learningRate, momentum, useNesterov?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Momentum gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "momentum",
                  "documentation": "The momentum to use for the momentum gradient descent\nalgorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "useNesterov",
                  "documentation": "",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.MomentumOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.MomentumOptimizer](#class:train.Optimizer) that uses momentum gradient\ndescent.\n\nSee\n[http://proceedings.mlr.press/v28/sutskever13.pdf](\nhttp://proceedings.mlr.press/v28/sutskever13.pdf)",
              "fileName": "#82",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L82-L86",
              "isFunction": true,
              "displayName": "tf.train.momentum",
              "urlHash": "train.momentum"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adagrad",
              "namespace": "train",
              "paramStr": "(learningRate, initialAccumulatorValue?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adagrad gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "initialAccumulatorValue",
                  "documentation": "Starting value for the accumulators, must be\npositive.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.AdagradOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.AdagradOptimizer](#class:train.Optimizer) that uses the Adagrad algorithm.\nSee\n[http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](\nhttp://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)\nor\n[http://ruder.io/optimizing-gradient-descent/index.html#adagrad](\nhttp://ruder.io/optimizing-gradient-descent/index.html#adagrad)",
              "fileName": "#179",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L179-L183",
              "isFunction": true,
              "displayName": "tf.train.adagrad",
              "urlHash": "train.adagrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adadelta",
              "namespace": "train",
              "paramStr": "(learningRate?, rho?, epsilon?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adadelta gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "rho",
                  "documentation": "The learning rate decay over each update.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A constant epsilon used to better condition the grad\nupdate.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.AdadeltaOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.AdadeltaOptimizer](#class:train.Optimizer) that uses the Adadelta algorithm.\nSee [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)",
              "fileName": "#141",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L141-L145",
              "isFunction": true,
              "displayName": "tf.train.adadelta",
              "urlHash": "train.adadelta"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adam",
              "namespace": "train",
              "paramStr": "(learningRate?, beta1?, beta2?, epsilon?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adam gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta1",
                  "documentation": "The exponential decay rate for the 1st moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta2",
                  "documentation": "The exponential decay rate for the 2nd moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A small constant for numerical stability.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "AdamOptimizer",
              "documentation": "Constructs a `AdamOptimizer` that uses the Adam algorithm.\nSee [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)",
              "fileName": "#125",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L125-L129",
              "isFunction": true,
              "displayName": "tf.train.adam",
              "urlHash": "train.adam"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adamax",
              "namespace": "train",
              "paramStr": "(learningRate?, beta1?, beta2?, epsilon?, decay?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adamax gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta1",
                  "documentation": "The exponential decay rate for the 1st moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta2",
                  "documentation": "The exponential decay rate for the 2nd moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A small constant for numerical stability.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "decay",
                  "documentation": "The learning rate decay over each update.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "AdamaxOptimizer",
              "documentation": "Constructs a `AdamaxOptimizer` that uses the Adamax algorithm.\nSee [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)",
              "fileName": "#158",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L158-L163",
              "isFunction": true,
              "displayName": "tf.train.adamax",
              "urlHash": "train.adamax"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "rmsprop",
              "namespace": "train",
              "paramStr": "(learningRate, decay?, momentum?, epsilon?, centered?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the RMSProp gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "decay",
                  "documentation": "The discounting factor for the history/coming gradient.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "momentum",
                  "documentation": "The momentum to use for the RMSProp gradient descent\nalgorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "Small value to avoid zero denominator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "centered",
                  "documentation": "If true, gradients are normalized by the estimated\nvariance of the gradient.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.RMSPropOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.RMSPropOptimizer](#class:train.Optimizer) that uses RMSProp gradient\ndescent. This implementation uses plain momentum and is not centered\nversion of RMSProp.\n\nSee\n[http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](\nhttp://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)",
              "fileName": "#106",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer_constructors.ts#L106-L113",
              "isFunction": true,
              "displayName": "tf.train.rmsprop",
              "urlHash": "train.rmsprop"
            }
          ]
        },
        {
          "name": "Losses",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "absoluteDifference",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the absolute difference loss between two tensors.",
              "fileName": "#84",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/loss_ops.ts#L84-L93",
              "isFunction": true,
              "displayName": "tf.losses.absoluteDifference",
              "urlHash": "losses.absoluteDifference"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "computeWeightedLoss",
              "namespace": "losses",
              "paramStr": "(losses, weights?, reduction?)",
              "parameters": [
                {
                  "name": "losses",
                  "documentation": "Tensor of shape `[batch_size, d1, ... dN]`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`losses`, and must be broadcastable to `losses` (i.e., all\ndimensions must be either `1`, or the same as the corresponding\n`losses` dimension).",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the weighted loss between two tensors.",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/loss_ops.ts#L42-L69",
              "isFunction": true,
              "displayName": "tf.losses.computeWeightedLoss",
              "urlHash": "losses.computeWeightedLoss"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "softmaxCrossEntropy",
              "namespace": "losses",
              "paramStr": "(labels, logits, dim?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The labels array.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "logits",
                  "documentation": "The logits array.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dim",
                  "documentation": "The dimension softmax would be performed on. Defaults to `-1`\nwhich indicates the last dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes softmax cross entropy between logits and labels.\n\nMeasures the probability error in discrete classification tasks in which\nthe classes are mutually exclusive (each entry is in exactly one class).\nFor example, each CIFAR-10 image is labeled with one and only one label: an\nimage can be a dog or a truck, but not both.\n\n`NOTE`: While the classes are mutually exclusive, their probabilities need\nnot be. All that is required is that each row of labels is a valid\nprobability distribution. If they are not, the computation of the gradient\nwill be incorrect.\n\n`WARNING`: This op expects unscaled logits, since it performs a softmax on\nlogits internally for efficiency. Do not call this op with the output of\nsoftmax, as it will produce incorrect results.\n\nlogits and labels must have the same shape, e.g. [batch_size, num_classes]\nand the same dtype.",
              "fileName": "#103",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/ops/softmax.ts#L103-L136",
              "isFunction": true,
              "displayName": "tf.losses.softmaxCrossEntropy",
              "urlHash": "losses.softmaxCrossEntropy"
            }
          ]
        },
        {
          "name": "Classes",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Classes",
                "namespace": "train"
              },
              "symbolName": "Optimizer",
              "namespace": "train",
              "documentation": "",
              "fileName": "#23",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer.ts#L23-L75",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Training",
                    "subheading": "Optimizers"
                  },
                  "symbolName": "minimize",
                  "paramStr": "(f, returnCost?, varList?)",
                  "parameters": [
                    {
                      "name": "f",
                      "documentation": "The function to execute and whose output to minimize.",
                      "type": "() => [tf.Scalar](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "returnCost",
                      "documentation": "Whether to return the scalar cost value produced by\nexecuting `f()`.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "varList",
                      "documentation": "An optional list of variables to update. If specified, only\nthe trainable variables in varList will be updated by minimize. Defaults to\nall trainable variables.",
                      "type": "[tf.Variable](#class:Variable)[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Scalar](#class:Tensor)\n      |null",
                  "documentation": "Executes `f()` and minimizes the scalar output of `f()` by computing\ngradients of y with respect to the list of trainable variables provided by\n`varList`. If no list is provided, it defaults to all trainable variables.",
                  "fileName": "#36",
                  "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/optimizers/optimizer.ts#L36-L53",
                  "isFunction": true,
                  "urlHash": "tf.train.Optimizer.minimize"
                }
              ],
              "isClass": true,
              "displayName": "tf.train.Optimizer",
              "urlHash": "class:train.Optimizer"
            }
          ]
        }
      ]
    },
    {
      "name": "Performance",
      "description": "",
      "subheadings": [
        {
          "name": "Memory",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "tidy",
              "paramStr": "(nameOrFn, fn?, gradMode?)",
              "parameters": [
                {
                  "name": "nameOrFn",
                  "documentation": "The name of the closure, or the function to execute.\nIf a name is provided, the 2nd argument should be the function.\nIf debug mode is on, the timing and the memory usage of the function\nwill be tracked and displayed on the console using the provided name.",
                  "type": "string|Function",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fn",
                  "documentation": "The function to execute.",
                  "type": "Function",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "gradMode",
                  "documentation": "If true, starts a tape and doesn't dispose tensors.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "void|number|string|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}",
              "documentation": "Executes the provided function `f` and after it is executed, cleans up all\nintermediate tensors allocated by `f` except those returned by `f`.\n`f` must not return a Promise (async functions not allowed).\nThe returned result can be a complex object, however tidy only walks the\ntop-level properties (depth 1) of that object to search for tensors, or\nlists of tensors that need to be tracked in the parent scope.\n\nUsing this method helps avoid memory leaks. In general, wrap calls to\noperations in [tf.tidy()](#tidy) for automatic memory cleanup.\n\nWhen in safe mode, you must enclose all [tf.Tensor](#class:Tensor) creation and ops\ninside a [tf.tidy()](#tidy) to prevent memory leaks.\n\n```js\n// y = 2 ^ 2 + 1\nconst y = tf.tidy(() => {\n   // a, b, and one will be cleaned up when the tidy ends.\n   const one = tf.scalar(1);\n   const a = tf.scalar(2);\n   const b = a.square();\n\n   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n\n   // The value returned inside the tidy function will return\n   // through the tidy, in this case to the variable y.\n   return b.add(one);\n});\n\nconsole.log('numTensors (outside tidy): ' + tf.memory().numTensors);\ny.print();\n```",
              "fileName": "#66",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tracking.ts#L66-L99",
              "isFunction": true,
              "displayName": "tf.tidy",
              "urlHash": "tidy"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "keep",
              "paramStr": "(result)",
              "parameters": [
                {
                  "name": "result",
                  "documentation": "The tensor to keep from being disposed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Keeps a [tf.Tensor](#class:Tensor) generated inside a [tf.tidy()](#tidy) from being disposed\nautomatically.\n\n```js\nlet b;\nconst y = tf.tidy(() => {\n   const one = tf.scalar(1);\n   const a = tf.scalar(2);\n\n   // b will not be cleaned up by the tidy. a and one will be cleaned up\n   // when the tidy ends.\n   b = tf.keep(a.square());\n\n   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n\n   // The value returned inside the tidy function will return\n   // through the tidy, in this case to the variable y.\n   return b.add(one);\n});\n\nconsole.log('numTensors (outside tidy): ' + tf.memory().numTensors);\nconsole.log('y:');\ny.print();\nconsole.log('b:');\nb.print();\n```",
              "fileName": "#146",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tracking.ts#L146-L149",
              "isFunction": true,
              "displayName": "tf.keep",
              "urlHash": "keep"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "memory",
              "paramStr": "()",
              "parameters": [],
              "returnType": "MemoryInfo",
              "documentation": "Returns memory info at the current time in the program. The result is an\nobject with the following properties:\n\n- `numBytes`: Number of bytes allocated (undisposed) at this time.\n- `numTensors`: Number of unique tensors allocated.\n- `numDataBuffers`: Number of unique data buffers allocated\n   (undisposed) at this time, which is  the number of tensors\n   (e.g. `a.reshape(newShape)` makes a new Tensor that shares the same\n   data buffer with `a`).\n- `unreliable`: `Optional` `boolean`:\n    - On WebGL, not present (always reliable).\n    - On CPU, true. Due to automatic garbage collection, these numbers\n     represent undisposed tensors, i.e. not wrapped in `tidy()`, or\n     lacking a call to `tensor.dispose()`.",
              "fileName": "#262",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/environment.ts#L262-L265",
              "isFunction": true,
              "displayName": "tf.memory",
              "urlHash": "memory"
            }
          ]
        },
        {
          "name": "Timing",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Timing"
              },
              "symbolName": "time",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to execute and time.",
                  "type": "() => void",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise",
              "documentation": "Executes `f()` and returns a promise that resolves with timing\ninformation.\n\nThe result is an object with the following properties:\n\n- `wallMs`: Wall execution time.\n- `kernelMs`: Kernel execution time, ignoring data transfer.\n- On `WebGL` The following additional properties exist:\n   - `uploadWaitMs`: CPU blocking time on texture uploads.\n   - `downloadWaitMs`: CPU blocking time on texture downloads (readPixels).\n\n```js\nconst x = tf.randomNormal([20, 20]);\nconst time = await tf.time(() => x.matMul(x));\n\nconsole.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);\n```",
              "fileName": "#172",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/tracking.ts#L172-L175",
              "isFunction": true,
              "displayName": "tf.time",
              "urlHash": "time"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Timing"
              },
              "symbolName": "nextFrame",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Promise",
              "documentation": "Returns a promise that resolve when a requestAnimationFrame has completed.\n\nThis is simply a sugar method so that users can do the following:\n`await tf.nextFrame();`",
              "fileName": "#26",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/browser_util.ts#L26-L29",
              "isFunction": true,
              "displayName": "tf.nextFrame",
              "urlHash": "nextFrame"
            }
          ]
        }
      ]
    },
    {
      "name": "Environment",
      "description": "<p>TensorFlow.js can run mathematical operations on\ndifferent backends. Currently, we support WebGL and JavaScript\nCPU. By default, we choose the 'best' backend available, but\nallow users to customize their backend.</p>",
      "subheadings": [
        {
          "name": "",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Environment",
                "subheading": ""
              },
              "symbolName": "setBackend",
              "paramStr": "(backendType, safeMode?)",
              "parameters": [
                {
                  "name": "backendType",
                  "documentation": "The backend type. Currently supports `'webgl'|'cpu'`.",
                  "type": "'webgl'|'cpu'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "safeMode",
                  "documentation": "Defaults to false. In safe mode, you are forced to\nconstruct tensors and call math operations inside a `tidy()` which\nwill automatically clean up intermediate tensors.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Sets the backend (cpu, webgl, etc) responsible for creating tensors and\nexecuting operations on those tensors.",
              "fileName": "#228",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/environment.ts#L228-L234",
              "isFunction": true,
              "displayName": "tf.setBackend",
              "urlHash": "setBackend"
            },
            {
              "docInfo": {
                "heading": "Environment",
                "subheading": ""
              },
              "symbolName": "getBackend",
              "paramStr": "()",
              "parameters": [],
              "returnType": "'webgl'|'cpu'",
              "documentation": "Returns the current backend (cpu, webgl, etc). The backend is responsible\nfor creating tensors and executing operations on those tensors.",
              "fileName": "#240",
              "githubUrl": "https://github.com/tensorflow/tfjs-core/blob/v0.7.1/src/environment.ts#L240-L244",
              "isFunction": true,
              "displayName": "tf.getBackend",
              "urlHash": "getBackend"
            }
          ]
        }
      ]
    },
    {
      "name": "Constraints",
      "description": "<p>Constraints are added to attributes\nof a Layer (such as weights, kernels, or biases) at\nconstruction time to clamp, or otherwise enforce an allowed range,\nof values for different components of the Layer.</p>",
      "subheadings": [
        {
          "name": "",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints",
                "useDocsFrom": "MaxNorm",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "maxNorm",
              "namespace": "constraints",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxValue",
                  "documentation": "Maximum norm for incoming weights",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "axis",
                  "documentation": "Axis along which to calculate norms.\n\n  For instance, in a `Dense` layer the weight matrix\n  has shape `[inputDim, outputDim]`,\n  set `axis` to `0` to constrain each weight vector\n  of length `[inputDim,]`.\n  In a `Conv2D` layer with `dataFormat=\"channels_last\"`,\n  the weight tensor has shape\n  `[rows, cols, inputDepth, outputDepth]`,\n  set `axis` to `[0, 1, 2]`\n  to constrain the weights of each filter tensor of size\n  `[rows, cols, inputDepth]`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "MaxNorm weight constraint.\n\nConstrains the weights incident to each hidden unit\nto have a norm less than or equal to a desired value.\n\nReferences\n       - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting\nSrivastava, Hinton, et al.\n2014](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
              "fileName": "#681",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L681-L689",
              "isFunction": true,
              "displayName": "tf.constraints.maxNorm",
              "urlHash": "constraints.maxNorm"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints",
                "useDocsFrom": "MinMaxNormConfig",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "minMaxNorm",
              "namespace": "constraints",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minValue",
                  "documentation": "Minimum norm for incoming weights",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "maxValue",
                  "documentation": "Maximum norm for incoming weights",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "axis",
                  "documentation": "Axis along which to calculate norms.\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "rate",
                  "documentation": "Rate for enforcing the constraint: weights will be rescaled to yield:\n`(1 - rate) * norm + rate * norm.clip(minValue, maxValue)`.\nEffectively, this means that rate=1.0 stands for strict\nenforcement of the constraint, while rate<1.0 means that\nweights will be rescaled at each step to slowly move\ntowards a value inside the desired interval.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "",
              "fileName": "#707",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L707-L715",
              "isFunction": true,
              "displayName": "tf.constraints.minMaxNorm",
              "urlHash": "constraints.minMaxNorm"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints",
                "useDocsFrom": "NonNeg",
                "subheading": ""
              },
              "symbolName": "nonNeg",
              "namespace": "constraints",
              "paramStr": "()",
              "parameters": [],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "Constains the weight to be non-negative.",
              "fileName": "#701",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L701-L705",
              "isFunction": true,
              "displayName": "tf.constraints.nonNeg",
              "urlHash": "constraints.nonNeg"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints",
                "useDocsFrom": "UnitNorm",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "unitNorm",
              "namespace": "constraints",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Axis along which to calculate norms.\n\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "Constrains the weights incident to each hidden unit to have unit norm.",
              "fileName": "#691",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L691-L699",
              "isFunction": true,
              "displayName": "tf.constraints.unitNorm",
              "urlHash": "constraints.unitNorm"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Constraints",
                "subheading": "Classes",
                "namespace": "constraints"
              },
              "symbolName": "Constraint",
              "namespace": "constraints",
              "documentation": "Base class for functions that impose constraints on weight values",
              "fileName": "#31",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/constraints.ts#L31-L38",
              "methods": [],
              "isClass": true,
              "displayName": "tf.constraints.Constraint",
              "urlHash": "class:constraints.Constraint"
            }
          ]
        }
      ]
    },
    {
      "name": "Initializers",
      "description": "<p>Initializers are used in Layers\nto establish the starting the values of weights, biases, kernels, \netc.</p>",
      "subheadings": [
        {
          "name": "",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "Constant",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "constant",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "value",
                  "documentation": "The value for each element in the variable. ",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates values initialized to some constant.",
              "fileName": "#734",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L734-L743",
              "isFunction": true,
              "displayName": "tf.initializers.constant",
              "urlHash": "initializers.constant"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "GlorotNormal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "glorotNormal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "Random number generator seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Glorot normal initializer, also called Xavier normal initializer.\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor.\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf",
              "fileName": "#811",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L811-L820",
              "isFunction": true,
              "displayName": "tf.initializers.glorotNormal",
              "urlHash": "initializers.glorotNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "GlorotUniform",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "glorotUniform",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "Random number generator seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Glorot uniform initializer, also called Xavier uniform initializer.\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.",
              "fileName": "#800",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L800-L809",
              "isFunction": true,
              "displayName": "tf.initializers.glorotUniform",
              "urlHash": "initializers.glorotUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "HeNormal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "heNormal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "Random number generator seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "He normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
              "fileName": "#822",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L822-L831",
              "isFunction": true,
              "displayName": "tf.initializers.heNormal",
              "urlHash": "initializers.heNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "Identity",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "identity",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "gain",
                  "documentation": "Multiplicative factor to apply to the identity matrix.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates the identity matrix.\nOnly use for square 2D matrices.",
              "fileName": "#778",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L778-L787",
              "isFunction": true,
              "displayName": "tf.initializers.identity",
              "urlHash": "initializers.identity"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "LeCunNormal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "leCunNormal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "Random number generator seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "LeCun normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(1 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReferences:\n   [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)\n   [Efficient Backprop](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf)",
              "fileName": "#833",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L833-L842",
              "isFunction": true,
              "displayName": "tf.initializers.leCunNormal",
              "urlHash": "initializers.leCunNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "Ones",
                "subheading": ""
              },
              "symbolName": "ones",
              "namespace": "initializers",
              "paramStr": "()",
              "parameters": [],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates tensors initialized to 1.",
              "fileName": "#728",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L728-L732",
              "isFunction": true,
              "displayName": "tf.initializers.ones",
              "urlHash": "initializers.ones"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "Orthogonal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "orthogonal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "gain",
                  "documentation": "Multiplicative factor to apply to the orthogonal matrix. Defaults to 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates a random orthogonal matrix.\n\nReference:\n[Saxe et al., http://arxiv.org/abs/1312.6120](http://arxiv.org/abs/1312.6120)",
              "fileName": "#844",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L844-L852",
              "isFunction": true,
              "displayName": "tf.initializers.orthogonal",
              "urlHash": "initializers.orthogonal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "RandomNormal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "randomNormal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "Mean of the random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "stddev",
                  "documentation": "Standard deviation of the random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "documentation": "Used to seed the random generator. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a normal\ndistribution.",
              "fileName": "#756",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L756-L765",
              "isFunction": true,
              "displayName": "tf.initializers.randomNormal",
              "urlHash": "initializers.randomNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "RandomUniform",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "randomUniform",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minval",
                  "documentation": "Lower bound of the range of random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "maxval",
                  "documentation": "Upper bound of the range of random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "documentation": "Used to seed the random generator. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a uniform\ndistribution.\n\nValues will be distributed uniformly between the configured minval and\nmaxval.",
              "fileName": "#745",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L745-L754",
              "isFunction": true,
              "displayName": "tf.initializers.randomUniform",
              "urlHash": "initializers.randomUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "TruncatedNormal",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "truncatedNormal",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "Mean of the random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "stddev",
                  "documentation": "Standard deviation of the random values to generate. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "documentation": "Used to seed the random generator. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a truncated normal.\ndistribution.\n\nThese values are similar to values from a `RandomNormal` except that values\nmore than two standard deviations from the mean are discarded and re-drawn.\nThis is the recommended initializer for neural network weights and filters.",
              "fileName": "#767",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L767-L776",
              "isFunction": true,
              "displayName": "tf.initializers.truncatedNormal",
              "urlHash": "initializers.truncatedNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "VarianceScaling",
                "configParamIndices": [
                  0
                ],
                "subheading": ""
              },
              "symbolName": "varianceScaling",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scale",
                  "documentation": "Scaling factor (positive float). ",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "mode",
                  "documentation": "Fanning mode for inputs and outputs. ",
                  "type": "'fanIn'|'fanOut'|'fanAvg'",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "distribution",
                  "documentation": "Probabilistic distribution of the values. ",
                  "type": "'normal'|'uniform'",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "documentation": "Random number generator seed. ",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer capable of adapting its scale to the shape of weights.\nWith distribution=NORMAL, samples are drawn from a truncated normal\ndistribution centered on zero, with `stddev = sqrt(scale / n)` where n is:\n   - number of input units in the weight tensor, if mode = FAN_IN.\n   - number of output units, if mode = FAN_OUT.\n   - average of the numbers of input and output units, if mode = FAN_AVG.\nWith distribution=UNIFORM,\nsamples are drawn from a uniform distribution\nwithin [-limit, limit], with `limit = sqrt(3 * scale / n)`.",
              "fileName": "#789",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L789-L798",
              "isFunction": true,
              "displayName": "tf.initializers.varianceScaling",
              "urlHash": "initializers.varianceScaling"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers",
                "useDocsFrom": "Zeros",
                "subheading": ""
              },
              "symbolName": "zeros",
              "namespace": "initializers",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Zeros",
              "documentation": "Initializer that generates tensors initialized to 0.",
              "fileName": "#719",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L719-L726",
              "isFunction": true,
              "displayName": "tf.initializers.zeros",
              "urlHash": "initializers.zeros"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Initializers",
                "subheading": "Classes",
                "namespace": "initializers"
              },
              "symbolName": "Initializer",
              "namespace": "initializers",
              "documentation": "Initializer base class.",
              "fileName": "#60",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/initializers.ts#L60-L81",
              "methods": [],
              "isClass": true,
              "displayName": "tf.initializers.Initializer",
              "urlHash": "class:initializers.Initializer"
            }
          ]
        }
      ]
    },
    {
      "name": "Regularizers",
      "description": "<p>Regularizers can be attached to various components\nof a Layer to add a 'scoring' function to help drive weights, or \nother trainable values, away from excessively large values.  They're\ntypically used to promote a notion that a 'simpler' model is better\nthan a complicated model, assuming equal performance.</p>",
      "subheadings": [
        {
          "name": "",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers",
                "subheading": ""
              },
              "symbolName": "L1L2",
              "namespace": "regularizers",
              "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/regularizers.ts#L52-L92",
              "methods": [],
              "isClass": true,
              "inheritsFrom": "Regularizer",
              "displayName": "tf.regularizers.L1L2",
              "urlHash": "class:regularizers.L1L2"
            },
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers",
                "useDocsFrom": "L1L2",
                "subheading": ""
              },
              "symbolName": "l1",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "L1Config",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
              "fileName": "#862",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L862-L866",
              "isFunction": true,
              "displayName": "tf.regularizers.l1",
              "urlHash": "regularizers.l1"
            },
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers",
                "useDocsFrom": "L1L2",
                "subheading": ""
              },
              "symbolName": "l1l2",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "L1L2Config",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
              "fileName": "#856",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L856-L860",
              "isFunction": true,
              "displayName": "tf.regularizers.l1l2",
              "urlHash": "regularizers.l1l2"
            },
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers",
                "useDocsFrom": "L1L2",
                "subheading": ""
              },
              "symbolName": "l2",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "L2Config",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
              "fileName": "#868",
              "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/v0.4.0/src/exports.ts#L868-L872",
              "isFunction": true,
              "displayName": "tf.regularizers.l2",
              "urlHash": "regularizers.l2"
            }
          ]
        }
      ]
    }
  ]
}