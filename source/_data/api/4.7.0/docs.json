{
  "headings": [
    {
      "name": "Tensors",
      "description": "<p>Tensors are the core datastructure of TensorFlow.js\nThey are a generalization of vectors and matrices to potentially\nhigher dimensions.</p>",
      "subheadings": [
        {
          "name": "Creation",
          "description": "<p>We have utility functions for common cases like Scalar, 1D,\n2D, 3D and 4D tensors, as well a number of functions to initialize\ntensors in ways useful for machine learning.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), or a `WebGLData` object, or a\n`WebGPUData` object. If the values are strings, they will be encoded as utf-8\nand kept as `Uint8Array[]`. If the values is a `WebGLData` object, the dtype\ncould only be 'float32' or 'int32' and the object has to have: 1. texture, a\n`WebGLTexture`, the texture must share the same `WebGLRenderingContext` with\nTFJS's WebGL backend (you could create a custom WebGL backend from your\ntexture's canvas) and the internal texture format for the input texture must\nbe floating point or normalized integer; 2. height, the height of the\ntexture; 3. width, the width of the texture; 4. channels, a non-empty subset\nof 'RGBA', indicating the values of which channels will be passed to the\ntensor, such as 'R' or 'BR' (The order of the channels affect the order of\ntensor values. ). (If the values passed from texture is less than the tensor\nsize, zeros will be padded at the rear.). If the values is a `WebGPUData`\nobject, the dtype could only be 'float32' or 'int32 and the object has to\nhave: buffer, a `GPUBuffer`. The buffer must: 1. share the same `GPUDevice`\nwith TFJS's WebGPU backend; 2. buffer.usage should at least support\nGPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC; 3. buffer.size should not\nbe smaller than the byte size of tensor shape. WebGPUData optionally supports\nzero copy by flag zeroCopy. When zeroCopy is false or undefined(default),\nthis passing GPUBuffer can be destroyed after tensor is created. When\nzeroCopy is true, this GPUBuffer is bound directly by the tensor, so do not\ndestroy this GPUBuffer until all access is done.",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array|WebGLData|WebGPUData",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\n```js\n// Pass an array of values to create a vector.\ntf.tensor([1, 2, 3, 4]).print();\n```\n\n```js\n// Pass a nested array of values to make a matrix or a higher\n// dimensional tensor.\ntf.tensor([[1, 2], [3, 4]]).print();\n```\n\n```js\n// Pass a flat array and specify a shape yourself.\ntf.tensor([1, 2, 3, 4], [2, 2]).print();\n```\n\n```js\n// Pass a `WebGLData` object and specify a shape yourself.\n\n// This makes it possible for TF.js applications to avoid GPU / CPU sync.\n// For example, if your application includes a preprocessing step on the GPU,\n// you could upload the GPU output directly to TF.js, rather than first\n// downloading the values.\n\n// Example for WebGL2:\nif (tf.findBackend('custom-webgl') == null) {\n   const customCanvas = document.createElement('canvas');\n   const customBackend = new tf.MathBackendWebGL(customCanvas);\n   tf.registerBackend('custom-webgl', () => customBackend);\n}\nconst savedBackend = tf.getBackend();\nawait tf.setBackend('custom-webgl');\nconst gl = tf.backend().gpgpu.gl;\nconst texture = gl.createTexture();\nconst tex2d = gl.TEXTURE_2D;\nconst width = 2;\nconst height = 2;\n\ngl.bindTexture(tex2d, texture);\ngl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\ngl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\ngl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.texImage2D(\n   tex2d, 0, gl.RGBA32F, // internalFormat\n   width, height, 0,\n   gl.RGBA, // textureFormat\n   gl.FLOAT, // textureType\n   new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n);\n\n// Currently, the `texture` has 4 pixels:\n// Pixel0 is {R:0, G:1, B:2, A:3}\n// Pixel1 is {R:4, G:5, B:6, A:7}\n// Pixel2 is {R:8, G:9, B:10, A:11}\n// Pixel3 is {R:12, G:13, B:14, A:15}\n\nconst logicalShape = [height * width * 2];\nconst a = tf.tensor({texture, height, width, channels: 'BR'}, logicalShape);\na.print();\n// Tensor value will be [2, 0, 6, 4, 10, 8, 14, 12], since [2, 0] is the\n// values of 'B' and 'R' channels of Pixel0, [6, 4] is the values of 'B' and\n'R'\n// channels of Pixel1...\n\n// For postprocessing on the GPU, it's possible to retrieve the texture\n// backing any tensor by calling the tensor's `dataToGPU` method like\n// so:\n\nconst tex = a.dataToGPU();\nawait tf.setBackend(savedBackend);\n```\n\n```js\n// Pass a `WebGPUData` object and specify a shape yourself.\n\n// This makes it possible for TF.js applications to avoid GPU / CPU sync.\n// For example, if your application includes a preprocessing step on the GPU,\n// you could upload the GPU output directly to TF.js, rather than first\n// downloading the values. Unlike WebGL, this optionally supports zero copy\n// by WebGPUData.zeroCopy. When zeroCopy is false or undefined(default), this\n// passing GPUBuffer can be destroyed after tensor is created. When zeroCopy\n// is true, this GPUBuffer is bound directly by the tensor, so do not destroy\n// this GPUBuffer until all access is done.\n\n// Example for WebGPU:\nfunction createGPUBufferFromData(device, data, dtype) {\n   const bytesPerElement = 4;\n   const sizeInBytes = data.length * bytesPerElement;\n\n   const gpuWriteBuffer = device.createBuffer({\n     mappedAtCreation: true,\n     size: sizeInBytes,\n     usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC\n   });\n   const arrayBuffer = gpuWriteBuffer.getMappedRange();\n   if (dtype === 'float32') {\n     new Float32Array(arrayBuffer).set(data);\n   } else if (dtype === 'int32') {\n     new Int32Array(arrayBuffer).set(data);\n   } else {\n     throw new Error(\n         `Creating tensor from GPUBuffer only supports` +\n         `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n   }\n   gpuWriteBuffer.unmap();\n\n   const gpuReadBuffer = device.createBuffer({\n     mappedAtCreation: false,\n     size: sizeInBytes,\n     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE |\n         GPUBufferUsage.COPY_SRC\n   });\n\n   const copyEncoder = device.createCommandEncoder();\n   copyEncoder.copyBufferToBuffer(\n       gpuWriteBuffer, 0, gpuReadBuffer, 0, sizeInBytes);\n   const copyCommands = copyEncoder.finish();\n   device.queue.submit([copyCommands]);\n   gpuWriteBuffer.destroy();\n   return gpuReadBuffer;\n}\n\nconst savedBackend = tf.getBackend();\nawait tf.setBackend('webgpu').catch(\n     () => {throw new Error(\n         'Failed to use WebGPU backend. Please use Chrome Canary to run.')});\nconst dtype = 'float32';\nconst device = tf.backend().device;\nconst aData = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nconst bData = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4];\nconst expected = [2, 4, 6, 8, 6, 8, 10, 12, 10, 12, 14, 16, 14, 16, 18, 20];\nconst aBuffer = createGPUBufferFromData(device, aData, dtype);\nconst shape = [aData.length];\n// To use zeroCopy, use {buffer: aBuffer, zeroCopy: true} instead and destroy\n// aBuffer untill all access is done.\nconst a = tf.tensor({buffer: aBuffer}, shape, dtype);\nconst b = tf.tensor(bData, shape, dtype);\nconst result = tf.add(a, b);\nresult.print();\na.dispose();\nb.dispose();\nresult.dispose();\naBuffer.destroy();\nawait tf.setBackend(savedBackend);\n```",
              "fileName": "#203",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor.ts#L203-L208",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor",
              "urlHash": "tensor"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "scalar",
              "paramStr": "(value, dtype?)",
              "parameters": [
                {
                  "name": "value",
                  "documentation": "The value of the scalar.",
                  "type": "number|boolean|string|Uint8Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Scalar](#class:Tensor)",
              "documentation": "Creates rank-0 [tf.Tensor](#class:Tensor) (scalar) with the provided value and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.scalar()](#scalar) as it makes the code more readable.\n\n```js\ntf.scalar(3.14).print();\n```",
              "fileName": "#38",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/scalar.ts#L38-L55",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.scalar",
              "urlHash": "scalar"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor1d",
              "paramStr": "(values, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be array of numbers,\nor a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Creates rank-1 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor1d()](#tensor1d) as it makes the code more readable.\n\n```js\ntf.tensor1d([1, 2, 3]).print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor1d.ts#L41-L49",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor1d",
              "urlHash": "tensor1d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor2d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. If not provided, it is inferred from\n`values`.",
                  "type": "[number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Creates rank-2 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor2d()](#tensor2d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor2d([[1, 2], [3, 4]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor2d.ts#L48-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor2d",
              "urlHash": "tensor2d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor3d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. If not provided,  it is inferred from\n`values`.",
                  "type": "[number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)",
              "documentation": "Creates rank-3 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor3d()](#tensor3d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor3d.ts#L48-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor3d",
              "urlHash": "tensor3d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor4d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "[number, number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Creates rank-4 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor4d()](#tensor4d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor4d.ts#L48-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor4d",
              "urlHash": "tensor4d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor5d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "[number, number, number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor5D](#class:Tensor)",
              "documentation": "Creates rank-5 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor5d()](#tensor5d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor5d([[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor5d.ts#L48-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor5d",
              "urlHash": "tensor5d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "tensor6d",
              "paramStr": "(values, shape?, dtype?)",
              "parameters": [
                {
                  "name": "values",
                  "documentation": "The values of the tensor. Can be nested array of numbers,\nor a flat array, or a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).",
                  "type": "[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The shape of the tensor. Optional. If not provided,\nit is inferred from `values`.",
                  "type": "[number, number, number, number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor6D](#class:Tensor)",
              "documentation": "Creates rank-6 [tf.Tensor](#class:Tensor) with the provided values, shape and dtype.\n\nThe same functionality can be achieved with [tf.tensor()](#tensor), but in general\nwe recommend using [tf.tensor6d()](#tensor6d) as it makes the code more readable.\n\n  ```js\n// Pass a nested array.\ntf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n```\n```js\n// Pass a flat array and specify a shape.\ntf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor6d.ts#L48-L70",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensor6d",
              "urlHash": "tensor6d"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "buffer",
              "paramStr": "(shape, dtype?, values?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The dtype of the buffer. Defaults to 'float32'.",
                  "type": "'float32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": "The values of the buffer as [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray). Defaults to\nzeros.",
                  "type": "DataTypeMap['float32']",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.TensorBuffer](#class:TensorBuffer)",
              "documentation": "Creates an empty [tf.TensorBuffer](#class:TensorBuffer) with the specified `shape` and `dtype`.\n\nThe values are stored in CPU as [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray). Fill the buffer using\n`buffer.set()`, or by modifying directly `buffer.values`.\n\nWhen done, call `buffer.toTensor()` to get an immutable [tf.Tensor](#class:Tensor) with\nthose values.\n\n```js\n// Create a buffer and set values at particular indices.\nconst buffer = tf.buffer([2, 2]);\nbuffer.set(3, 0, 0);\nbuffer.set(5, 1, 0);\n\n// Convert the buffer back to a tensor.\nbuffer.toTensor().print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/buffer.ts#L48-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.buffer",
              "urlHash": "buffer"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "clone",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to clone.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a new tensor with the same values and shape as the specified\ntensor.\n\n```js\nconst x = tf.tensor([1, 2]);\n\nx.clone().print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/clone.ts#L41-L48",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.clone",
              "urlHash": "clone"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "complex",
              "paramStr": "(real, imag)",
              "parameters": [
                {
                  "name": "real",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "imag",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Converts two real numbers to a complex number.\n\nGiven a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form [r0, i0, r1, i1],\nwhere r represents the real part and i represents the imag part.\n\nThe input tensors real and imag must have the same shape.\n\n```js\nconst real = tf.tensor1d([2.25, 3.25]);\nconst imag = tf.tensor1d([4.75, 5.75]);\nconst complex = tf.complex(real, imag);\n\ncomplex.print();\n```",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/complex.ts#L47-L57",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.complex",
              "urlHash": "complex"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "diag",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns a diagonal tensor with given diagonal values.\n\nGiven a diagonal, this operation returns a tensor with the diagonal and\neverything else padded with zeros.\n\nAssume the input has dimensions `[D1,..., Dk]`, then the output is a tensor\nof rank 2k with dimensions `[D1,..., Dk, D1,..., Dk]`\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\ntf.diag(x).print()\n```\n```js\nconst x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [4, 2])\n\ntf.diag(x).print()\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/diag.ts#L49-L55",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.diag",
              "urlHash": "diag"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "eye",
              "paramStr": "(numRows, numColumns?, batchShape?, dtype?)",
              "parameters": [
                {
                  "name": "numRows",
                  "documentation": "Number of rows.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numColumns",
                  "documentation": "Number of columns. Defaults to `numRows`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "batchShape",
                  "documentation": "If provided, will add the batch shape to the beginning\nof the shape of the returned [tf.Tensor](#class:Tensor) by repeating the identity\nmatrix.",
                  "type": "[\n          number\n        ]|[number,\n           number]|[number, number, number]|[number, number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "Data type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Create an identity matrix.",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/eye.ts#L41-L80",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.eye",
              "urlHash": "eye"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "fill",
              "paramStr": "(shape, value, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "value",
                  "documentation": "The scalar value to fill the tensor with.",
                  "type": "number|string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Defaults to\n'float32' if the given param value is a number, otherwise 'string'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) filled with a scalar value.\n\n```js\ntf.fill([2, 2], 4).print();\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/fill.ts#L40-L48",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.fill",
              "urlHash": "fill"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "imag",
              "paramStr": "(input)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the imaginary part of a complex (or real) tensor.\n\nGiven a tensor input, this operation returns a tensor of type float that is\nthe imaginary part of each element in input considered as a complex number.\nIf input is real, a tensor of all zeros is returned.\n\n```js\nconst x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\ntf.imag(x).print();\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/imag.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.imag",
              "urlHash": "imag"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "linspace",
              "paramStr": "(start, stop, num)",
              "parameters": [
                {
                  "name": "start",
                  "documentation": "The start value of the sequence.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stop",
                  "documentation": "The end value of the sequence.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "num",
                  "documentation": "The number of values to generate.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Return an evenly spaced sequence of numbers over the given interval.\n\n```js\ntf.linspace(0, 9, 10).print();\n```",
              "fileName": "#35",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/linspace.ts#L35-L42",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.linspace",
              "urlHash": "linspace"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "oneHot",
              "paramStr": "(indices, depth, onValue?, offValue?, dtype?)",
              "parameters": [
                {
                  "name": "indices",
                  "documentation": "[tf.Tensor](#class:Tensor) of indices with dtype `int32`. Indices must\nstart from 0.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depth",
                  "documentation": "The depth of the one hot dimension.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "onValue",
                  "documentation": "A number used to fill in the output when the index matches\nthe location.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "offValue",
                  "documentation": "A number used to fill in the output when the index does\nnot match the location.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The dtype of the output tensor, default to 'int32'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a one-hot [tf.Tensor](#class:Tensor). The locations represented by `indices` take\nvalue `onValue` (defaults to 1), while all other locations take value\n`offValue` (defaults to 0). If `indices` is rank `R`, the output has rank\n`R+1` with the last axis of size `depth`.\n`indices` used to encode prediction class must start from 0. For example,\n  if you have 3 classes of data, class 1 should be encoded as 0, class 2\n  should be 1, and class 3 should be 2.\n\n```js\ntf.oneHot(tf.tensor1d([0, 1], 'int32'), 3).print();\n```",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/one_hot.ts#L52-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.oneHot",
              "urlHash": "oneHot"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "ones",
              "paramStr": "(shape, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Defaults to\n'float'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 1.\n\n```js\ntf.ones([2, 2]).print();\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/ones.ts#L39-L49",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.ones",
              "urlHash": "ones"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "onesLike",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 1 with the same shape as the\ngiven tensor.\n\n```js\nconst x = tf.tensor([1, 2]);\ntf.onesLike(x).print();\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/ones_like.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.onesLike",
              "urlHash": "onesLike"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "print",
              "paramStr": "(x, verbose?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to be printed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "verbose",
                  "documentation": "Whether to print verbose information about the ` Tensor`,\nincluding dtype and size.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Prints information about the [tf.Tensor](#class:Tensor) including its data.\n\n```js\nconst verbose = true;\ntf.tensor2d([1, 2, 3, 4], [2, 2]).print(verbose);\n```",
              "fileName": "#33",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/print.ts#L33-L35",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.print",
              "urlHash": "print"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "range",
              "paramStr": "(start, stop, step?, dtype?)",
              "parameters": [
                {
                  "name": "start",
                  "documentation": "An integer start value",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stop",
                  "documentation": "An integer stop value",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "step",
                  "documentation": "An integer increment (will default to 1 or -1)",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor. Defaults to 'float32'.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Creates a new [tf.Tensor1D](#class:Tensor) filled with the numbers in the range provided.\n\nThe tensor is a half-open interval meaning it includes start, but\nexcludes stop. Decrementing ranges and negative step values are also\nsupported.\n\n\n```js\ntf.range(0, 9, 2).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/range.ts#L42-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.range",
              "urlHash": "range"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "real",
              "paramStr": "(input)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the real part of a complex (or real) tensor.\n\nGiven a tensor input, this operation returns a tensor of type float that is\nthe real part of each element in input considered as a complex number.\n\nIf the input is real, it simply makes a clone.\n\n```js\nconst x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\ntf.real(x).print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/real.ts#L41-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.real",
              "urlHash": "real"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "truncatedNormal",
              "paramStr": "(shape, mean?, stdDev?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "The mean of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "stdDev",
                  "documentation": "The standard deviation of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a truncated normal\ndistribution.\n\n```js\ntf.truncatedNormal([2, 2]).print();\n```\n\nThe generated values follow a normal distribution with specified mean and\nstandard deviation, except that values whose magnitude is more than 2\nstandard deviations from the mean are dropped and re-picked.",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/truncated_normal.ts#L46-L60",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.truncatedNormal",
              "urlHash": "truncatedNormal"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "variable",
              "paramStr": "(initialValue, trainable?, name?, dtype?)",
              "parameters": [
                {
                  "name": "initialValue",
                  "documentation": "Initial value for the tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "trainable",
                  "documentation": "If true, optimizers are allowed to update it.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "name",
                  "documentation": "Name of the variable. Defaults to a unique id.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "If set, initialValue will be converted to the given type.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Variable](#class:Variable)",
              "documentation": "Creates a new variable with the provided initial value.\n```js\nconst x = tf.variable(tf.tensor([1, 2, 3]));\nx.assign(tf.tensor([4, 5, 6]));\n\nx.print();\n```",
              "fileName": "#38",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/variable.ts#L38-L43",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.variable",
              "urlHash": "variable"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "zeros",
              "paramStr": "(shape, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The type of an element in the resulting tensor. Can\nbe 'float32', 'int32' or 'bool'. Defaults to 'float'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 0.\n\n```js\ntf.zeros([2, 2]).print();\n```",
              "fileName": "#38",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/zeros.ts#L38-L48",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.zeros",
              "urlHash": "zeros"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Creation"
              },
              "symbolName": "zerosLike",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor of required shape.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with all elements set to 0 with the same shape as the\ngiven tensor.\n\n```js\nconst x = tf.tensor([1, 2]);\ntf.zerosLike(x).print();\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/zeros_like.ts#L40-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.zerosLike",
              "urlHash": "zerosLike"
            }
          ]
        },
        {
          "name": "Classes",
          "description": "<p>\nThis section shows the main Tensor related classes in TensorFlow.js and\nthe methods we expose on them.\n</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "Tensor",
              "documentation": "A [tf.Tensor](#class:Tensor) object represents an immutable, multidimensional array of\nnumbers that has a shape and a data type.\n\nFor performance reasons, functions that create tensors do not necessarily\nperform a copy of the data passed to them (e.g. if the data is passed as a\n`Float32Array`), and changes to the data will change the tensor. This is not\na feature and is not supported. To avoid this behavior, use the tensor before\nchanging the input data or create a copy with `copy = tf.add(yourTensor, 0)`.\n\nSee [tf.tensor()](#tensor) for details on how to create a [tf.Tensor](#class:Tensor).",
              "fileName": "#257",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L257-L500",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "buffer",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise<[tf.TensorBuffer](#class:TensorBuffer)>",
                  "documentation": "Returns a promise of [tf.TensorBuffer](#class:TensorBuffer) that holds the underlying data.",
                  "fileName": "#305",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L305-L308",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.buffer"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "bufferSync",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.TensorBuffer](#class:TensorBuffer)",
                  "documentation": "Returns a [tf.TensorBuffer](#class:TensorBuffer) that holds the underlying data.",
                  "fileName": "#314",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L314-L316",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.bufferSync"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "array",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise<number[]>",
                  "documentation": "Returns the tensor data as a nested array. The transfer of data is done\nasynchronously.",
                  "fileName": "#324",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L324-L328",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.array"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "arraySync",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "number[]",
                  "documentation": "Returns the tensor data as a nested array. The transfer of data is done\nsynchronously.",
                  "fileName": "#336",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L336-L340",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.arraySync"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "data",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise<DataTypeMap[NumericDataType]>",
                  "documentation": "Asynchronously downloads the values from the [tf.Tensor](#class:Tensor). Returns a\npromise of [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) that resolves when the computation has finished.",
                  "fileName": "#348",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L348-L362",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.data"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "dataToGPU",
                  "paramStr": "(options?)",
                  "parameters": [
                    {
                      "name": "options",
                      "documentation": ":\nFor WebGL,\n- customTexShape: Optional. If set, will use the user defined\ntexture shape to create the texture.",
                      "type": "DataToGPUOptions",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "GPUData",
                  "documentation": "Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`\nand `data()`, this method prevents data from being downloaded to CPU.\n\nFor WebGL backend, the data will be stored on a densely packed texture.\nThis means that the texture will use the RGBA channels to store value.\n\nFor WebGPU backend, the data will be stored on a buffer. There is no\nparameter, so can not use a user-defined size to create the buffer.",
                  "fileName": "#398",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L398-L401",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.dataToGPU"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "dataSync",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "DataTypeMap[NumericDataType]",
                  "documentation": "Synchronously downloads the values from the [tf.Tensor](#class:Tensor). This blocks the\nUI thread until the values are ready, which can cause performance issues.",
                  "fileName": "#409",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L409-L423",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.dataSync"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "dispose",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "void",
                  "documentation": "Disposes [tf.Tensor](#class:Tensor) from memory.",
                  "fileName": "#441",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L441-L447",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.dispose"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "print",
                  "paramStr": "(verbose?)",
                  "parameters": [
                    {
                      "name": "verbose",
                      "documentation": "Whether to print verbose information about the tensor,\nincluding dtype and size.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Prints the [tf.Tensor](#class:Tensor). See [tf.print()](#print) for details.",
                  "fileName": "#468",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L468-L470",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.print"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "clone",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Returns a copy of the tensor. See [tf.clone()](#clone) for details.",
                  "fileName": "#476",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L476-L479",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.clone"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "toString",
                  "paramStr": "(verbose?)",
                  "parameters": [
                    {
                      "name": "verbose",
                      "documentation": "",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "string",
                  "documentation": "Returns a human-readable description of the tensor. Useful for logging.",
                  "fileName": "#486",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L486-L489",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Tensor.toString"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "TensorInfo",
              "displayName": "tf.Tensor",
              "urlHash": "class:Tensor"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "Variable",
              "documentation": "A mutable [tf.Tensor](#class:Tensor), useful for persisting state, e.g. for training.",
              "fileName": "#559",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L559-L598",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Classes"
                  },
                  "symbolName": "assign",
                  "paramStr": "(newValue)",
                  "parameters": [
                    {
                      "name": "newValue",
                      "documentation": "New tensor to be assigned to this variable.",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Assign a new [tf.Tensor](#class:Tensor) to this variable. The new [tf.Tensor](#class:Tensor) must have\nthe same shape and dtype as the old [tf.Tensor](#class:Tensor).",
                  "fileName": "#578",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L578-L592",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Variable.assign"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "[tf.Tensor](#class:Tensor)",
              "displayName": "tf.Variable",
              "urlHash": "class:Variable"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Classes"
              },
              "symbolName": "TensorBuffer",
              "documentation": "A mutable object, similar to [tf.Tensor](#class:Tensor), that allows users to set values\nat locations before converting to an immutable [tf.Tensor](#class:Tensor).\n\nSee [tf.buffer()](#buffer) for creating a tensor buffer.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L45-L161",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "set",
                  "paramStr": "(value, ...locs)",
                  "parameters": [
                    {
                      "name": "value",
                      "documentation": "The value to set.",
                      "type": "SingleValueMap[D]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "...locs",
                      "documentation": "The location indices.",
                      "type": "number[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Sets a value in the buffer at a given location.",
                  "fileName": "#80",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L80-L91",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.set"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "get",
                  "paramStr": "(...locs)",
                  "parameters": [
                    {
                      "name": "...locs",
                      "documentation": "The location indices.",
                      "type": "number[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "SingleValueMap[D]",
                  "documentation": "Returns the value in the buffer at the provided location.",
                  "fileName": "#100",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L100-L118",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.get"
                },
                {
                  "docInfo": {
                    "heading": "Tensors",
                    "subheading": "Creation"
                  },
                  "symbolName": "toTensor",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "[tf.Tensor](#class:Tensor)",
                  "documentation": "Creates an immutable [tf.Tensor](#class:Tensor) object from the buffer.",
                  "fileName": "#157",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/tensor.ts#L157-L160",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.TensorBuffer.toTensor"
                }
              ],
              "tags": [],
              "isClass": true,
              "displayName": "tf.TensorBuffer",
              "urlHash": "class:TensorBuffer"
            }
          ]
        },
        {
          "name": "Transformations",
          "description": "<p>This section describes some common Tensor\ntransformations for reshaping and type-casting.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "batchToSpaceND",
              "paramStr": "(x, blockShape, crops)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A [tf.Tensor](#class:Tensor). N-D with `x.shape` = `[batch] + spatialShape +\nremainingShape`, where spatialShape has `M` dimensions.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "blockShape",
                  "documentation": "A 1-D array. Must have shape `[M]`, all values must\nbe >= 1.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "crops",
                  "documentation": "A 2-D array.  Must have shape `[M, 2]`, all values must be >= 0.\n`crops[i] = [cropStart, cropEnd]` specifies the amount to crop from input\ndimension `i + 1`, which corresponds to spatial dimension `i`. It is required\nthat `cropStart[i] + cropEnd[i] <= blockShape[i] * inputShape[i + 1]`\n\nThis operation is equivalent to the following steps:\n\n1. Reshape `x` to `reshaped` of shape: `[blockShape[0], ...,\nblockShape[M-1], batch / prod(blockShape), x.shape[1], ...,\nx.shape[N-1]]`\n\n2. Permute dimensions of `reshaped` to produce `permuted` of shape `[batch /\nprod(blockShape),x.shape[1], blockShape[0], ..., x.shape[M],\nblockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`\n\n3. Reshape `permuted` to produce `reshapedPermuted` of shape `[batch /\nprod(blockShape),x.shape[1] * blockShape[0], ..., x.shape[M] *\nblockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`\n\n4. Crop the start and end of dimensions `[1, ..., M]` of `reshapedPermuted`\naccording to `crops` to produce the output of shape: `[batch /\nprod(blockShape),x.shape[1] * blockShape[0] - crops[0,0] - crops[0,1],\n..., x.shape[M] * blockShape[M-1] - crops[M-1,0] -\ncrops[M-1,1],x.shape[M+1], ..., x.shape[N-1]]`",
                  "type": "number[][]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "This operation reshapes the \"batch\" dimension 0 into `M + 1` dimensions of\nshape `blockShape + [batch]`, interleaves these blocks back into the grid\ndefined by the spatial dimensions `[1, ..., M]`, to obtain a result with\nthe same rank as the input. The spatial dimensions of this intermediate\nresult are then optionally cropped according to `crops` to produce the\noutput. This is the reverse of [tf.spaceToBatchND()](#spaceToBatchND). See below for a precise\ndescription.\n\n```js\nconst x = tf.tensor4d([1, 2, 3, 4], [4, 1, 1, 1]);\nconst blockShape = [2, 2];\nconst crops = [[0, 0], [0, 0]];\n\nx.batchToSpaceND(blockShape, crops).print();\n```",
              "fileName": "#77",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/batch_to_space_nd.ts#L77-L105",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.batchToSpaceND",
              "urlHash": "batchToSpaceND"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "broadcastArgs",
              "paramStr": "(s0, s1)",
              "parameters": [
                {
                  "name": "s0",
                  "documentation": "A tensor representing a shape",
                  "type": "[tf.Tensor](#class:Tensor) | [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "s1",
                  "documentation": "A tensor representing a shape",
                  "type": "[tf.Tensor](#class:Tensor) | [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Return the shape of s0 op s1 with broadcast.\n\ncompute r0, the broadcasted shape as a tensor.\ns0, s1 and r0 are all integer vectors.\n\nThis function returns the shape of the result of an operation between\ntwo tensors of size s0 and s1 performed with broadcast.",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/broadcast_args.ts#L41-L60",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.broadcastArgs",
              "urlHash": "broadcastArgs"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "broadcastTo",
              "paramStr": "(x, shape)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "The input is to be broadcast to this shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Broadcast an array to a compatible shape NumPy-style.\n\nThe tensor's shape is compared to the broadcast shape from end to beginning.\nOnes are prepended to the tensor's shape until it has the same length as\nthe broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is\nalready broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then\nthe input tensor is tiled N times along that axis (using tf.tile).",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/broadcast_to.ts#L45-L87",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.broadcastTo",
              "urlHash": "broadcastTo"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "cast",
              "paramStr": "(x, dtype)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be casted.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The dtype to cast the input tensor to.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Casts a [tf.Tensor](#class:Tensor) to a new dtype.\n\n```js\nconst x = tf.tensor1d([1.5, 2.5, 3]);\ntf.cast(x, 'int32').print();\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/cast.ts#L40-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.cast",
              "urlHash": "cast"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "depthToSpace",
              "paramStr": "(x, blockSize, dataFormat?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor of rank 4",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "blockSize",
                  "documentation": "",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "An optional string from: \"NHWC\", \"NCHW\". Defaults to \"NHWC\"",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Rearranges data from depth into blocks of spatial data. More specifically,\nthis op outputs a copy of the input tensor where values from the `depth`\ndimension are moved in spatial blocks to the `height` and `width` dimensions.\nThe attr `blockSize` indicates the input block size and how the data is\nmoved.\n\n  - Chunks of data of size `blockSize * blockSize` from depth are rearranged\ninto non-overlapping blocks of size `blockSize x blockSize`\n\n  - The width the output tensor is `inputWidth * blockSize`, whereas the\nheight is `inputHeight * blockSize`\n\n  - The Y, X coordinates within each block of the output image are determined\nby the high order component of the input channel index\n\n  - The depth of the input tensor must be divisible by `blockSize *\nblockSize`\n\nThe `dataFormat` attr specifies the layout of the input and output tensors\nwith the following options: \"NHWC\": [ `batch, height, width, channels` ]\n\"NCHW\": [ `batch, channels, height, width` ]\n\n```js\nconst x = tf.tensor4d([1, 2, 3, 4], [1, 1, 1, 4]);\nconst blockSize = 2;\nconst dataFormat = \"NHWC\";\n\ntf.depthToSpace(x, blockSize, dataFormat).print();\n```",
              "fileName": "#66",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/depth_to_space.ts#L66-L103",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.depthToSpace",
              "urlHash": "depthToSpace"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "ensureShape",
              "paramStr": "(x, shape)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be ensured.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "A TensorShape representing the shape of this tensor, an array\nor null.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Checks the input tensor mathes the given shape.\n\nGiven an input tensor, returns a new tensor with the same values as the\ninput tensor with shape `shape`.\n\nThe method supports the null value in tensor. It will still check the shapes,\nand null is a placeholder.\n\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst y = tf.tensor1d([1, null, 3, 4]);\nconst z = tf.tensor2d([1, 2, 3, 4], [2,2]);\ntf.ensureShape(x, [4]).print();\ntf.ensureShape(y, [4]).print();\ntf.ensureShape(z, [null, 2]).print();\n```",
              "fileName": "#50",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/ensure_shape.ts#L50-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.ensureShape",
              "urlHash": "ensureShape"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "expandDims",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor whose dimensions are to be expanded.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension index at which to insert shape of `1`. Defaults\nto 0 (the first dimension).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns a [tf.Tensor](#class:Tensor) that has expanded rank, by inserting a dimension\ninto the tensor's shape.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst axis = 1;\nx.expandDims(axis).print();\n```",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/expand_dims.ts#L45-L56",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.expandDims",
              "urlHash": "expandDims"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "mirrorPad",
              "paramStr": "(x, paddings, mode)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to pad.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "paddings",
                  "documentation": "An array of length `R` (the rank of the tensor), where\neach element is a length-2 tuple of ints `[padBefore, padAfter]`,\nspecifying how much to pad along each dimension of the tensor.\nIn \"reflect\" mode, the padded regions do not include the borders,\nwhile in \"symmetric\" mode the padded regions do include the borders.\nFor example, if the input is `[1, 2, 3]` and paddings is `[0, 2]`,\nthen the output is `[1, 2, 3, 2, 1]` in \"reflect\" mode, and\n`[1, 2, 3, 3, 2]` in \"symmetric\" mode.\nIf `mode` is \"reflect\" then both `paddings[D, 0]` and `paddings[D, 1]`\nmust be no greater than `x.shape[D] - 1`. If mode is \"symmetric\"\nthen both `paddings[D, 0]` and `paddings[D, 1]` must be no greater than\n`x.shape[D]`",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mode",
                  "documentation": "String to specify padding mode. Can be `'reflect' | 'symmetric'`",
                  "type": "'reflect'|'symmetric'",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Pads a [tf.Tensor](#class:Tensor) using mirror padding.\n\nThis operation implements the `REFLECT` and `SYMMETRIC` modes of pad.\n\n```js\nconst x = tf.range(0, 9).reshape([1, 1, 3, 3]);\nx.mirrorPad([[0, 0], [0, 0], [2, 2], [2, 2]], 'reflect').print();\n```",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/mirror_pad.ts#L54-L90",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.mirrorPad",
              "urlHash": "mirrorPad"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "pad",
              "paramStr": "(x, paddings, constantValue?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to pad.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "paddings",
                  "documentation": "An array of length `R` (the rank of the tensor), where\neach element is a length-2 tuple of ints `[padBefore, padAfter]`,\nspecifying how much to pad along each dimension of the tensor.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "constantValue",
                  "documentation": "The pad value to use. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Pads a [tf.Tensor](#class:Tensor) with a given value and paddings.\n\nThis operation implements `CONSTANT` mode. For `REFLECT` and `SYMMETRIC`,\nrefer to [tf.mirrorPad()](#mirrorPad).\n\nAlso available are stricter rank-specific methods with the same signature\nas this method that assert that `paddings` is of given length.\n   - `tf.pad1d`\n   - `tf.pad2d`\n   - `tf.pad3d`\n   - `tf.pad4d`\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nx.pad([[1, 2]]).print();\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/pad.ts#L53-L65",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.pad",
              "urlHash": "pad"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "reshape",
              "paramStr": "(x, shape)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be reshaped.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Reshapes a [tf.Tensor](#class:Tensor) to a given shape.\n\nGiven an input tensor, returns a new tensor with the same values as the\ninput tensor with shape `shape`.\n\nIf one component of shape is the special value -1, the size of that\ndimension is computed so that the total size remains constant. In\nparticular, a shape of [-1] flattens into 1-D. At most one component of\nshape can be -1.\n\nIf shape is 1-D or higher, then the operation returns a tensor with shape\nshape filled with the values of tensor. In this case, the number of\nelements implied by shape must be the same as the number of elements in\ntensor.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nx.reshape([2, 2]).print();\n```",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/reshape.ts#L54-L63",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.reshape",
              "urlHash": "reshape"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "setdiff1dAsync",
              "paramStr": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "1-D Tensor. Values to keep.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "y",
                  "documentation": "1-D Tensor. Must have the same type as x. Values to exclude in the\noutput.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[[tf.Tensor](#class:Tensor), [tf.Tensor](#class:Tensor)]>",
              "documentation": "Computes the difference between two lists of numbers.\n\nGiven a Tensor `x` and a Tensor `y`, this operation returns a Tensor `out`\nthat represents all values that are in `x` but not in `y`. The returned\nTensor `out` is sorted in the same order that the numbers appear in `x`\n(duplicates are preserved). This operation also returns a Tensor indices that\nrepresents the position of each out element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., out.length - 1]`\n\n```js\nconst x = [1, 2, 3, 4, 5, 6];\nconst y = [1, 3, 5];\n\nconst [out, indices] = await tf.setdiff1dAsync(x, y);\nout.print(); // [2, 4, 6]\nindices.print(); // [1, 3, 5]\n```",
              "fileName": "#51",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/setdiff1d_async.ts#L51-L88",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.setdiff1dAsync",
              "urlHash": "setdiff1dAsync"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "spaceToBatchND",
              "paramStr": "(x, blockShape, paddings)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A [tf.Tensor](#class:Tensor). N-D with `x.shape` = `[batch] + spatialShape +\nremainingShape`, where spatialShape has `M` dimensions.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "blockShape",
                  "documentation": "A 1-D array. Must have shape `[M]`, all values must\nbe >= 1.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "paddings",
                  "documentation": "A 2-D array. Must have shape `[M, 2]`, all values must be >=\n0. `paddings[i] = [padStart, padEnd]` specifies the amount to zero-pad\nfrom input dimension `i + 1`, which corresponds to spatial dimension `i`. It\nis required that\n`(inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0`\n\nThis operation is equivalent to the following steps:\n\n1. Zero-pad the start and end of dimensions `[1, ..., M]` of the input\naccording to `paddings` to produce `padded` of shape paddedShape.\n\n2. Reshape `padded` to `reshapedPadded` of shape:\n`[batch] + [paddedShape[1] / blockShape[0], blockShape[0], ...,\npaddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape`\n\n3. Permute dimensions of `reshapedPadded` to produce `permutedReshapedPadded`\nof shape: `blockShape + [batch] + [paddedShape[1] / blockShape[0], ...,\npaddedShape[M] / blockShape[M-1]] + remainingShape`\n\n4. Reshape `permutedReshapedPadded` to flatten `blockShape` into the\nbatch dimension, producing an output tensor of shape:\n`[batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ...,\npaddedShape[M] / blockShape[M-1]] + remainingShape`",
                  "type": "number[][]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into\na grid of blocks of shape `blockShape`, and interleaves these blocks with\nthe \"batch\" dimension (0) such that in the output, the spatial\ndimensions `[1, ..., M]` correspond to the position within the grid,\nand the batch dimension combines both the position within a spatial block\nand the original batch position. Prior to division into blocks,\nthe spatial dimensions of the input are optionally zero padded\naccording to `paddings`. See below for a precise description.\n\n```js\nconst x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);\nconst blockShape = [2, 2];\nconst paddings = [[0, 0], [0, 0]];\n\nx.spaceToBatchND(blockShape, paddings).print();\n```",
              "fileName": "#77",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/space_to_batch_nd.ts#L77-L113",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.spaceToBatchND",
              "urlHash": "spaceToBatchND"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Transformations"
              },
              "symbolName": "squeeze",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be squeezed.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "An optional list of numbers. If specified, only\nsqueezes the dimensions listed. The dimension index starts at 0. It\nis an error to squeeze a dimension that is not 1.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Removes dimensions of size 1 from the shape of a [tf.Tensor](#class:Tensor).\n\n```js\nconst x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);\nx.squeeze().print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/squeeze.ts#L41-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.squeeze",
              "urlHash": "squeeze"
            }
          ]
        },
        {
          "name": "Slicing and Joining",
          "description": "<p>TensorFlow.js provides several operations\nto slice or extract parts of a tensor, or join multiple\ntensors together.",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "booleanMaskAsync",
              "paramStr": "(tensor, mask, axis?)",
              "parameters": [
                {
                  "name": "tensor",
                  "documentation": "N-D tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mask",
                  "documentation": "K-D boolean tensor, K <= N and K must be known statically.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "A 0-D int Tensor representing the axis in tensor to mask from.\nBy default, axis is 0 which will mask from the first dimension.\nOtherwise K + axis <= N.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.Tensor](#class:Tensor)>",
              "documentation": "Apply boolean mask to tensor.\n\n```js\nconst tensor = tf.tensor2d([1, 2, 3, 4, 5, 6], [3, 2]);\nconst mask = tf.tensor1d([1, 0, 1], 'bool');\nconst result = await tf.booleanMaskAsync(tensor, mask);\nresult.print();\n```",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/boolean_mask.ts#L46-L88",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.booleanMaskAsync",
              "urlHash": "booleanMaskAsync"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "concat",
              "paramStr": "(tensors, axis?)",
              "parameters": [
                {
                  "name": "tensors",
                  "documentation": "A list of tensors to concatenate.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis to concatenate along. Defaults to 0 (the first dim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Concatenates a list of [tf.Tensor](#class:Tensor)s along a given axis.\n\nThe tensors ranks and types must match, and their sizes must match in all\ndimensions except `axis`.\n\nAlso available are stricter rank-specific methods that assert that\n`tensors` are of the given rank:\n   - `tf.concat1d`\n   - `tf.concat2d`\n   - `tf.concat3d`\n   - `tf.concat4d`\n\nExcept `tf.concat1d` (which does not have axis param), all methods have\nsame signature as this method.\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\na.concat(b).print();  // or a.concat(b)\n```\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\nconst c = tf.tensor1d([5, 6]);\ntf.concat([a, b, c]).print();\n```\n\n```js\nconst a = tf.tensor2d([[1, 2], [10, 20]]);\nconst b = tf.tensor2d([[3, 4], [30, 40]]);\nconst axis = 1;\ntf.concat([a, b], axis).print();\n```",
              "fileName": "#69",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/concat.ts#L69-L94",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.concat",
              "urlHash": "concat"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "gather",
              "paramStr": "(x, indices, axis?, batchDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor whose slices are to be gathered.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": "The indices of the values to extract.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis over which to select values. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "batchDims",
                  "documentation": "Optional. The number of batch dimensions. It must be less\nthan or equal to rank(indices). Defaults to 0.\nThe output tensor will have shape of\n`x.shape[:axis] + indices.shape[batchDims:] + x.shape[axis + 1:]`",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Gather slices from tensor `x`'s axis `axis` according to `indices`.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst indices = tf.tensor1d([1, 3, 3], 'int32');\n\nx.gather(indices).print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\nconst indices = tf.tensor1d([1, 1, 0], 'int32');\n\nx.gather(indices).print();\n```",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/gather.ts#L54-L65",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.gather",
              "urlHash": "gather"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "reverse",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be reversed.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The set of dimensions to reverse. Must be in the\nrange [-rank(x), rank(x)). Defaults to all axes.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Reverses a [tf.Tensor](#class:Tensor) along a specified axis.\n\nAlso available are stricter rank-specific methods that assert that `x` is\nof the given rank:\n   - `tf.reverse1d`\n   - `tf.reverse2d`\n   - `tf.reverse3d`\n   - `tf.reverse4d`\n\nExcept `tf.reverse1d` (which does not have axis param), all methods have\nsame signature as this method.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.reverse().print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.reverse(axis).print();\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/reverse.ts#L59-L69",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.reverse",
              "urlHash": "reverse"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "slice",
              "paramStr": "(x, begin, size?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input [tf.Tensor](#class:Tensor) to slice from.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "begin",
                  "documentation": "The coordinates to start the slice from. The length can be\nless than the rank of x - the rest of the axes will have implicit 0 as\nstart. Can also be a single number, in which case it specifies the\nfirst axis.",
                  "type": "number|number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "The size of the slice. The length can be less than the rank of\nx - the rest of the axes will have implicit -1. A value of -1 requests\nthe rest of the dimensions in the axis. Can also be a single number,\nin which case it specifies the size of the first axis.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Extracts a slice from a [tf.Tensor](#class:Tensor) starting at coordinates `begin`\nand is of size `size`.\n\nAlso available are stricter rank-specific methods with the same signature\nas this method that assert that `x` is of the given rank:\n   - `tf.slice1d`\n   - `tf.slice2d`\n   - `tf.slice3d`\n   - `tf.slice4d`\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.slice([1], [2]).print();\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nx.slice([1, 0], [1, 2]).print();\n```",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/slice.ts#L62-L76",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.slice",
              "urlHash": "slice"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "split",
              "paramStr": "(x, numOrSizeSplits, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to split.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numOrSizeSplits",
                  "documentation": "Either an integer indicating the number of\nsplits along the axis or an array of integers containing the sizes of\neach output tensor along the axis. If a number then it must evenly divide\n`x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.\nCan contain one -1 indicating that dimension is to be inferred.",
                  "type": "number[]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension along which to split. Defaults to 0 (the first\ndim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)[]",
              "documentation": "Splits a [tf.Tensor](#class:Tensor) into sub tensors.\n\nIf `numOrSizeSplits` is a number, splits `x` along dimension `axis`\ninto `numOrSizeSplits` smaller tensors.\nRequires that `numOrSizeSplits` evenly divides `x.shape[axis]`.\n\nIf `numOrSizeSplits` is a number array, splits `x` into\n`numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the\nsame size as `x` except along dimension `axis` where the size is\n`numOrSizeSplits[i]`.\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);\nconst [a, b] = tf.split(x, 2, 1);\na.print();\nb.print();\n\nconst [c, d, e] = tf.split(x, [1, 2, 1], 1);\nc.print();\nd.print();\ne.print();\n```",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/split.ts#L62-L72",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.split",
              "urlHash": "split"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "stack",
              "paramStr": "(tensors, axis?)",
              "parameters": [
                {
                  "name": "tensors",
                  "documentation": "A list of tensor objects with the same shape and dtype.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis to stack along. Defaults to 0 (the first dim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Stacks a list of rank-`R` [tf.Tensor](#class:Tensor)s into one rank-`(R+1)` [tf.Tensor](#class:Tensor).\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\nconst c = tf.tensor1d([5, 6]);\ntf.stack([a, b, c]).print();\n```",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/stack.ts#L44-L63",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.stack",
              "urlHash": "stack"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "tile",
              "paramStr": "(x, reps)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to tile.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "reps",
                  "documentation": "Determines the number of replications per dimension.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Construct a tensor by repeating it the number of times given by reps.\n\nThis operation creates a new tensor by replicating `input` `reps`\ntimes. The output tensor's `i`th dimension has `input.shape[i] *\nreps[i]` elements, and the values of `input` are replicated\n`reps[i]` times along the `i`th dimension. For example, tiling\n`[a, b, c, d]` by `[2]` produces `[a, b, c, d, a, b, c, d]`.\n\n```js\nconst a = tf.tensor1d([1, 2]);\n\na.tile([2]).print();    // or tf.tile(a, [2])\n```\n\n```js\nconst a = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\na.tile([1, 2]).print();  // or tf.tile(a, [1,2])\n```",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tile.ts#L54-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tile",
              "urlHash": "tile"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "unstack",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A tensor object.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis to unstack along. Defaults to 0 (the first dim).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)[]",
              "documentation": "Unstacks a [tf.Tensor](#class:Tensor) of rank-`R` into a list of rank-`(R-1)` [tf.Tensor](#class:Tensor)s.\n\n```js\nconst a = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\ntf.unstack(a).forEach(tensor => tensor.print());\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/unstack.ts#L43-L56",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.unstack",
              "urlHash": "unstack"
            }
          ]
        },
        {
          "name": "Matrices",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Matrices"
              },
              "symbolName": "einsum",
              "paramStr": "(equation, ...tensors)",
              "parameters": [
                {
                  "name": "equation",
                  "documentation": "a string describing the contraction, in the same format as\n[numpy.einsum](https://numpy.org/doc/stable/reference/generated/numpy.einsum.html).",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "...tensors",
                  "documentation": "the input(s) to contract (each one a Tensor), whose shapes\nshould be consistent with equation.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Tensor contraction over specified indices and outer product.\n\n`einsum` allows defining Tensors by defining their element-wise computation.\nThis computation is based on\n[Einstein summation](https://en.wikipedia.org/wiki/Einstein_notation).\n\nSome special cases include:\n\nMatrix multiplication:\n```js\nconst x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\nconst y = tf.tensor2d([[0, 1], [2, 3], [4, 5]]);\nx.print();\ny.print();\ntf.einsum('ij,jk->ik', x, y).print();\n```\n\nDot product:\n```js\nconst x = tf.tensor1d([1, 2, 3]);\nconst y = tf.tensor1d([0, 1, 2]);\nx.print();\ny.print();\ntf.einsum('i,i->', x, y).print();\n```\n\nBatch dot product:\n```js\nconst x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\nconst y = tf.tensor2d([[0, 1, 2], [3, 4, 5]]);\nx.print();\ny.print();\ntf.einsum('bi,bi->b', x, y).print();\n```\n\nOuter prouduct:\n```js\nconst x = tf.tensor1d([1, 3, 5]);\nconst y = tf.tensor1d([2, 4, 6]);\nx.print();\ny.print();\ntf.einsum('i,j->ij', x, y).print();\n```\n\nMatrix transpose:\n```js\nconst x = tf.tensor2d([[1, 2], [3, 4]]);\nx.print();\ntf.einsum('ij->ji', x).print();\n```\n\nBatch matrix transpose:\n```js\nconst x = tf.tensor3d([[[1, 2], [3, 4]], [[-1, -2], [-3, -4]]]);\nx.print();\ntf.einsum('bij->bji', x).print();\n```\n\nLimitations:\n\nThis implementation of einsum has the following limitations:\n\n- Does not support >2 input tensors.\n- Does not support duplicate axes for any given input tensor. E.g., equation\n   'ii->' is not supported.\n- The `...` notation is not supported.",
              "fileName": "#103",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/einsum.ts#L103-L110",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.einsum",
              "urlHash": "einsum"
            }
          ]
        },
        {
          "name": "Random",
          "symbols": [
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "multinomial",
              "paramStr": "(logits, numSamples, seed?, normalized?)",
              "parameters": [
                {
                  "name": "logits",
                  "documentation": "1D array with unnormalized log-probabilities, or\n2D array of shape `[batchSize, numOutcomes]`. See the `normalized`\nparameter.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numSamples",
                  "documentation": "Number of samples to draw for each row slice.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed number.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "normalized",
                  "documentation": "Whether the provided `logits` are normalized true\nprobabilities (sum to 1). Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)|[tf.Tensor2D](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values drawn from a multinomial distribution.\n\n```js\nconst probs = tf.tensor([.75, .25]);\ntf.multinomial(probs, 3).print();\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/multinomial.ts#L49-L81",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.multinomial",
              "urlHash": "multinomial"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "rand",
              "paramStr": "(shape, randFunction, dtype?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "randFunction",
                  "documentation": "A random number generator function which is called\nfor each element in the output tensor.",
                  "type": "() => number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor. Defaults to 'float32'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a random number generator\nfunction defined by the user.",
              "fileName": "#37",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/rand.ts#L37-L56",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.rand",
              "urlHash": "rand"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "randomGamma",
              "paramStr": "(shape, alpha, beta?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "The shape parameter of the gamma distribution.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "beta",
                  "documentation": "The inverse scale parameter of the gamma distribution. Defaults\nto 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output. Defaults to float32.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a gamma distribution.\n\n```js\ntf.randomGamma([2, 2], 1).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/random_gamma.ts#L42-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.randomGamma",
              "urlHash": "randomGamma"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "randomNormal",
              "paramStr": "(shape, mean?, stdDev?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "The mean of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "stdDev",
                  "documentation": "The standard deviation of the normal distribution.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a normal distribution.\n\n```js\ntf.randomNormal([2, 2]).print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/random_normal.ts#L41-L55",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.randomNormal",
              "urlHash": "randomNormal"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "randomStandardNormal",
              "paramStr": "(shape, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output.",
                  "type": "'float32'|'int32'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "The seed for the random number generator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a normal distribution.\n\nThe generated values will have mean 0 and standard deviation 1.\n\n```js\ntf.randomStandardNormal([2, 2]).print();\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/random_standard_normal.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.randomStandardNormal",
              "urlHash": "randomStandardNormal"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "randomUniform",
              "paramStr": "(shape, minval?, maxval?, dtype?, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minval",
                  "documentation": "The lower bound on the range of random values to generate.\nDefaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "maxval",
                  "documentation": "The upper bound on the range of random values to generate.\nDefaults to 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dtype",
                  "documentation": "The data type of the output tensor. Defaults to 'float32'.",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "An optional int. Defaults to 0. If seed is set to be non-zero,\nthe random number generator is seeded by the given seed. Otherwise, it is\nseeded by a random seed.",
                  "type": "number|string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with values sampled from a uniform distribution.\n\nThe generated values follow a uniform distribution in the range [minval,\nmaxval). The lower bound minval is included in the range, while the upper\nbound maxval is excluded.\n\n```js\ntf.randomUniform([2, 2]).print();\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/random_uniform.ts#L49-L59",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.randomUniform",
              "urlHash": "randomUniform"
            },
            {
              "docInfo": {
                "heading": "Tensors",
                "subheading": "Random"
              },
              "symbolName": "randomUniformInt",
              "paramStr": "(shape, minval, maxval, seed?)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "An array of integers defining the output tensor shape.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minval",
                  "documentation": "Inclusive lower bound on the generated integers.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxval",
                  "documentation": "Exclusive upper bound on the generated integers.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "An optional int. Defaults to 0. If seed is set to be non-zero,\nthe random number generator is seeded by the given seed. Otherwise, it is\nseeded by a random seed.",
                  "type": "number|string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) with integers sampled from a uniform distribution.\n\nThe generated values are uniform integers in the range [minval, maxval). The\nlower bound minval is included in the range, while the upper bound maxval is\nexcluded.\n\n```js\ntf.randomUniformInt([2, 2], 0, 10).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/random_uniform_int.ts#L43-L48",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.randomUniformInt",
              "urlHash": "randomUniformInt"
            }
          ]
        }
      ]
    },
    {
      "name": "Models",
      "description": "<p>Models are one of the primary abstractions used in\nTensorFlow.js Layers.  Models can be trained, evaluated, and used\nfor prediction.  A model's state (topology, and optionally, trained\nweights) can be restored from various formats.</p>\n<p>Models are a collection of Layers, see Model Creation for\ndetails about how Layers can be connected.</p>",
      "subheadings": [
        {
          "name": "Creation",
          "description": "<p>There are two primary ways of creating models.</p>\n<ul><li>Sequential &mdash; Easiest, works if the models is a\nsimple stack of each layer's input resting on the top of the\nprevious layer's output.</li>\n<li>Model &mdash; Offers more control if the layers need to be\nwired together in graph-like ways &mdash; multiple 'towers',\nlayers that skip a layer, etc.</li></ul>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Creation"
              },
              "symbolName": "sequential",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "layers",
                  "type": "[tf.layers.Layer](#class:layers.Layer)[]",
                  "documentation": "Stack of layers for the model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "The name of this model.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.Sequential](#class:Sequential)",
              "documentation": "Creates a [tf.Sequential](#class:Sequential) model.  A sequential model is any model where the\noutputs of one layer are the inputs to the next layer, i.e. the model\ntopology is a simple 'stack' of layers, with no branching or skipping.\n\nThis means that the first layer passed to a [tf.Sequential](#class:Sequential) model should have\na defined input shape. What that means is that it should have received an\n`inputShape` or `batchInputShape` argument, or for some type of layers\n(recurrent, Dense...) an `inputDim` argument.\n\nThe key difference between [tf.model()](#model) and [tf.sequential()](#sequential) is that\n[tf.sequential()](#sequential) is less generic, supporting only a linear stack of layers.\n[tf.model()](#model) is more generic and supports an arbitrary graph (without\ncycles) of layers.\n\nExamples:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have an input shape defined.\nmodel.add(tf.layers.dense({units: 32, inputShape: [50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output, which equals\n// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the\n// 2nd is the output size of the model's last layer.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nIt is also possible to specify a batch size (with potentially undetermined\nbatch dimension, denoted by \"null\") for the first layer using the\n`batchInputShape` key. The following example is equivalent to the above:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nYou can also use an `Array` of already-constructed `Layer`s to create\na [tf.Sequential](#class:Sequential) model:\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 32, inputShape: [50]}),\n            tf.layers.dense({units: 4})]\n});\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
              "fileName": "#134",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L134-L136",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sequential",
              "urlHash": "sequential"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Creation"
              },
              "symbolName": "model",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputs",
                  "type": "[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "outputs",
                  "type": "[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.LayersModel](#class:LayersModel)",
              "documentation": "A model is a data structure that consists of `Layers` and defines inputs\nand outputs.\n\nThe key difference between [tf.model()](#model) and [tf.sequential()](#sequential) is that\n[tf.model()](#model) is more generic, supporting an arbitrary graph (without\ncycles) of layers. [tf.sequential()](#sequential) is less generic and supports only a linear\nstack of layers.\n\nWhen creating a [tf.LayersModel](#class:LayersModel), specify its input(s) and output(s). Layers\nare used to wire input(s) to output(s).\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 4, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\nSee also:\n   [tf.sequential()](#sequential), [tf.loadLayersModel()](#loadLayersModel).",
              "fileName": "#70",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L70-L72",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.model",
              "urlHash": "model"
            }
          ]
        },
        {
          "name": "Inputs",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Inputs"
              },
              "symbolName": "input",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "type": "(null | number)[]",
                  "documentation": "A shape, not including the batch size. For instance, `shape=[32]`\nindicates that the expected input will be batches of 32-dimensional\nvectors.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchShape",
                  "type": "(null | number)[]",
                  "documentation": "A shape tuple (integer), including the batch size. For instance,\n`batchShape=[10, 32]` indicates that the expected input will be batches of\n10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\narbitrary number of 32-dimensional vectors.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "An optional name string for the layer. Should be unique in a model (do not\nreuse the same name twice). It will be autogenerated if it isn't provided.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "sparse",
                  "type": "boolean",
                  "documentation": "A boolean specifying whether the placeholder to be created is sparse.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.SymbolicTensor](#class:SymbolicTensor)",
              "documentation": "Used to instantiate an input to a model as a [tf.SymbolicTensor](#class:SymbolicTensor).\n\nUsers should call the `input` factory function for\nconsistency with other generator functions.\n\nExample:\n\n```js\n// Defines a simple logistic regression model with 32 dimensional input\n// and 3 dimensional output.\nconst x = tf.input({shape: [32]});\nconst y = tf.layers.dense({units: 3, activation: 'softmax'}).apply(x);\nconst model = tf.model({inputs: x, outputs: y});\nmodel.predict(tf.ones([2, 32])).print();\n```\n\nNote: `input` is only necessary when using `model`. When using\n`sequential`, specify `inputShape` for the first layer or use `inputLayer`\nas the first layer.",
              "fileName": "#161",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L161-L163",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.input",
              "urlHash": "input"
            }
          ]
        },
        {
          "name": "Loading",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading"
              },
              "symbolName": "loadGraphModel",
              "paramStr": "(modelUrl, options?, tfio?)",
              "parameters": [
                {
                  "name": "modelUrl",
                  "documentation": "The url or an `io.IOHandler` that loads the model.",
                  "type": "string|io.IOHandler",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "options",
                  "documentation": "Options for the HTTP request, which allows to send\ncredentials\nand custom headers.",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "requestInit",
                  "type": "RequestInit",
                  "documentation": "RequestInit (options) for HTTP requests.\n\nFor detailed information on the supported fields, see\n[https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](\n     https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "onProgress",
                  "type": "OnProgressCallback",
                  "documentation": "Progress callback.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "fetchFunc",
                  "type": "Function",
                  "documentation": "A function used to override the `window.fetch` function.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strict",
                  "type": "boolean",
                  "documentation": "Strict loading model: whether extraneous weights or missing\nweights should trigger an `Error`.\n\nIf `true`, require that the provided weights exactly match those\nrequired by the layers. `false` means that both extra weights\nand missing weights will be silently ignored.\n\nDefault: `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weightPathPrefix",
                  "type": "string",
                  "documentation": "Path prefix for weight files, by default this is calculated from the\npath of the model JSON file.\n\nFor instance, if the path to the model JSON file is\n`http://localhost/foo/model.json`, then the default path prefix will be\n`http://localhost/foo/`. If a weight file has the path value\n`group1-shard1of2` in the weight manifest, then the weight file will be\nloaded from `http://localhost/foo/group1-shard1of2` by default. However,\nif you provide a `weightPathPrefix` value of\n`http://localhost/foo/alt-weights`, then the weight file will be loaded\nfrom the path `http://localhost/foo/alt-weights/group1-shard1of2` instead.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "fromTFHub",
                  "type": "boolean",
                  "documentation": "Whether the module or model is to be loaded from TF Hub.\n\nSetting this to `true` allows passing a TF-Hub module URL, omitting the\nstandard model file name and the query parameters.\n\nDefault: `false`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weightUrlConverter",
                  "type": "(weightFileName: string) => Promise<string>",
                  "documentation": "An async function to convert weight file name to URL. The weight file\nnames are stored in model.json's weightsManifest.paths field. By default we\nconsider weight files are colocated with the model.json file. For example:\n     model.json URL: https://www.google.com/models/1/model.json\n     group1-shard1of1.bin url:\n        https://www.google.com/models/1/group1-shard1of1.bin\n\nWith this func you can convert the weight file name to any URL.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "tfio",
                  "documentation": "",
                  "type": "typeof import(\"@tensorflow/tfjs-core/dist/io/io\")",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.GraphModel](#class:GraphModel)>",
              "documentation": "Load a graph model given a URL to the model definition.\n\nExample of loading MobileNetV2 from a URL and making a prediction with a\nzeros input:\n\n```js\nconst modelUrl =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';\nconst model = await tf.loadGraphModel(modelUrl);\nconst zeros = tf.zeros([1, 224, 224, 3]);\nmodel.predict(zeros).print();\n```\n\nExample of loading MobileNetV2 from a TF Hub URL and making a prediction\nwith a zeros input:\n\n```js\nconst modelUrl =\n    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';\nconst model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});\nconst zeros = tf.zeros([1, 224, 224, 3]);\nmodel.predict(zeros).print();\n```",
              "fileName": "#600",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L600-L618",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.loadGraphModel",
              "urlHash": "loadGraphModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading"
              },
              "symbolName": "loadLayersModel",
              "paramStr": "(pathOrIOHandler, options?)",
              "parameters": [
                {
                  "name": "pathOrIOHandler",
                  "documentation": "Can be either of the two formats\n1. A string path to the `ModelAndWeightsConfig` JSON describing\nthe model in the canonical TensorFlow.js format. For file://\n(tfjs-node-only), http:// and https:// schemas, the path can be\neither absolute or relative. The content of the JSON file is assumed to\nbe a JSON object with the following fields and values:\n- 'modelTopology': A JSON object that can be either of:\n1. a model architecture JSON consistent with the format of the return\nvalue of `keras.Model.to_json()`\n2. a full model JSON in the format of `keras.models.save_model()`.\n- 'weightsManifest': A TensorFlow.js weights manifest.\nSee the Python converter function `save_model()` for more details.\nIt is also assumed that model weights can be accessed from relative\npaths described by the `paths` fields in weights manifest.\n2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\nmethod.",
                  "type": "string|io.IOHandler",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "options",
                  "documentation": "Optional configuration arguments for the model loading,\nincluding:\n- `strict`: Require that the provided weights exactly match those required\nby the layers.  Default true.  Passing false means that both extra\nweights and missing weights will be silently ignored.\n- `onProgress`: A progress callback of the form:\n`(fraction: number) => void`. This callback can be used to monitor the\nmodel-loading process.",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "requestInit",
                  "type": "RequestInit",
                  "documentation": "RequestInit (options) for HTTP requests.\n\nFor detailed information on the supported fields, see\n[https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](\n     https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "onProgress",
                  "type": "OnProgressCallback",
                  "documentation": "Progress callback.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "fetchFunc",
                  "type": "Function",
                  "documentation": "A function used to override the `window.fetch` function.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strict",
                  "type": "boolean",
                  "documentation": "Strict loading model: whether extraneous weights or missing\nweights should trigger an `Error`.\n\nIf `true`, require that the provided weights exactly match those\nrequired by the layers. `false` means that both extra weights\nand missing weights will be silently ignored.\n\nDefault: `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weightPathPrefix",
                  "type": "string",
                  "documentation": "Path prefix for weight files, by default this is calculated from the\npath of the model JSON file.\n\nFor instance, if the path to the model JSON file is\n`http://localhost/foo/model.json`, then the default path prefix will be\n`http://localhost/foo/`. If a weight file has the path value\n`group1-shard1of2` in the weight manifest, then the weight file will be\nloaded from `http://localhost/foo/group1-shard1of2` by default. However,\nif you provide a `weightPathPrefix` value of\n`http://localhost/foo/alt-weights`, then the weight file will be loaded\nfrom the path `http://localhost/foo/alt-weights/group1-shard1of2` instead.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "fromTFHub",
                  "type": "boolean",
                  "documentation": "Whether the module or model is to be loaded from TF Hub.\n\nSetting this to `true` allows passing a TF-Hub module URL, omitting the\nstandard model file name and the query parameters.\n\nDefault: `false`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weightUrlConverter",
                  "type": "(weightFileName: string) => Promise<string>",
                  "documentation": "An async function to convert weight file name to URL. The weight file\nnames are stored in model.json's weightsManifest.paths field. By default we\nconsider weight files are colocated with the model.json file. For example:\n     model.json URL: https://www.google.com/models/1/model.json\n     group1-shard1of1.bin url:\n        https://www.google.com/models/1/group1-shard1of1.bin\n\nWith this func you can convert the weight file name to any URL.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Promise<[tf.LayersModel](#class:LayersModel)>",
              "documentation": "Load a model composed of Layer objects, including its topology and optionally\nweights. See the Tutorial named \"How to import a Keras Model\" for usage\nexamples.\n\nThis method is applicable to:\n\n1. Models created with the `tf.layers.*`, [tf.sequential()](#sequential), and\n[tf.model()](#model) APIs of TensorFlow.js and later saved with the\n[tf.LayersModel.save()](#tf.LayersModel.save) method.\n2. Models converted from Keras or TensorFlow tf.keras using the\n[tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n\nThis mode is *not* applicable to TensorFlow `SavedModel`s or their converted\nforms. For those models, use [tf.loadGraphModel()](#loadGraphModel).\n\nExample 1. Load a model from an HTTP server.\n\n```js\nconst model = await tf.loadLayersModel(\n     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\nmodel.summary();\n```\n\nExample 2: Save `model`'s topology and weights to browser [local\nstorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('localstorage://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 3. Saving `model`'s topology and weights to browser\n[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('indexeddb://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 4. Load a model from user-selected files from HTML\n[file input\nelements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n\n```js\n// Note: this code snippet will not work without the HTML elements in the\n//   page\nconst jsonUpload = document.getElementById('json-upload');\nconst weightsUpload = document.getElementById('weights-upload');\n\nconst model = await tf.loadLayersModel(\n     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n```",
              "fileName": "#248",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L248-L270",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.loadLayersModel",
              "urlHash": "loadLayersModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "browserDownloads",
              "namespace": "io",
              "paramStr": "(fileNamePrefix?)",
              "parameters": [
                {
                  "name": "fileNamePrefix",
                  "documentation": "Prefix name of the files to be downloaded. For use with\n`tf.Model`, `fileNamePrefix` should follow either of the following two\nformats:\n1. `null` or `undefined`, in which case the default file\nnames will be used:\n- 'model.json' for the JSON file containing the model topology and\nweights manifest.\n- 'model.weights.bin' for the binary file containing the binary weight\nvalues.\n2. A single string or an Array of a single string, as the file name prefix.\nFor example, if `'foo'` is provided, the downloaded JSON\nfile and binary weights file will be named 'foo.json' and\n'foo.weights.bin', respectively.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "IOHandler",
              "documentation": "Creates an IOHandler that triggers file downloads from the browser.\n\nThe returned `IOHandler` instance can be used as model exporting methods such\nas `tf.Model.save` and supports only saving.\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.dense(\n     {units: 1, inputShape: [10], activation: 'sigmoid'}));\nconst saveResult = await model.save('downloads://mymodel');\n// This will trigger downloading of two files:\n//   'mymodel.json' and 'mymodel.weights.bin'.\nconsole.log(saveResult);\n```",
              "fileName": "#299",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/browser_files.ts#L299-L301",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.browserDownloads",
              "urlHash": "io.browserDownloads"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "browserFiles",
              "namespace": "io",
              "paramStr": "(files)",
              "parameters": [
                {
                  "name": "files",
                  "documentation": "`File`s to load from. Currently, this function supports only\nloading from files that contain Keras-style models (i.e., `tf.Model`s), for\nwhich an `Array` of `File`s is expected (in that order):\n- A JSON file containing the model topology and weight manifest.\n- Optionally, one or more binary files containing the binary weights.\nThese files must have names that match the paths in the `weightsManifest`\ncontained by the aforementioned JSON file, or errors will be thrown\nduring loading. These weights files have the same format as the ones\ngenerated by `tensorflowjs_converter` that comes with the `tensorflowjs`\nPython PIP package. If no weights files are provided, only the model\ntopology will be loaded from the JSON file above.",
                  "type": "File[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "IOHandler",
              "documentation": "Creates an IOHandler that loads model artifacts from user-selected files.\n\nThis method can be used for loading from files such as user-selected files\nin the browser.\nWhen used in conjunction with [tf.loadLayersModel()](#loadLayersModel), an instance of\n[tf.LayersModel](#class:LayersModel) (Keras-style) can be constructed from the loaded artifacts.\n\n```js\n// Note: This code snippet won't run properly without the actual file input\n//   elements in the HTML DOM.\n\n// Suppose there are two HTML file input (`<input type=\"file\" ...>`)\n// elements.\nconst uploadJSONInput = document.getElementById('upload-json');\nconst uploadWeightsInput = document.getElementById('upload-weights');\nconst model = await tf.loadLayersModel(tf.io.browserFiles(\n     [uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n```",
              "fileName": "#343",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/browser_files.ts#L343-L345",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.browserFiles",
              "urlHash": "io.browserFiles"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "http",
              "namespace": "io",
              "paramStr": "(path, loadOptions?)",
              "parameters": [
                {
                  "name": "path",
                  "documentation": "A URL path to the model.\nCan be an absolute HTTP path (e.g.,\n'http://localhost:8000/model-upload)') or a relative path (e.g.,\n'./model-upload').",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "loadOptions",
                  "documentation": "Optional configuration for the loading. It includes the\nfollowing fields:\n- weightPathPrefix Optional, this specifies the path prefix for weight\nfiles, by default this is calculated from the path param.\n- fetchFunc Optional, custom `fetch` function. E.g., in Node.js,\nthe `fetch` from node-fetch can be used here.\n- onProgress Optional, progress callback function, fired periodically\nbefore the load is completed.",
                  "type": "LoadOptions",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "IOHandler",
              "documentation": "Creates an IOHandler subtype that sends model artifacts to HTTP server.\n\nAn HTTP request of the `multipart/form-data` mime type will be sent to the\n`path` URL. The form data includes artifacts that represent the topology\nand/or weights of the model. In the case of Keras-style `tf.Model`, two\nblobs (files) exist in form-data:\n   - A JSON file consisting of `modelTopology` and `weightsManifest`.\n   - A binary weights file consisting of the concatenated weight values.\nThese files are in the same format as the one generated by\n[tfjs_converter](https://js.tensorflow.org/tutorials/import-keras.html).\n\nThe following code snippet exemplifies the client-side code that uses this\nfunction:\n\n```js\nconst model = tf.sequential();\nmodel.add(\n     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n\nconst saveResult = await model.save(tf.io.http(\n     'http://model-server:5000/upload', {requestInit: {method: 'PUT'}}));\nconsole.log(saveResult);\n```\n\nIf the default `POST` method is to be used, without any custom parameters\nsuch as headers, you can simply pass an HTTP or HTTPS URL to `model.save`:\n\n```js\nconst saveResult = await model.save('http://model-server:5000/upload');\n```\n\nThe following GitHub Gist\nhttps://gist.github.com/dsmilkov/1b6046fd6132d7408d5257b0976f7864\nimplements a server based on [flask](https://github.com/pallets/flask) that\ncan receive the request. Upon receiving the model artifacts via the requst,\nthis particular server reconstitutes instances of [Keras\nModels](https://keras.io/models/model/) in memory.",
              "fileName": "#340",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/http.ts#L340-L342",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.http",
              "urlHash": "io.http"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Loading"
              },
              "symbolName": "loadGraphModelSync",
              "paramStr": "(modelSource)",
              "parameters": [
                {
                  "name": "modelSource",
                  "documentation": "The `io.IOHandlerSync` that loads the model, or the\n`io.ModelArtifacts` that encode the model, or a tuple of\n`[io.ModelJSON, ArrayBuffer]` of which the first element encodes the\nmodel and the second contains the weights.",
                  "type": "io.IOHandlerSync|\n    io.ModelArtifacts|[io.ModelJSON, /* Weights */ ArrayBuffer]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.GraphModel](#class:GraphModel)",
              "documentation": "Load a graph model given a synchronous IO handler with a 'load' method.",
              "fileName": "#630",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L630-L677",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.loadGraphModelSync",
              "urlHash": "loadGraphModelSync"
            }
          ]
        },
        {
          "name": "Management",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Management",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "copyModel",
              "namespace": "io",
              "paramStr": "(sourceURL, destURL)",
              "parameters": [
                {
                  "name": "sourceURL",
                  "documentation": "Source URL of copying.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "destURL",
                  "documentation": "Destination URL of copying.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<ModelArtifactsInfo>",
              "documentation": "Copy a model from one URL to another.\n\nThis function supports:\n\n1. Copying within a storage medium, e.g.,\n    `tf.io.copyModel('localstorage://model-1', 'localstorage://model-2')`\n2. Copying between two storage mediums, e.g.,\n    `tf.io.copyModel('localstorage://model-1', 'indexeddb://model-1')`\n\n```js\n// First create and save a model.\nconst model = tf.sequential();\nmodel.add(tf.layers.dense(\n     {units: 1, inputShape: [10], activation: 'sigmoid'}));\nawait model.save('localstorage://demo/management/model1');\n\n// Then list existing models.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Copy the model, from Local Storage to IndexedDB.\nawait tf.io.copyModel(\n     'localstorage://demo/management/model1',\n     'indexeddb://demo/management/model1');\n\n// List models again.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Remove both models.\nawait tf.io.removeModel('localstorage://demo/management/model1');\nawait tf.io.removeModel('indexeddb://demo/management/model1');\n```",
              "fileName": "#298",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/model_management.ts#L298-L302",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.copyModel",
              "urlHash": "io.copyModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Management",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "listModels",
              "namespace": "io",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Promise<{[url: string]: ModelArtifactsInfo}>",
              "documentation": "List all models stored in registered storage mediums.\n\nFor a web browser environment, the registered mediums are Local Storage and\nIndexedDB.\n\n```js\n// First create and save a model.\nconst model = tf.sequential();\nmodel.add(tf.layers.dense(\n     {units: 1, inputShape: [10], activation: 'sigmoid'}));\nawait model.save('localstorage://demo/management/model1');\n\n// Then list existing models.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Delete the model.\nawait tf.io.removeModel('localstorage://demo/management/model1');\n\n// List models again.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n```",
              "fileName": "#198",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/model_management.ts#L198-L210",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.listModels",
              "urlHash": "io.listModels"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Management",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "moveModel",
              "namespace": "io",
              "paramStr": "(sourceURL, destURL)",
              "parameters": [
                {
                  "name": "sourceURL",
                  "documentation": "Source URL of moving.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "destURL",
                  "documentation": "Destination URL of moving.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<ModelArtifactsInfo>",
              "documentation": "Move a model from one URL to another.\n\nThis function supports:\n\n1. Moving within a storage medium, e.g.,\n    `tf.io.moveModel('localstorage://model-1', 'localstorage://model-2')`\n2. Moving between two storage mediums, e.g.,\n    `tf.io.moveModel('localstorage://model-1', 'indexeddb://model-1')`\n\n```js\n// First create and save a model.\nconst model = tf.sequential();\nmodel.add(tf.layers.dense(\n     {units: 1, inputShape: [10], activation: 'sigmoid'}));\nawait model.save('localstorage://demo/management/model1');\n\n// Then list existing models.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Move the model, from Local Storage to IndexedDB.\nawait tf.io.moveModel(\n     'localstorage://demo/management/model1',\n     'indexeddb://demo/management/model1');\n\n// List models again.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Remove the moved model.\nawait tf.io.removeModel('indexeddb://demo/management/model1');\n```",
              "fileName": "#350",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/model_management.ts#L350-L354",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.moveModel",
              "urlHash": "io.moveModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Management",
                "namespace": "io",
                "ignoreCI": true
              },
              "symbolName": "removeModel",
              "namespace": "io",
              "paramStr": "(url)",
              "parameters": [
                {
                  "name": "url",
                  "documentation": "A URL to a stored model, with a scheme prefix, e.g.,\n'localstorage://my-model-1', 'indexeddb://my/model/2'.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<ModelArtifactsInfo>",
              "documentation": "Remove a model specified by URL from a registered storage medium.\n\n```js\n// First create and save a model.\nconst model = tf.sequential();\nmodel.add(tf.layers.dense(\n     {units: 1, inputShape: [10], activation: 'sigmoid'}));\nawait model.save('localstorage://demo/management/model1');\n\n// Then list existing models.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n\n// Delete the model.\nawait tf.io.removeModel('localstorage://demo/management/model1');\n\n// List models again.\nconsole.log(JSON.stringify(await tf.io.listModels()));\n```",
              "fileName": "#245",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/io/model_management.ts#L245-L249",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.io.removeModel",
              "urlHash": "io.removeModel"
            }
          ]
        },
        {
          "name": "Serialization",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Serialization",
                "ignoreCI": true
              },
              "symbolName": "registerClass",
              "paramStr": "(cls)",
              "parameters": [
                {
                  "name": "cls",
                  "documentation": "The class to be registered. It must have a public static member\ncalled `className` defined and the value must be a non-empty string.",
                  "type": "SerializableConstructor",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Register a class with the serialization map of TensorFlow.js.\n\nThis is often used for registering custom Layers, so they can be\nserialized and deserialized.\n\nExample:\n\n```js\nclass MyCustomLayer extends tf.layers.Layer {\n   static className = 'MyCustomLayer';\n\n   constructor(config) {\n     super(config);\n   }\n}\ntf.serialization.registerClass(MyCustomLayer);\n```",
              "fileName": "#161",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/serialization.ts#L161-L177",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.registerClass",
              "urlHash": "registerClass"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "Functional",
              "documentation": "A [tf.Functional](#class:Functional) is an alias to [tf.LayersModel](#class:LayersModel).\n\nSee also:\n   [tf.LayersModel](#class:LayersModel), [tf.Sequential](#class:Sequential), [tf.loadLayersModel()](#loadLayersModel).",
              "fileName": "#2205",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L2205-L2207",
              "methods": [],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "[tf.LayersModel](#class:LayersModel)",
              "displayName": "tf.Functional",
              "urlHash": "class:Functional"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "GraphModel",
              "documentation": "A [tf.GraphModel](#class:GraphModel) is a directed, acyclic graph built from a\nSavedModel GraphDef and allows inference execution.\n\nA [tf.GraphModel](#class:GraphModel) can only be created by loading from a model converted from\na [TensorFlow SavedModel](https://www.tensorflow.org/guide/saved_model) using\nthe command line converter tool and loaded via [tf.loadGraphModel()](#loadGraphModel).",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L42-L567",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "ignoreCI": true
                  },
                  "symbolName": "loadSync",
                  "paramStr": "(artifacts)",
                  "parameters": [
                    {
                      "name": "artifacts",
                      "documentation": "",
                      "type": "io.ModelArtifacts",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "boolean",
                  "documentation": "Synchronously construct the in memory weight map and\ncompile the inference graph.",
                  "fileName": "#169",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L169-L210",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.loadSync"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "ignoreCI": true
                  },
                  "symbolName": "save",
                  "paramStr": "(handlerOrURL, config?)",
                  "parameters": [
                    {
                      "name": "handlerOrURL",
                      "documentation": "An instance of `IOHandler` or a URL-like,\nscheme-based string shortcut for `IOHandler`.",
                      "type": "io.IOHandler|string",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "Options for saving the model.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "trainableOnly",
                      "type": "boolean",
                      "documentation": "Whether to save only the trainable weights of the model, ignoring the\nnon-trainable ones.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "includeOptimizer",
                      "type": "boolean",
                      "documentation": "Whether the optimizer will be saved (if exists).\n\nDefault: `false`.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<io.SaveResult>",
                  "documentation": "Save the configuration and/or weights of the GraphModel.\n\nAn `IOHandler` is an object that has a `save` method of the proper\nsignature defined. The `save` method manages the storing or\ntransmission of serialized data (\"artifacts\") that represent the\nmodel's topology and weights onto or via a specific medium, such as\nfile downloads, local storage, IndexedDB in the web browser and HTTP\nrequests to a server. TensorFlow.js provides `IOHandler`\nimplementations for a number of frequently used saving mediums, such as\n[tf.io.browserDownloads()](#io.browserDownloads) and `tf.io.browserLocalStorage`. See `tf.io`\nfor more details.\n\nThis method also allows you to refer to certain types of `IOHandler`s\nas URL-like string shortcuts, such as 'localstorage://' and\n'indexeddb://'.\n\nExample 1: Save `model`'s topology and weights to browser [local\nstorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\nthen load it back.\n\n```js\nconst modelUrl =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';\nconst model = await tf.loadGraphModel(modelUrl);\nconst zeros = tf.zeros([1, 224, 224, 3]);\nmodel.predict(zeros).print();\n\nconst saveResults = await model.save('localstorage://my-model-1');\n\nconst loadedModel = await tf.loadGraphModel('localstorage://my-model-1');\nconsole.log('Prediction from loaded model:');\nmodel.predict(zeros).print();\n```",
                  "fileName": "#256",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L256-L277",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.save"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "predict",
                  "paramStr": "(inputs, config?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "Prediction configuration for specifying the batch size.\nCurrently the batch size option is ignored for graph model.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "type": "number",
                      "documentation": "Optional. Batch size (Integer). If unspecified, it will default to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "boolean",
                      "documentation": "Optional. Verbosity mode. Defaults to false.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}",
                  "documentation": "Execute the inference for the input tensors.",
                  "fileName": "#333",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L333-L337",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.predict"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "predictAsync",
                  "paramStr": "(inputs, config?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "Prediction configuration for specifying the batch size.\nCurrently the batch size option is ignored for graph model.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "type": "number",
                      "documentation": "Optional. Batch size (Integer). If unspecified, it will default to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "boolean",
                      "documentation": "Optional. Verbosity mode. Defaults to false.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}>",
                  "documentation": "Execute the inference for the input tensors in async fashion, use this\nmethod when your model contains control flow ops.",
                  "fileName": "#379",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L379-L384",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.predictAsync"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "execute",
                  "paramStr": "(inputs, outputs?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "tensor, tensor array or tensor map of the inputs for the\nmodel, keyed by the input node names.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "outputs",
                      "documentation": "output node name from the TensorFlow model, if no\noutputs are specified, the default outputs of the model would be used.\nYou can inspect intermediate nodes of the model by adding them to the\noutputs array.",
                      "type": "string|string[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Executes inference for the model for given input tensors.",
                  "fileName": "#483",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L483-L492",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.execute"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "executeAsync",
                  "paramStr": "(inputs, outputs?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "tensor, tensor array or tensor map of the inputs for the\nmodel, keyed by the input node names.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[name: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "outputs",
                      "documentation": "output node name from the TensorFlow model, if no outputs\nare specified, the default outputs of the model would be used. You can\ninspect intermediate nodes of the model by adding them to the outputs\narray.",
                      "type": "string|string[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "Promise<[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]>",
                  "documentation": "Executes inference for the model for given input tensors in async\nfashion, use this method when your model contains control flow ops.",
                  "fileName": "#510",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L510-L521",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.executeAsync"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "getIntermediateTensors",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "NamedTensorsMap",
                  "documentation": "Get intermediate tensors for model debugging mode (flag\nKEEP_INTERMEDIATE_TENSORS is true).",
                  "fileName": "#529",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L529-L531",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.getIntermediateTensors"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "disposeIntermediateTensors",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "void",
                  "documentation": "Dispose intermediate tensors for model debugging mode (flag\nKEEP_INTERMEDIATE_TENSORS is true).",
                  "fileName": "#539",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L539-L541",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.disposeIntermediateTensors"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "dispose",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "void",
                  "documentation": "Releases the memory used by the weight tensors and resourceManager.",
                  "fileName": "#555",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/executor/graph_model.ts#L555-L566",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.GraphModel.dispose"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "InferenceModel",
              "displayName": "tf.GraphModel",
              "urlHash": "class:GraphModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "LayersModel",
              "documentation": "A [tf.LayersModel](#class:LayersModel) is a directed, acyclic graph of `tf.Layer`s plus methods\nfor training, evaluation, prediction and saving.\n\n[tf.LayersModel](#class:LayersModel) is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a [tf.LayersModel](#class:LayersModel), use [tf.LayersModel](#class:LayersModel).\n\nSee also:\n   [tf.Sequential](#class:Sequential), [tf.loadLayersModel()](#loadLayersModel).",
              "fileName": "#475",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L475-L2195",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "summary",
                  "paramStr": "(lineLength?, positions?, printFn?)",
                  "parameters": [
                    {
                      "name": "lineLength",
                      "documentation": "Custom line length, in number of characters.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "positions",
                      "documentation": "Custom widths of each of the columns, as either\nfractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\nof characters (e.g., `[30, 50, 65]`). Each number corresponds to\nright-most (i.e., ending) position of a column.",
                      "type": "number[]",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "printFn",
                      "documentation": "Custom print function. Can be used to replace the default\n`console.log`. For example, you can use `x => {}` to mute the printed\nmessages in the console.",
                      "type": "(message?: [tf.any()](#any), ...optionalParams: [tf.any()](#any)[]) => void",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Print a text summary of the model's layers.\n\nThe summary includes\n- Name and type of all layers that comprise the model.\n- Output shape(s) of the layers\n- Number of weight parameters of each layer\n- If the model has non-sequential-like topology, the inputs each layer\n   receives\n- The total number of trainable and non-trainable parameters of the model.\n\n```js\nconst input1 = tf.input({shape: [10]});\nconst input2 = tf.input({shape: [20]});\nconst dense1 = tf.layers.dense({units: 4}).apply(input1);\nconst dense2 = tf.layers.dense({units: 8}).apply(input2);\nconst concat = tf.layers.concatenate().apply([dense1, dense2]);\nconst output =\n     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);\n\nconst model = tf.model({inputs: [input1, input2], outputs: output});\nmodel.summary();\n```",
                  "fileName": "#559",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L559-L571",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.summary"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "compile",
                  "paramStr": "(args)",
                  "parameters": [
                    {
                      "name": "args",
                      "documentation": "a `ModelCompileArgs` specifying the loss, optimizer, and\nmetrics to be used for fitting and evaluating this model.",
                      "type": "Object",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "optimizer",
                      "type": "string|[tf.train.Optimizer](#class:train.Optimizer)",
                      "documentation": "An instance of [tf.train.Optimizer](#class:train.Optimizer) or a string name for an Optimizer.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "loss",
                      "type": "string|string[]|{[outputName: string]: string}|LossOrMetricFn|\n      LossOrMetricFn[]|{[outputName: string]: LossOrMetricFn}",
                      "documentation": "Object function(s) or name(s) of object function(s).\nIf the model has multiple outputs, you can use a different loss\non each output by passing a dictionary or an Array of losses.\nThe loss value that will be minimized by the model will then be the sum\nof all individual losses.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "metrics",
                      "type": "string|LossOrMetricFn|Array|\n      {[outputName: string]: string | LossOrMetricFn}",
                      "documentation": "List of metrics to be evaluated by the model during training and testing.\nTypically you will use `metrics=['accuracy']`.\nTo specify different metrics for different outputs of a multi-output\nmodel, you could also pass a dictionary.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Configures and prepares the model for training and evaluation.  Compiling\noutfits the model with an optimizer, loss, and/or metrics.  Calling `fit`\nor `evaluate` on an un-compiled model will throw an error.",
                  "fileName": "#583",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L583-L785",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.compile"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "evaluate",
                  "paramStr": "(x, y, args?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of test data, or an `Array` of [tf.Tensor](#class:Tensor)s if the\nmodel has multiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target data, or an `Array` of [tf.Tensor](#class:Tensor)s if the\nmodel has multiple outputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "args",
                      "documentation": "A `ModelEvaluateArgs`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "type": "number",
                      "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "ModelLoggingVerbosity",
                      "documentation": "Verbosity mode.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "documentation": "Tensor of weights to weight the contribution of different samples to the\nloss and metrics.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "steps",
                      "type": "number",
                      "documentation": "integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Scalar](#class:Tensor)|[tf.Scalar](#class:Tensor)[]",
                  "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nconst result = model.evaluate(\n     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});\nresult.print();\n```",
                  "fileName": "#840",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L840-L864",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.evaluate"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "evaluateDataset",
                  "paramStr": "(dataset, args?)",
                  "parameters": [
                    {
                      "name": "dataset",
                      "documentation": "A dataset object. Its `iterator()` method is expected\nto generate a dataset iterator object, the `next()` method of which\nis expected to produce data batches for evaluation. The return value\nof the `next()` call ought to contain a boolean `done` field and a\n`value` field. The `value` field is expected to be an array of two\n[tf.Tensor](#class:Tensor)s or an array of two nested [tf.Tensor](#class:Tensor) structures. The former\ncase is for models with exactly one input and one output (e.g.\na sequential model). The latter case is for models with multiple\ninputs and/or multiple outputs. Of the two items in the array, the\nfirst is the input feature(s) and the second is the output target(s).",
                      "type": "[tf.data.Dataset](#class:data.Dataset)",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "args",
                      "documentation": "A configuration object for the dataset-based evaluation.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batches",
                      "type": "number",
                      "documentation": "Number of batches to draw from the dataset object before ending the\nevaluation.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "ModelLoggingVerbosity",
                      "documentation": "Verbosity mode.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<[tf.Scalar](#class:Tensor)|[tf.Scalar](#class:Tensor)[]>",
                  "documentation": "Evaluate model using a dataset object.\n\nNote: Unlike `evaluate()`, this method is asynchronous (`async`).",
                  "fileName": "#888",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L888-L892",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.evaluateDataset"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "predict",
                  "paramStr": "(x, args?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "The input data, as a Tensor, or an `Array` of [tf.Tensor](#class:Tensor)s if\nthe model has multiple inputs.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "args",
                      "documentation": "A `ModelPredictArgs` object containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "type": "number",
                      "documentation": "Optional. Batch size (Integer). If unspecified, it will default to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "boolean",
                      "documentation": "Optional. Verbosity mode. Defaults to false.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nNote: the \"step\" mode of predict() is currently not supported.\n   This is because the TensorFlow.js core backend is imperative only.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predict(tf.ones([8, 10]), {batchSize: 4}).print();\n```",
                  "fileName": "#1105",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1105-L1120",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.predict"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "predictOnBatch",
                  "paramStr": "(x)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": ": Input samples, as a Tensor (for models with exactly one\ninput) or an array of Tensors (for models with more than one input).",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Returns predictions for a single batch of samples.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predictOnBatch(tf.ones([8, 10])).print();\n```",
                  "fileName": "#1137",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1137-L1143",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.predictOnBatch"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "fit",
                  "paramStr": "(x, y, args?)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "[tf.Tensor](#class:Tensor) of training data, or an array of [tf.Tensor](#class:Tensor)s if the\nmodel has multiple inputs. If all inputs in the model are named, you\ncan also pass a dictionary mapping input names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "[tf.Tensor](#class:Tensor) of target (label) data, or an array of [tf.Tensor](#class:Tensor)s if\nthe model has multiple outputs. If all outputs in the model are named,\nyou can also pass a dictionary mapping output names to [tf.Tensor](#class:Tensor)s.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "args",
                      "documentation": "A `ModelFitArgs`, containing optional fields.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchSize",
                      "type": "number",
                      "documentation": "Number of samples per gradient update. If unspecified, it\nwill default to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "epochs",
                      "type": "number",
                      "documentation": "Integer number of times to iterate over the training data arrays.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "ModelLoggingVerbosity",
                      "documentation": "Verbosity level.\n\nExpected to be 0, 1, or 2. Default: 1.\n\n0 - No printed message during fit() call.\n1 - In Node.js (tfjs-node), prints the progress bar, together with\n     real-time updates of loss and metric values and training speed.\n     In the browser: no action. This is the default.\n2 - Not implemented yet.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "callbacks",
                      "type": "BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]",
                      "documentation": "List of callbacks to be called during training.\nCan have one or more of the following callbacks:\n   - `onTrainBegin(logs)`: called when training starts.\n   - `onTrainEnd(logs)`: called when training ends.\n   - `onEpochBegin(epoch, logs)`: called at the start of every epoch.\n   - `onEpochEnd(epoch, logs)`: called at the end of every epoch.\n   - `onBatchBegin(batch, logs)`: called at the start of every batch.\n   - `onBatchEnd(batch, logs)`: called at the end of every batch.\n   - `onYield(epoch, batch, logs)`: called every `yieldEvery` milliseconds\n      with the current epoch, batch and logs. The logs are the same\n      as in `onBatchEnd()`. Note that `onYield` can skip batches or\n      epochs. See also docs for `yieldEvery` below.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSplit",
                      "type": "number",
                      "documentation": "Float between 0 and 1: fraction of the training data\nto be used as validation data. The model will set apart this fraction of\nthe training data, will not train on it, and will evaluate the loss and\nany model metrics on this data at the end of each epoch.\nThe validation data is selected from the last samples in the `x` and `y`\ndata provided, before shuffling.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationData",
                      "type": "[\n    [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]\n  ]|[[tf.Tensor](#class:Tensor) | [tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[], [tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]]",
                      "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be a tuple [xVal, yVal] or a tuple [xVal, yVal,\nvalSampleWeights]. The model will not be trained on this data.\n`validationData` will override `validationSplit`.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "shuffle",
                      "type": "boolean",
                      "documentation": "Whether to shuffle the training data before each epoch. Has\nno effect when `stepsPerEpoch` is not `null`.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "classWeight",
                      "type": "ClassWeight|ClassWeight[]|ClassWeightMap",
                      "documentation": "Optional object mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.\n\nIf the model has multiple outputs, a class weight can be specified for\neach of the outputs by setting this field an array of weight object\nor an object that maps model output names (e.g., `model.outputNames[0]`)\nto weight objects.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "sampleWeight",
                      "type": "[tf.Tensor](#class:Tensor)",
                      "documentation": "Optional array of the same length as x, containing\nweights to apply to the model's loss for each sample. In the case of\ntemporal data, you can pass a 2D array with shape (samples,\nsequenceLength), to apply a different weight to every timestep of every\nsample. In this case you should make sure to specify\nsampleWeightMode=\"temporal\" in compile().",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "initialEpoch",
                      "type": "number",
                      "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun). When this is used, `epochs` is the index of the \"final epoch\".\nThe model is not trained for a number of iterations given by `epochs`,\nbut merely until the epoch of index `epochs` is reached.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "stepsPerEpoch",
                      "type": "number",
                      "documentation": "Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. When training\nwith Input Tensors such as TensorFlow data tensors, the default `null` is\nequal to the number of unique samples in your dataset divided by the\nbatch size, or 1 if that cannot be determined.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationSteps",
                      "type": "number",
                      "documentation": "Only relevant if `stepsPerEpoch` is specified. Total number of steps\n(batches of samples) to validate before stopping.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "yieldEvery",
                      "type": "YieldEveryOptions",
                      "documentation": "Configures the frequency of yielding the main thread to other tasks.\n\nIn the browser environment, yielding the main thread can improve the\nresponsiveness of the page during training. In the Node.js environment,\nit can ensure tasks queued in the event loop can be handled in a timely\nmanner.\n\nThe value can be one of the following:\n   - `'auto'`: The yielding happens at a certain frame rate (currently set\n               at 125ms). This is the default.\n   - `'batch'`: yield every batch.\n   - `'epoch'`: yield every epoch.\n   - any `number`: yield every `number` milliseconds.\n   - `'never'`: never yield. (yielding can still happen through `await\n      nextFrame()` calls in custom callbacks.)",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<History>",
                  "documentation": "Trains the model for a fixed number of epochs (iterations on a\ndataset).\n\n```js\nconst model = tf.sequential({\n     layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nfor (let i = 1; i < 5 ; ++i) {\n   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n       batchSize: 4,\n       epochs: 3\n   });\n   console.log(\"Loss after Epoch \" + i + \" : \" + h.history.loss[0]);\n}\n```",
                  "fileName": "#1464",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1464-L1602",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.fit"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "fitDataset",
                  "paramStr": "(dataset, args)",
                  "parameters": [
                    {
                      "name": "dataset",
                      "documentation": "A dataset object. Its `iterator()` method is expected\nto generate a dataset iterator object, the `next()` method of which\nis expected to produce data batches for training. The return value\nof the `next()` call ought to contain a boolean `done` field and a\n`value` field. The `value` field is expected to be an array of two\n[tf.Tensor](#class:Tensor)s or an array of two nested [tf.Tensor](#class:Tensor) structures. The former\ncase is for models with exactly one input and one output (e.g.\na sequential model). The latter case is for models with multiple\ninputs and/or multiple outputs.\nOf the two items in the array, the first is the input feature(s) and\nthe second is the output target(s).",
                      "type": "[tf.data.Dataset](#class:data.Dataset)",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "args",
                      "documentation": "A `ModelFitDatasetArgs`, containing optional fields.",
                      "type": "Object",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "batchesPerEpoch",
                      "type": "number",
                      "documentation": "(Optional) Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. It should\ntypically be equal to the number of samples of your dataset divided by\nthe batch size, so that `fitDataset`() call can utilize the entire dataset.\nIf it is not provided, use `done` return value in `iterator.next()` as\nsignal to finish an epoch.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "epochs",
                      "type": "number",
                      "documentation": "Integer number of times to iterate over the training dataset.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "verbose",
                      "type": "ModelLoggingVerbosity",
                      "documentation": "Verbosity level.\n\nExpected to be 0, 1, or 2. Default: 1.\n\n0 - No printed message during fit() call.\n1 - In Node.js (tfjs-node), prints the progress bar, together with\n     real-time updates of loss and metric values and training speed.\n     In the browser: no action. This is the default.\n2 - Not implemented yet.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "callbacks",
                      "type": "BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]",
                      "documentation": "List of callbacks to be called during training.\nCan have one or more of the following callbacks:\n   - `onTrainBegin(logs)`: called when training starts.\n   - `onTrainEnd(logs)`: called when training ends.\n   - `onEpochBegin(epoch, logs)`: called at the start of every epoch.\n   - `onEpochEnd(epoch, logs)`: called at the end of every epoch.\n   - `onBatchBegin(batch, logs)`: called at the start of every batch.\n   - `onBatchEnd(batch, logs)`: called at the end of every batch.\n   - `onYield(epoch, batch, logs)`: called every `yieldEvery` milliseconds\n      with the current epoch, batch and logs. The logs are the same\n      as in `onBatchEnd()`. Note that `onYield` can skip batches or\n      epochs. See also docs for `yieldEvery` below.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationData",
                      "type": "[\n    TensorOrArrayOrMap, TensorOrArrayOrMap\n  ]|[TensorOrArrayOrMap, TensorOrArrayOrMap, TensorOrArrayOrMap]|[tf.data.Dataset](#class:data.Dataset)",
                      "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be any of the following:\n\n   - An array `[xVal, yVal]`, where the two values may be [tf.Tensor](#class:Tensor),\n     an array of Tensors, or a map of string to Tensor.\n   - Similarly, an array ` [xVal, yVal, valSampleWeights]`\n     (not implemented yet).\n   - a `Dataset` object with elements of the form `{xs: xVal, ys: yVal}`,\n     where `xs` and `ys` are the feature and label tensors, respectively.\n\nIf `validationData` is an Array of Tensor objects, each [tf.Tensor](#class:Tensor) will be\nsliced into batches during validation, using the parameter\n`validationBatchSize` (which defaults to 32). The entirety of the\n[tf.Tensor](#class:Tensor) objects will be used in the validation.\n\nIf `validationData` is a dataset object, and the `validationBatches`\nparameter is specified, the validation will use `validationBatches` batches\ndrawn from the dataset object. If `validationBatches` parameter is not\nspecified, the validation will stop when the dataset is exhausted.\n\nThe model will not be trained on this data.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationBatchSize",
                      "type": "number",
                      "documentation": "Optional batch size for validation.\n\nUsed only if `validationData` is an array of [tf.Tensor](#class:Tensor) objects, i.e., not\na dataset object.\n\nIf not specified, its value defaults to 32.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "validationBatches",
                      "type": "number",
                      "documentation": "(Optional) Only relevant if `validationData` is specified and is a dataset\nobject.\n\nTotal number of batches of samples to draw from `validationData` for\nvalidation purpose before stopping at the end of every epoch. If not\nspecified, `evaluateDataset` will use `iterator.next().done` as signal to\nstop validation.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "yieldEvery",
                      "type": "YieldEveryOptions",
                      "documentation": "Configures the frequency of yielding the main thread to other tasks.\n\nIn the browser environment, yielding the main thread can improve the\nresponsiveness of the page during training. In the Node.js environment,\nit can ensure tasks queued in the event loop can be handled in a timely\nmanner.\n\nThe value can be one of the following:\n   - `'auto'`: The yielding happens at a certain frame rate (currently set\n               at 125ms). This is the default.\n   - `'batch'`: yield every batch.\n   - `'epoch'`: yield every epoch.\n   - a `number`: Will yield every `number` milliseconds.\n   - `'never'`: never yield. (But yielding can still happen through `await\n      nextFrame()` calls in custom callbacks.)",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "initialEpoch",
                      "type": "number",
                      "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun). When this is used, `epochs` is the index of the \"final epoch\".\nThe model is not trained for a number of iterations given by `epochs`,\nbut merely until the epoch of index `epochs` is reached.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "classWeight",
                      "type": "ClassWeight|ClassWeight[]|ClassWeightMap",
                      "documentation": "Optional object mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.\n\nIf the model has multiple outputs, a class weight can be specified for\neach of the outputs by setting this field an array of weight object\nor an object that maps model output names (e.g., `model.outputNames[0]`)\nto weight objects.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<History>",
                  "documentation": "Trains the model using a dataset object.",
                  "fileName": "#1791",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1791-L1794",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.fitDataset"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "trainOnBatch",
                  "paramStr": "(x, y)",
                  "parameters": [
                    {
                      "name": "x",
                      "documentation": "Input data. It could be one of the following:\n- A [tf.Tensor](#class:Tensor), or an Array of [tf.Tensor](#class:Tensor)s (in case the model has\nmultiple inputs).\n- An Object mapping input names to corresponding [tf.Tensor](#class:Tensor) (if the\nmodel has named inputs).",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "y",
                      "documentation": "Target data. It could be either a [tf.Tensor](#class:Tensor) or multiple\n[tf.Tensor](#class:Tensor)s. It should be consistent with `x`.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|\n      {[inputName: string]: [tf.Tensor](#class:Tensor)}",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "Promise<number|number[]>",
                  "documentation": "Runs a single gradient update on a single batch of data.\n\nThis method differs from `fit()` and `fitDataset()` in the following\nregards:\n   - It operates on exactly one batch of data.\n   - It returns only the loss and metric values, instead of\n     returning the batch-by-batch loss and metric values.\n   - It doesn't support fine-grained options such as verbosity and\n     callbacks.",
                  "fileName": "#1819",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1819-L1839",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.trainOnBatch"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes",
                    "ignoreCI": true
                  },
                  "symbolName": "save",
                  "paramStr": "(handlerOrURL, config?)",
                  "parameters": [
                    {
                      "name": "handlerOrURL",
                      "documentation": "An instance of `IOHandler` or a URL-like,\nscheme-based string shortcut for `IOHandler`.",
                      "type": "io.IOHandler|string",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "config",
                      "documentation": "Options for saving the model.",
                      "type": "Object",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "trainableOnly",
                      "type": "boolean",
                      "documentation": "Whether to save only the trainable weights of the model, ignoring the\nnon-trainable ones.",
                      "optional": false,
                      "isConfigParam": true
                    },
                    {
                      "name": "includeOptimizer",
                      "type": "boolean",
                      "documentation": "Whether the optimizer will be saved (if exists).\n\nDefault: `false`.",
                      "optional": false,
                      "isConfigParam": true
                    }
                  ],
                  "returnType": "Promise<io.SaveResult>",
                  "documentation": "Save the configuration and/or weights of the LayersModel.\n\nAn `IOHandler` is an object that has a `save` method of the proper\nsignature defined. The `save` method manages the storing or\ntransmission of serialized data (\"artifacts\") that represent the\nmodel's topology and weights onto or via a specific medium, such as\nfile downloads, local storage, IndexedDB in the web browser and HTTP\nrequests to a server. TensorFlow.js provides `IOHandler`\nimplementations for a number of frequently used saving mediums, such as\n[tf.io.browserDownloads()](#io.browserDownloads) and `tf.io.browserLocalStorage`. See `tf.io`\nfor more details.\n\nThis method also allows you to refer to certain types of `IOHandler`s\nas URL-like string shortcuts, such as 'localstorage://' and\n'indexeddb://'.\n\nExample 1: Save `model`'s topology and weights to browser [local\nstorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('localstorage://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 2. Saving `model`'s topology and weights to browser\n[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('indexeddb://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 3. Saving `model`'s topology and weights as two files\n(`my-model-1.json` and `my-model-1.weights.bin`) downloaded from\nbrowser.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconst saveResults = await model.save('downloads://my-model-1');\n```\n\nExample 4. Send  `model`'s topology and weights to an HTTP server.\nSee the documentation of [tf.io.http()](#io.http) for more details\nincluding specifying request parameters and implementation of the\nserver.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconst saveResults = await model.save('http://my-server/model/upload');\n```",
                  "fileName": "#2112",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L2112-L2166",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.save"
                },
                {
                  "docInfo": {
                    "heading": "Layers",
                    "subheading": "Classes",
                    "namespace": "layers",
                    "subclasses": [
                      "LayersModel"
                    ]
                  },
                  "symbolName": "getLayer",
                  "namespace": "layers",
                  "paramStr": "(name)",
                  "parameters": [
                    {
                      "name": "name",
                      "documentation": "Name of layer.",
                      "type": "string",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.layers.Layer](#class:layers.Layer)",
                  "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                  "fileName": "#975",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L975-L975",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.getLayer"
                },
                {
                  "docInfo": {
                    "heading": "Layers",
                    "subheading": "Classes",
                    "namespace": "layers",
                    "subclasses": [
                      "LayersModel"
                    ]
                  },
                  "symbolName": "getLayer",
                  "namespace": "layers",
                  "paramStr": "(name)",
                  "parameters": [
                    {
                      "name": "name",
                      "documentation": "Name of layer.",
                      "type": "string",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.layers.Layer](#class:layers.Layer)",
                  "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                  "fileName": "#976",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L976-L976",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.getLayer"
                },
                {
                  "docInfo": {
                    "heading": "Layers",
                    "subheading": "Classes",
                    "namespace": "layers",
                    "subclasses": [
                      "LayersModel"
                    ]
                  },
                  "symbolName": "getLayer",
                  "namespace": "layers",
                  "paramStr": "(name)",
                  "parameters": [
                    {
                      "name": "name",
                      "documentation": "Name of layer.",
                      "type": "string",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.layers.Layer](#class:layers.Layer)",
                  "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                  "fileName": "#977",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L977-L977",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.getLayer"
                },
                {
                  "docInfo": {
                    "heading": "Layers",
                    "subheading": "Classes",
                    "namespace": "layers",
                    "subclasses": [
                      "LayersModel"
                    ]
                  },
                  "symbolName": "getLayer",
                  "namespace": "layers",
                  "paramStr": "(name)",
                  "parameters": [
                    {
                      "name": "name",
                      "documentation": "Name of layer.",
                      "type": "string",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.layers.Layer](#class:layers.Layer)",
                  "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                  "fileName": "#978",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L978-L996",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.LayersModel.getLayer"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "Container|tfc.InferenceModel",
              "displayName": "tf.LayersModel",
              "urlHash": "class:LayersModel"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "Sequential",
              "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n[tf.sequential()](#sequential) is a factory function that creates an instance of\n[tf.Sequential](#class:Sequential).\n\n```js\n  // Define a model for linear regression.\n  const model = tf.sequential();\n  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n\n  // Prepare the model for training: Specify the loss and the optimizer.\n  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n\n  // Generate some synthetic data for training.\n  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n\n  // Train the model using the data then do inference on a data point the\n  // model hasn't seen:\n  await model.fit(xs, ys);\n  model.predict(tf.tensor2d([5], [1, 1])).print();\n```",
              "fileName": "#397",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L397-L1113",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "add",
                  "paramStr": "(layer)",
                  "parameters": [
                    {
                      "name": "layer",
                      "documentation": "Layer instance.",
                      "type": "[tf.layers.Layer](#class:layers.Layer)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Adds a layer instance on top of the layer stack.\n\n```js\n  const model = tf.sequential();\n  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n  // Note that the untrained model is random at this point.\n  model.predict(tf.randomNormal([10, 1])).print();\n```",
                  "fileName": "#452",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L452-L555",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.Sequential.add"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "[tf.LayersModel](#class:LayersModel)",
              "displayName": "tf.Sequential",
              "urlHash": "class:Sequential"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Classes"
              },
              "symbolName": "SymbolicTensor",
              "documentation": "[tf.SymbolicTensor](#class:SymbolicTensor) is a placeholder for a Tensor without any concrete value.\n\nThey are most often encountered when building a graph of `Layer`s for a\n[tf.LayersModel](#class:LayersModel) and the input data's shape, but not values are known.",
              "fileName": "#98",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L98-L145",
              "methods": [],
              "tags": [],
              "isClass": true,
              "displayName": "tf.SymbolicTensor",
              "urlHash": "class:SymbolicTensor"
            }
          ]
        },
        {
          "name": "Op Registry",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Op Registry"
              },
              "symbolName": "deregisterOp",
              "paramStr": "(name)",
              "parameters": [
                {
                  "name": "name",
                  "documentation": "The Tensorflow Op name.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Deregister the Op for graph model executor.",
              "fileName": "#78",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/operations/custom_op/register.ts#L78-L80",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.deregisterOp",
              "urlHash": "deregisterOp"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Op Registry"
              },
              "symbolName": "getRegisteredOp",
              "paramStr": "(name)",
              "parameters": [
                {
                  "name": "name",
                  "documentation": "The Tensorflow Op name.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "OpMapper",
              "documentation": "Retrieve the OpMapper object for the registered op.",
              "fileName": "#67",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/operations/custom_op/register.ts#L67-L69",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.getRegisteredOp",
              "urlHash": "getRegisteredOp"
            },
            {
              "docInfo": {
                "heading": "Models",
                "subheading": "Op Registry"
              },
              "symbolName": "registerOp",
              "paramStr": "(name, opFunc)",
              "parameters": [
                {
                  "name": "name",
                  "documentation": "The Tensorflow Op name.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "opFunc",
                  "documentation": "An op function which is called with the current graph node\nduring execution and needs to return a tensor or a list of tensors. The node\nhas the following attributes:\n- attr: A map from attribute name to its value\n- inputs: A list of input tensors",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Register an Op for graph model executor. This allows you to register\nTensorFlow custom op or override existing op.\n\nHere is an example of registering a new MatMul Op.\n```js\nconst customMatmul = (node) =>\n    tf.matMul(\n        node.inputs[0], node.inputs[1],\n        node.attrs['transpose_a'], node.attrs['transpose_b']);\n\ntf.registerOp('MatMul', customMatmul);\n```\nThe inputs and attrs of the node object are based on the TensorFlow op\nregistry.",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-converter/src/operations/custom_op/register.ts#L48-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.registerOp",
              "urlHash": "registerOp"
            }
          ]
        }
      ]
    },
    {
      "name": "Layers",
      "description": "<p>Layers are the primary building block for \nconstructing a Model.  Each layer will typically perform some\ncomputation to transform its input to its output.</p>\n<p>Layers will automatically take care of creating and initializing\nthe various internal variables/weights they need to function.</p>",
      "subheadings": [
        {
          "name": "Advanced Activation",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "elu",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "type": "number",
                  "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `1.0`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ELU",
              "documentation": "Exponential Linear Unit (ELU).\n\nIt follows:\n`f(x) =  alpha * (exp(x) - 1.) for x < 0`,\n`f(x) = x for x >= 0`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Fast and Accurate Deep Network Learning by Exponential Linear Units\n(ELUs)](https://arxiv.org/abs/1511.07289v1)",
              "fileName": "#102",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L102-L104",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.elu",
              "urlHash": "layers.elu"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "leakyReLU",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "type": "number",
                  "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `0.3`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "LeakyReLU",
              "documentation": "Leaky version of a rectified linear unit.\n\nIt allows a small gradient when the unit is not active:\n`f(x) = alpha * x for x < 0.`\n`f(x) = x for x >= 0.`\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#147",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L147-L149",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.leakyReLU",
              "urlHash": "layers.leakyReLU"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "prelu",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alphaInitializer",
                  "type": "[tf.initializers.Initializer](#class:initializers.Initializer)|'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string",
                  "documentation": "Initializer for the learnable alpha.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "alphaRegularizer",
                  "type": "Regularizer",
                  "documentation": "Regularizer for the learnable alpha.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "alphaConstraint",
                  "type": "[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the learnable alpha.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "sharedAxes",
                  "type": "number|number[]",
                  "documentation": "The axes along which to share learnable parameters for the activation\nfunction. For example, if the incoming feature maps are from a 2D\nconvolution with output shape `[numExamples, height, width, channels]`,\nand you wish to share parameters across space (height and width) so that\neach filter channels has only one set of parameters, set\n`shared_axes: [1, 2]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "PReLU",
              "documentation": "Parameterized version of a leaky rectified linear unit.\n\nIt follows\n`f(x) = alpha * x for x < 0.`\n`f(x) = x for x >= 0.`\nwherein `alpha` is a trainable weight.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#172",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L172-L174",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.prelu",
              "urlHash": "layers.prelu"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "reLU",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "maxValue",
                  "type": "number",
                  "documentation": "Float, the maximum output value.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ReLU",
              "documentation": "Rectified Linear Unit activation function.\n\nInput shape:\n   Arbitrary. Use the config field `inputShape` (Array of integers, does\n   not include the sample axis) when using this layer as the first layer\n   in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#123",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L123-L125",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.reLU",
              "urlHash": "layers.reLU"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "softmax",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "Integer, axis along which the softmax normalization is applied.\nDefaults to `-1` (i.e., the last axis).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Softmax",
              "documentation": "Softmax activation layer.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
              "fileName": "#192",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L192-L194",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.softmax",
              "urlHash": "layers.softmax"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Advanced Activation",
                "namespace": "layers"
              },
              "symbolName": "thresholdedReLU",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "theta",
                  "type": "number",
                  "documentation": "Float >= 0. Threshold location of activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ThresholdedReLU",
              "documentation": "Thresholded Rectified Linear Unit.\n\nIt follows:\n`f(x) = x for x > theta`,\n`f(x) = 0 otherwise`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Zero-Bias Autoencoders and the Benefits of Co-Adapting\nFeatures](http://arxiv.org/abs/1402.3337)",
              "fileName": "#220",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L220-L222",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.thresholdedReLU",
              "urlHash": "layers.thresholdedReLU"
            }
          ]
        },
        {
          "name": "Basic",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "activation",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Name of the activation function to use.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Activation",
              "documentation": "Applies an activation function to an output.\n\nThis layer applies element-wise activation function.  Other layers, notably\n`dense` can also apply activation functions.  Use this isolated activation\nfunction to extract the values before and after the\nactivation. For instance:\n\n```js\nconst input = tf.input({shape: [5]});\nconst denseLayer = tf.layers.dense({units: 1});\nconst activationLayer = tf.layers.activation({activation: 'relu6'});\n\n// Obtain the output symbolic tensors by applying the layers in order.\nconst denseOutput = denseLayer.apply(input);\nconst activationOutput = activationLayer.apply(denseOutput);\n\n// Create the model based on the inputs.\nconst model = tf.model({\n     inputs: input,\n     outputs: [denseOutput, activationOutput]\n});\n\n// Collect both outputs and print separately.\nconst [denseOut, activationOut] = model.predict(tf.randomNormal([6, 5]));\ndenseOut.print();\nactivationOut.print();\n```",
              "fileName": "#482",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L482-L484",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.activation",
              "urlHash": "layers.activation"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "dense",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\n\nIf unspecified, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether to apply a bias.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the dense kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "If specified, defines inputShape as `[inputDim]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the dense kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Dense",
              "documentation": "Creates a dense (fully connected) layer.\n\nThis layer implements the operation:\n   `output = activation(dot(input, kernel) + bias)`\n\n`activation` is the element-wise activation function\n   passed as the `activation` argument.\n\n`kernel` is a weights matrix created by the layer.\n\n`bias` is a bias vector created by the layer (only applicable if `useBias`\nis `true`).\n\n*Input shape:**\n\n   nD [tf.Tensor](#class:Tensor) with shape: `(batchSize, ..., inputDim)`.\n\n   The most common situation would be\n   a 2D input with shape `(batchSize, inputDim)`.\n\n*Output shape:**\n\n   nD tensor with shape: `(batchSize, ..., units)`.\n\n   For instance, for a 2D input with shape `(batchSize, inputDim)`,\n   the output would have shape `(batchSize, units)`.\n\nNote: if the input to the layer has a rank greater than 2, then it is\nflattened prior to the initial dot product with the kernel.",
              "fileName": "#519",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L519-L521",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.dense",
              "urlHash": "layers.dense"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "dropout",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "type": "number",
                  "documentation": "Float between 0 and 1. Fraction of the input units to drop.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "noiseShape",
                  "type": "number[]",
                  "documentation": "Integer array representing the shape of the binary dropout mask that will\nbe multiplied with the input.\n\nFor instance, if your inputs have shape `(batchSize, timesteps, features)`\nand you want the dropout mask to be the same for all timesteps, you can use\n`noise_shape=(batch_size, 1, features)`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "An integer to use as random seed.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Dropout",
              "documentation": "Applies\n[dropout](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf) to\nthe input.\n\nDropout consists in randomly setting a fraction `rate` of input units to 0 at\neach update during training time, which helps prevent overfitting.",
              "fileName": "#533",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L533-L535",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.dropout",
              "urlHash": "layers.dropout"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "embedding",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "Integer > 0. Size of the vocabulary, i.e. maximum integer index + 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "outputDim",
                  "type": "number",
                  "documentation": "Integer >= 0. Dimension of the dense embedding.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `embeddings` matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `embeddings` matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "embeddingsConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `embeddings` matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "maskZero",
                  "type": "boolean",
                  "documentation": "Whether the input value 0 is a special \"padding\" value that should be\nmasked out. This is useful when using recurrent layers which may take\nvariable length input.\n\nIf this is `True` then all subsequent layers in the model need to support\nmasking or an exception will be raised. If maskZero is set to `True`, as a\nconsequence, index 0 cannot be used in the vocabulary (inputDim should\nequal size of vocabulary + 1).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "number|number[]",
                  "documentation": "Length of input sequences, when it is constant.\n\nThis argument is required if you are going to connect `flatten` then\n`dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Embedding",
              "documentation": "Maps positive integers (indices) into dense vectors of fixed size.\nE.g. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]\n\n*Input shape:** 2D tensor with shape: `[batchSize, sequenceLength]`.\n\n*Output shape:** 3D tensor with shape: `[batchSize, sequenceLength,\noutputDim]`.",
              "fileName": "#684",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L684-L686",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.embedding",
              "urlHash": "layers.embedding"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "flatten",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Image data format: channelsLast (default) or channelsFirst.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Flatten",
              "documentation": "Flattens the input. Does not affect the batch size.\n\nA `Flatten` layer flattens each batch in its inputs to 1D (making the output\n2D).\n\nFor example:\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst flattenLayer = tf.layers.flatten();\n// Inspect the inferred output shape of the flatten layer, which\n// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the\n// flattening. (The 1st dimension is the undermined batch size.)\nconsole.log(JSON.stringify(flattenLayer.apply(input).shape));\n```",
              "fileName": "#592",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L592-L594",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.flatten",
              "urlHash": "layers.flatten"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "permute",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dims",
                  "type": "number[]",
                  "documentation": "Array of integers. Permutation pattern. Does not include the\nsample (batch) dimension. Index starts at 1.\nFor instance, `[2, 1]` permutes the first and second dimensions\nof the input.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Permute",
              "documentation": "Permutes the dimensions of the input according to a given pattern.\n\nUseful for, e.g., connecting RNNs and convnets together.\n\nExample:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.permute({\n   dims: [2, 1],\n   inputShape: [10, 64]\n}));\nconsole.log(model.outputShape);\n// Now model's output shape is [null, 64, 10], where null is the\n// unpermuted sample (batch) dimension.\n```\n\nInput shape:\n   Arbitrary. Use the configuration field `inputShape` when using this\n   layer as the first layer in a model.\n\nOutput shape:\n   Same rank as the input shape, but with the dimensions re-ordered (i.e.,\n   permuted) according to the `dims` configuration of this layer.",
              "fileName": "#669",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L669-L671",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.permute",
              "urlHash": "layers.permute"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "repeatVector",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "n",
                  "type": "number",
                  "documentation": "The integer number of times to repeat the input.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "RepeatVector",
              "documentation": "Repeats the input n times in a new dimension.\n\n```js\n  const model = tf.sequential();\n  model.add(tf.layers.repeatVector({n: 4, inputShape: [2]}));\n  const x = tf.tensor2d([[10, 20]]);\n  // Use the model to do inference on a data point the model hasn't seen\n  model.predict(x).print();\n  // output shape is now [batch, 2, 4]\n```",
              "fileName": "#610",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L610-L612",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.repeatVector",
              "urlHash": "layers.repeatVector"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "reshape",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "targetShape",
                  "type": "(null | number)[]",
                  "documentation": "The target shape. Does not include the batch axis.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Reshape",
              "documentation": "Reshapes an input to a certain shape.\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst reshapeLayer = tf.layers.reshape({targetShape: [2, 6]});\n// Inspect the inferred output shape of the Reshape layer, which\n// equals `[null, 2, 6]`. (The 1st dimension is the undermined batch size.)\nconsole.log(JSON.stringify(reshapeLayer.apply(input).shape));\n```\n\nInput shape:\n   Arbitrary, although all dimensions in the input shape must be fixed.\n   Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\n\nOutput shape:\n   [batchSize, targetShape[0], targetShape[1], ...,\n    targetShape[targetShape.length - 1]].",
              "fileName": "#637",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L637-L639",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.reshape",
              "urlHash": "layers.reshape"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Basic",
                "namespace": "layers"
              },
              "symbolName": "spatialDropout1d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "type": "number",
                  "documentation": "Float between 0 and 1. Fraction of the input units to drop.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "An integer to use as random seed.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "input_shape",
                  "type": "(null | number)[]",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batch_input_shape",
                  "type": "(null | number)[]",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batch_size",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "input_dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "SpatialDropout1D",
              "documentation": "Spatial 1D version of Dropout.\n\nThis Layer type performs the same function as the Dropout layer, but it drops\nentire 1D feature maps instead of individual elements. For example, if an\ninput example consists of 3 timesteps and the feature map for each timestep\nhas a size of 4, a `spatialDropout1d` layer may zero out the feature maps\nof the 1st timesteps and 2nd timesteps completely while sparing all feature\nelements of the 3rd timestep.\n\nIf adjacent frames (timesteps) are strongly correlated (as is normally the\ncase in early convolution layers), regular dropout will not regularize the\nactivation and will otherwise just result in merely an effective learning\nrate decrease. In this case, `spatialDropout1d` will help promote\nindependence among feature maps and should be used instead.\n\n*Arguments:**\n   rate: A floating-point number >=0 and <=1. Fraction of the input elements\n     to drop.\n\n*Input shape:**\n   3D tensor with shape `(samples, timesteps, channels)`.\n\n*Output shape:**\n   Same as the input shape.\n\nReferences:\n   - [Efficient Object Localization Using Convolutional\n      Networks](https://arxiv.org/abs/1411.4280)",
              "fileName": "#569",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L569-L571",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.spatialDropout1d",
              "urlHash": "layers.spatialDropout1d"
            }
          ]
        },
        {
          "name": "Convolutional",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "conv1d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Conv1D",
              "documentation": "1D convolution layer (e.g., temporal convolution).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input over a single spatial (or temporal) dimension\nto produce a tensor of outputs.\n\nIf `use_bias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model, provide an\n`inputShape` argument `Array` or `null`.\n\nFor example, `inputShape` would be:\n- `[10, 128]` for sequences of 10 vectors of 128-dimensional vectors\n- `[null, 128]` for variable-length sequences of 128-dimensional vectors.",
              "fileName": "#246",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L246-L248",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.conv1d",
              "urlHash": "layers.conv1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "conv2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Conv2D",
              "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat='channelsLast'`.",
              "fileName": "#268",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L268-L270",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.conv2d",
              "urlHash": "layers.conv2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "conv2dTranspose",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Conv2DTranspose",
              "documentation": "Transposed convolutional layer (sometimes called Deconvolution).\n\nThe need for transposed convolutions generally arises\nfrom the desire to use a transformation going in the opposite direction of\na normal convolution, i.e., from something that has the shape of the output\nof some convolution to something that has the shape of its input while\nmaintaining a connectivity pattern that is compatible with said\nconvolution.\n\nWhen using this layer as the first layer in a model, provide the\nconfiguration `inputShape` (`Array` of integers, does not include the\nsample axis), e.g., `inputShape: [128, 128, 3]` for 128x128 RGB pictures in\n`dataFormat: 'channelsLast'`.\n\nInput shape:\n   4D tensor with shape:\n   `[batch, channels, rows, cols]` if `dataFormat` is `'channelsFirst'`.\n   or 4D tensor with shape\n   `[batch, rows, cols, channels]` if `dataFormat` is `'channelsLast'`.\n\nOutput shape:\n   4D tensor with shape:\n   `[batch, filters, newRows, newCols]` if `dataFormat` is\n`'channelsFirst'`. or 4D tensor with shape:\n   `[batch, newRows, newCols, filters]` if `dataFormat` is `'channelsLast'`.\n\nReferences:\n   - [A guide to convolution arithmetic for deep\nlearning](https://arxiv.org/abs/1603.07285v1)\n   - [Deconvolutional\nNetworks](http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf)",
              "fileName": "#307",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L307-L309",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.conv2dTranspose",
              "urlHash": "layers.conv2dTranspose"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "conv3d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Conv3D",
              "documentation": "3D convolution layer (e.g. spatial convolution over volumes).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 128, 1]` for 128x128x128 grayscale volumes\nin `dataFormat='channelsLast'`.",
              "fileName": "#329",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L329-L331",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.conv3d",
              "urlHash": "layers.conv3d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "cropping2D",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cropping",
                  "type": "number|[number, number]|[[number, number], [number, number]]",
                  "documentation": "Dimension of the cropping along the width and the height.\n- If integer: the same symmetric cropping\n  is applied to width and height.\n- If list of 2 integers:\n   interpreted as two different\n   symmetric cropping values for height and width:\n   `[symmetric_height_crop, symmetric_width_crop]`.\n- If a list of 2 lists of 2 integers:\n   interpreted as\n   `[[top_crop, bottom_crop], [left_crop, right_crop]]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n`channels_first` corresponds to inputs with shape\n   `(batch, channels, ...)`\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Cropping2D",
              "documentation": "Cropping layer for 2D input (e.g., image).\n\nThis layer can crop an input\nat the top, bottom, left and right side of an image tensor.\n\nInput shape:\n   4D tensor with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, rows, cols, channels]`\n   - If `data_format` is `\"channels_first\"`:\n     `[batch, channels, rows, cols]`.\n\nOutput shape:\n   4D with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, croppedRows, croppedCols, channels]`\n    - If `dataFormat` is `\"channelsFirst\"`:\n     `[batch, channels, croppedRows, croppedCols]`.\n\nExamples\n```js\n\nconst model = tf.sequential();\nmodel.add(tf.layers.cropping2D({cropping:[[2, 2], [2, 2]],\n                                inputShape: [128, 128, 3]}));\n//now output shape is [batch, 124, 124, 3]\n```",
              "fileName": "#401",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L401-L403",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.cropping2D",
              "urlHash": "layers.cropping2D"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "depthwiseConv2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "kernelSize",
                  "type": "number|[number, number]",
                  "documentation": "An integer or Array of 2 integers, specifying the width and height of the\n2D convolution window. Can be a single integer to specify the same value\nfor all spatial dimensions.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthMultiplier",
                  "type": "number",
                  "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal to\n`filtersIn * depthMultiplier`.\nDefault: 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the depthwise kernel matrix.\nDefault: GlorotNormal.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the depthwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function for the depthwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "DepthwiseConv2D",
              "documentation": "Depthwise separable 2D convolution.\n\nDepthwise Separable convolutions consists in performing just the first step\nin a depthwise spatial convolution (which acts on each input channel\nseparately). The `depthMultiplier` argument controls how many output channels\nare generated per input channel in the depthwise step.",
              "fileName": "#445",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L445-L447",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.depthwiseConv2d",
              "urlHash": "layers.depthwiseConv2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "separableConv2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depthMultiplier",
                  "type": "number",
                  "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal\nto `filtersIn * depthMultiplier`. Default: 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the depthwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the pointwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the depthwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the pointwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "depthwiseConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the depthwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "pointwiseConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the pointwise kernel matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]|[number, number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the convolutional kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the convolutional kernel weights.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activityRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the activation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "SeparableConv2D",
              "documentation": "Depthwise separable 2D convolution.\n\nSeparable convolution consists of first performing\na depthwise spatial convolution\n(which acts on each input channel separately)\nfollowed by a pointwise convolution which mixes together the resulting\noutput channels. The `depthMultiplier` argument controls how many\noutput channels are generated per input channel in the depthwise step.\n\nIntuitively, separable convolutions can be understood as\na way to factorize a convolution kernel into two smaller kernels,\nor as an extreme version of an Inception block.\n\nInput shape:\n   4D tensor with shape:\n     `[batch, channels, rows, cols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, rows, cols, channels]` if data_format='channelsLast'.\n\nOutput shape:\n   4D tensor with shape:\n     `[batch, filters, newRows, newCols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, newRows, newCols, filters]` if data_format='channelsLast'.\n     `rows` and `cols` values might have changed due to padding.",
              "fileName": "#366",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L366-L368",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.separableConv2d",
              "urlHash": "layers.separableConv2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers"
              },
              "symbolName": "upSampling2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "type": "number[]",
                  "documentation": "The upsampling factors for rows and columns.\n\nDefaults to `[2, 2]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`\"channelsLast\"` corresponds to inputs with shape\n   `[batch, ..., channels]`\n\n  `\"channelsFirst\"` corresponds to inputs with shape `[batch, channels,\n...]`.\n\nDefaults to `\"channelsLast\"`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "interpolation",
                  "type": "InterpolationFormat",
                  "documentation": "The interpolation mechanism, one of `\"nearest\"` or `\"bilinear\"`, default\nto `\"nearest\"`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "UpSampling2D",
              "documentation": "Upsampling layer for 2D inputs.\n\nRepeats the rows and columns of the data\nby size[0] and size[1] respectively.\n\n\nInput shape:\n    4D tensor with shape:\n     - If `dataFormat` is `\"channelsLast\"`:\n         `[batch, rows, cols, channels]`\n     - If `dataFormat` is `\"channelsFirst\"`:\n        `[batch, channels, rows, cols]`\n\nOutput shape:\n     4D tensor with shape:\n     - If `dataFormat` is `\"channelsLast\"`:\n        `[batch, upsampledRows, upsampledCols, channels]`\n     - If `dataFormat` is `\"channelsFirst\"`:\n         `[batch, channels, upsampledRows, upsampledCols]`",
              "fileName": "#429",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L429-L431",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.upSampling2d",
              "urlHash": "layers.upSampling2d"
            }
          ]
        },
        {
          "name": "Merge",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "add",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Add",
              "documentation": "Layer that performs element-wise addition on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). The inputs are specified as an\n`Array` when the `apply` method of the `Add` layer instance is called. For\nexample:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst addLayer = tf.layers.add();\nconst sum = addLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(sum.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#710",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L710-L712",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.add",
              "urlHash": "layers.add"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "average",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Average",
              "documentation": "Layer that performs element-wise averaging on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst averageLayer = tf.layers.average();\nconst average = averageLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(average.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#732",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L732-L734",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.average",
              "urlHash": "layers.average"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "concatenate",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "Axis along which to concatenate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Concatenate",
              "documentation": "Layer that concatenates an `Array` of inputs.\n\nIt takes a list of tensors, all of the same shape except for the\nconcatenation axis, and returns a single tensor, the concatenation\nof all inputs. For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 3]});\nconst concatLayer = tf.layers.concatenate();\nconst output = concatLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(output.shape));\n// You get [null, 2, 5], with the first dimension as the undetermined batch\n// dimension. The last dimension (5) is the result of concatenating the\n// last dimensions of the inputs (2 and 3).\n```",
              "fileName": "#756",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L756-L758",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.concatenate",
              "urlHash": "layers.concatenate"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "dot",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axes",
                  "type": "number|[number, number]",
                  "documentation": "Axis or axes along which the dot product will be taken.\n\nInteger or an Array of integers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "normalize",
                  "type": "boolean",
                  "documentation": "Whether to L2-normalize samples along the dot product axis\nbefore taking the dot product.\n\nIf set to `true`, the output of the dot product is the cosine\nproximity between the two samples.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Dot",
              "documentation": "Layer that computes a dot product between samples in two tensors.\n\nE.g., if applied to a list of two tensors `a` and `b` both of shape\n`[batchSize, n]`, the output will be a tensor of shape `[batchSize, 1]`,\nwhere each entry at index `[i, 0]` will be the dot product between\n`a[i, :]` and `b[i, :]`.\n\nExample:\n\n```js\nconst dotLayer = tf.layers.dot({axes: -1});\nconst x1 = tf.tensor2d([[10, 20], [30, 40]]);\nconst x2 = tf.tensor2d([[-1, -2], [-3, -4]]);\n\n// Invoke the layer's apply() method in eager (imperative) mode.\nconst y = dotLayer.apply([x1, x2]);\ny.print();\n```",
              "fileName": "#849",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L849-L851",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.dot",
              "urlHash": "layers.dot"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "maximum",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Maximum",
              "documentation": "Layer that computes the element-wise maximum of an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst maxLayer = tf.layers.maximum();\nconst max = maxLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(max.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#778",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L778-L780",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.maximum",
              "urlHash": "layers.maximum"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "minimum",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Minimum",
              "documentation": "Layer that computes the element-wise minimum of an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst minLayer = tf.layers.minimum();\nconst min = minLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(min.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
              "fileName": "#800",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L800-L802",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.minimum",
              "urlHash": "layers.minimum"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Merge",
                "namespace": "layers"
              },
              "symbolName": "multiply",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Multiply",
              "documentation": "Layer that multiplies (element-wise) an `Array` of inputs.\n\nIt takes as input an Array of tensors, all of the same\nshape, and returns a single tensor (also of the same shape).\nFor example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst input3 = tf.input({shape: [2, 2]});\nconst multiplyLayer = tf.layers.multiply();\nconst product = multiplyLayer.apply([input1, input2, input3]);\nconsole.log(product.shape);\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.",
              "fileName": "#823",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L823-L825",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.multiply",
              "urlHash": "layers.multiply"
            }
          ]
        },
        {
          "name": "Normalization",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Normalization",
                "namespace": "layers"
              },
              "symbolName": "batchNormalization",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "The integer axis that should be normalized (typically the features axis).\nDefaults to -1.\n\nFor instance, after a `Conv2D` layer with `data_format=\"channels_first\"`,\nset `axis=1` in `batchNormalization`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "momentum",
                  "type": "number",
                  "documentation": "Momentum of the moving average. Defaults to 0.99.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "epsilon",
                  "type": "number",
                  "documentation": "Small float added to the variance to avoid dividing by zero. Defaults to\n1e-3.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "center",
                  "type": "boolean",
                  "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "scale",
                  "type": "boolean",
                  "documentation": "If `true`, multiply by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear (also e.g. `nn.relu`),\nthis can be disabled since the scaling will be done by the next layer.\nDefaults to `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "betaInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the beta weight.\n  Defaults to 'zeros'.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "gammaInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the gamma weight.\n  Defaults to `ones`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "movingMeanInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the moving mean.\nDefaults to `zeros`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "movingVarianceInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the moving variance.\n  Defaults to 'Ones'.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "betaConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for the beta weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "gammaConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint for gamma weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "betaRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer for the beta weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "gammaRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer for the gamma weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "BatchNormalization",
              "documentation": "Batch normalization layer (Ioffe and Szegedy, 2014).\n\nNormalize the activations of the previous layer at each batch,\ni.e. applies a transformation that maintains the mean activation\nclose to 0 and the activation standard deviation close to 1.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape` (Array of integers, does\n   not include the sample axis) when calling the constructor of this class,\n   if this layer is used as a first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Batch Normalization: Accelerating Deep Network Training by Reducing\nInternal Covariate Shift](https://arxiv.org/abs/1502.03167)",
              "fileName": "#876",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L876-L878",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.batchNormalization",
              "urlHash": "layers.batchNormalization"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Normalization",
                "namespace": "layers"
              },
              "symbolName": "layerNormalization",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "type": "number|number[]",
                  "documentation": "The axis or axes that should be normalized (typically, the feature axis).\nDefaults to -1 (the last axis).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "epsilon",
                  "type": "number",
                  "documentation": "A small positive float added to variance to avoid divison by zero.\nDefaults to 1e-3.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "center",
                  "type": "boolean",
                  "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefault: `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "scale",
                  "type": "boolean",
                  "documentation": "If `true`, multiply output by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear, this can be disabled since scaling will\nbe done by the next layer.\nDefault: `true`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "betaInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the beta weight.\nDefault: `'zeros'`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "gammaInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the gamma weight.\nDefault: `'ones'`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "betaRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer for the beta weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "gammaRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer for the gamma weight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "LayerNormalization",
              "documentation": "Layer-normalization layer (Ba et al., 2016).\n\nNormalizes the activations of the previous layer for each given example in a\nbatch independently, instead of across a batch like in `batchNormalization`.\nIn other words, this layer applies a transformation that maintains the mean\nactivation within each example close to 0 and activation variance close to 1.\n\nInput shape:\n   Arbitrary. Use the argument `inputShape` when using this layer as the first\n   layer in a model.\n\nOutput shape:\n   Same as input.\n\nReferences:\n   - [Layer Normalization](https://arxiv.org/abs/1607.06450)",
              "fileName": "#900",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L900-L902",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.layerNormalization",
              "urlHash": "layers.layerNormalization"
            }
          ]
        },
        {
          "name": "Pooling",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "averagePooling1d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number]",
                  "documentation": "Size of the window to pool over, should be an integer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number]",
                  "documentation": "Period at which to sample the pooled values.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "How to fill in data that's not an integer multiple of poolSize.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "AveragePooling1D",
              "documentation": "Average pooling operation for spatial data.\n\nInput shape: `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`\n\n`tf.avgPool1d` is an alias.",
              "fileName": "#945",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L945-L947",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.averagePooling1d",
              "urlHash": "layers.averagePooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "averagePooling2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number, number]",
                  "documentation": "Factors by which to downscale in each dimension [vertical, horizontal].\nExpects an integer or an array of 2 integers.\n\nFor example, `[2, 2]` will halve the input in both spatial dimensions.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number, number]",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 2 integers. Integer, tuple of 2 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "The padding type to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "The data format to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "AveragePooling2D",
              "documentation": "Average pooling operation for spatial data.\n\nInput shape:\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, rows, cols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, rows, cols]`\n\nOutput shape\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, pooledRows, pooledCols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, pooledRows, pooledCols]`\n\n`tf.avgPool2d` is an alias.",
              "fileName": "#980",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L980-L982",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.averagePooling2d",
              "urlHash": "layers.averagePooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "averagePooling3d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number, number, number]",
                  "documentation": "Factors by which to downscale in each dimension [depth, height, width].\nExpects an integer or an array of 3 integers.\n\nFor example, `[2, 2, 2]` will halve the input in three dimensions.\nIf only one integer is specified, the same window length\nwill be used for all dimensions.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number, number, number]",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 3 integers. Integer, tuple of 3 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "The padding type to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "The data format to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "AveragePooling3D",
              "documentation": "Average pooling operation for 3D data.\n\nInput shape\n   - If `dataFormat === channelsLast`:\n       5D tensor with shape:\n       `[batchSize, depths, rows, cols, channels]`\n   - If `dataFormat === channelsFirst`:\n      4D tensor with shape:\n       `[batchSize, channels, depths, rows, cols]`\n\nOutput shape\n   - If `dataFormat=channelsLast`:\n       5D tensor with shape:\n       `[batchSize, pooledDepths, pooledRows, pooledCols, channels]`\n   - If `dataFormat=channelsFirst`:\n       5D tensor with shape:\n       `[batchSize, channels, pooledDepths, pooledRows, pooledCols]`",
              "fileName": "#1013",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1013-L1015",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.averagePooling3d",
              "urlHash": "layers.averagePooling3d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "globalAveragePooling1d",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GlobalAveragePooling1D",
              "documentation": "Global average pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape: 2D tensor with shape: `[batchSize, features]`.",
              "fileName": "#1034",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1034-L1036",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.globalAveragePooling1d",
              "urlHash": "layers.globalAveragePooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "globalAveragePooling2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels]` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GlobalAveragePooling2D",
              "documentation": "Global average pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
              "fileName": "#1052",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1052-L1054",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.globalAveragePooling2d",
              "urlHash": "layers.globalAveragePooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "globalMaxPooling1d",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GlobalMaxPooling1D",
              "documentation": "Global max pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape: 2D tensor with shape: `[batchSize, features]`.",
              "fileName": "#1065",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1065-L1067",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.globalMaxPooling1d",
              "urlHash": "layers.globalMaxPooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "globalMaxPooling2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels]` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GlobalMaxPooling2D",
              "documentation": "Global max pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
              "fileName": "#1083",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1083-L1085",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.globalMaxPooling2d",
              "urlHash": "layers.globalMaxPooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "maxPooling1d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number]",
                  "documentation": "Size of the window to pool over, should be an integer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number]",
                  "documentation": "Period at which to sample the pooled values.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "How to fill in data that's not an integer multiple of poolSize.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "MaxPooling1D",
              "documentation": "Max pooling operation for temporal data.\n\nInput shape:  `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`",
              "fileName": "#1096",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1096-L1098",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.maxPooling1d",
              "urlHash": "layers.maxPooling1d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "maxPooling2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number, number]",
                  "documentation": "Factors by which to downscale in each dimension [vertical, horizontal].\nExpects an integer or an array of 2 integers.\n\nFor example, `[2, 2]` will halve the input in both spatial dimensions.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number, number]",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 2 integers. Integer, tuple of 2 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "The padding type to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "The data format to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "MaxPooling2D",
              "documentation": "Max pooling operation for spatial data.\n\nInput shape\n   - If `dataFormat === CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, rows, cols, channels]`\n   - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n       `[batchSize, channels, rows, cols]`\n\nOutput shape\n   - If `dataFormat=CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, pooledRows, pooledCols, channels]`\n   - If `dataFormat=CHANNEL_FIRST`:\n       4D tensor with shape:\n       `[batchSize, channels, pooledRows, pooledCols]`",
              "fileName": "#1121",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1121-L1123",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.maxPooling2d",
              "urlHash": "layers.maxPooling2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Pooling",
                "namespace": "layers"
              },
              "symbolName": "maxPooling3d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolSize",
                  "type": "number|[number, number, number]",
                  "documentation": "Factors by which to downscale in each dimension [depth, height, width].\nExpects an integer or an array of 3 integers.\n\nFor example, `[2, 2, 2]` will halve the input in three dimensions.\nIf only one integer is specified, the same window length\nwill be used for all dimensions.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|[number, number, number]",
                  "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 3 integers. Integer, tuple of 3 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "The padding type to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "The data format to use for the pooling layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "MaxPooling3D",
              "documentation": "Max pooling operation for 3D data.\n\nInput shape\n   - If `dataFormat === channelsLast`:\n       5D tensor with shape:\n       `[batchSize, depths, rows, cols, channels]`\n   - If `dataFormat === channelsFirst`:\n      5D tensor with shape:\n       `[batchSize, channels, depths, rows, cols]`\n\nOutput shape\n   - If `dataFormat=channelsLast`:\n       5D tensor with shape:\n       `[batchSize, pooledDepths, pooledRows, pooledCols, channels]`\n   - If `dataFormat=channelsFirst`:\n       5D tensor with shape:\n       `[batchSize, channels, pooledDepths, pooledRows, pooledCols]`",
              "fileName": "#1146",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1146-L1148",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.maxPooling3d",
              "urlHash": "layers.maxPooling3d"
            }
          ]
        },
        {
          "name": "Recurrent",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "convLstm2d",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "activation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "[tf.any()](#any)",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "[tf.any()](#any)",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "[tf.any()](#any)",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "[tf.any()](#any)",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "[tf.any()](#any)",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "[tf.any()](#any)",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "[tf.any()](#any)",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "[tf.any()](#any)",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentActivation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unitForgetBias",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this config field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnSequences",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnState",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether to return the last state in addition to the output.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "goBackwards",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stateful",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unroll",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "[tf.any()](#any)",
                  "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "[tf.any()](#any)",
                  "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "cell",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ConvLSTM2D",
              "documentation": "Convolutional LSTM layer - Xingjian Shi 2015.\n\nThis is a `ConvRNN2D` layer consisting of one `ConvLSTM2DCell`. However,\nunlike the underlying `ConvLSTM2DCell`, the `apply` method of `ConvLSTM2D`\noperates on a sequence of inputs. The shape of the input (not including the\nfirst, batch dimension) needs to be 4-D, with the first dimension being time\nsteps. For example:\n\n```js\nconst filters = 3;\nconst kernelSize = 3;\n\nconst batchSize = 4;\nconst sequenceLength = 2;\nconst size = 5;\nconst channels = 3;\n\nconst inputShape = [batchSize, sequenceLength, size, size, channels];\nconst input = tf.ones(inputShape);\n\nconst layer = tf.layers.convLstm2d({filters, kernelSize});\n\nconst output = layer.apply(input);\n```",
              "fileName": "#1408",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1408-L1410",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.convLstm2d",
              "urlHash": "layers.convLstm2d"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "convLstm2dCell",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "activation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "[tf.any()](#any)",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "[tf.any()](#any)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "[tf.any()](#any)",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "[tf.any()](#any)",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "[tf.any()](#any)",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "[tf.any()](#any)",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "[tf.any()](#any)",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "[tf.any()](#any)",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "[tf.any()](#any)",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "[tf.any()](#any)",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.any()](#any)",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "[tf.any()](#any)",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentActivation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unitForgetBias",
                  "type": "[tf.any()](#any)",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "[tf.any()](#any)",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "filters",
                  "type": "number",
                  "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelSize",
                  "type": "number|number[]",
                  "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "strides",
                  "type": "number|number[]",
                  "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "padding",
                  "type": "'valid'|'same'|'causal'",
                  "documentation": "Padding mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dilationRate",
                  "type": "number|[number]|[number, number]",
                  "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ConvLSTM2DCell",
              "documentation": "Cell class for `ConvLSTM2D`.\n\n`ConvLSTM2DCell` is distinct from the `ConvRNN2D` subclass `ConvLSTM2D` in\nthat its `call` method takes the input data of only a single time step and\nreturns the cell's output at the time step, while `ConvLSTM2D` takes the\ninput data over a number of time steps. For example:\n\n```js\nconst filters = 3;\nconst kernelSize = 3;\n\nconst sequenceLength = 1;\nconst size = 5;\nconst channels = 3;\n\nconst inputShape = [sequenceLength, size, size, channels];\nconst input = tf.ones(inputShape);\n\nconst cell = tf.layers.convLstm2dCell({filters, kernelSize});\n\ncell.build(input.shape);\n\nconst outputSize = size - kernelSize + 1;\nconst outShape = [sequenceLength, outputSize, outputSize, filters];\n\nconst initialH = tf.zeros(outShape);\nconst initialC = tf.zeros(outShape);\n\nconst [o, h, c] = cell.call([input, initialH, initialC], {});\n```",
              "fileName": "#1445",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1445-L1447",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.convLstm2dCell",
              "urlHash": "layers.convLstm2dCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "gru",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "number",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "cell",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnSequences",
                  "type": "boolean",
                  "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnState",
                  "type": "boolean",
                  "documentation": "Whether to return the last state in addition to the output.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "goBackwards",
                  "type": "boolean",
                  "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stateful",
                  "type": "boolean",
                  "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unroll",
                  "type": "boolean",
                  "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "number",
                  "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GRU",
              "documentation": "Gated Recurrent Unit - Cho et al. 2014.\n\nThis is an `RNN` layer consisting of one `GRUCell`. However, unlike\nthe underlying `GRUCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.gru({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `GRUCell`'s number of units.",
              "fileName": "#1175",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1175-L1177",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.gru",
              "urlHash": "layers.gru"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "gruCell",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "number",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "resetAfter",
                  "type": "boolean",
                  "documentation": "GRU convention (whether to apply reset gate after or before matrix\nmultiplication). false = \"before\", true = \"after\" (only false is\nsupported).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "units: Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GRUCell",
              "documentation": "Cell class for `GRU`.\n\n`GRUCell` is distinct from the `RNN` subclass `GRU` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `GRU` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.gruCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `GRUCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.gruCell({units: 4}),\n   tf.layers.gruCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `gruCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `GRUCell`, use the\n[tf.layers.gru()](#layers.gru).",
              "fileName": "#1224",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1224-L1226",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.gruCell",
              "urlHash": "layers.gruCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "lstm",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unitForgetBias",
                  "type": "boolean",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "number",
                  "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this config field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "cell",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnSequences",
                  "type": "boolean",
                  "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnState",
                  "type": "boolean",
                  "documentation": "Whether to return the last state in addition to the output.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "goBackwards",
                  "type": "boolean",
                  "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stateful",
                  "type": "boolean",
                  "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unroll",
                  "type": "boolean",
                  "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "number",
                  "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "LSTM",
              "documentation": "Long-Short Term Memory layer - Hochreiter 1997.\n\nThis is an `RNN` layer consisting of one `LSTMCell`. However, unlike\nthe underlying `LSTMCell`, the `apply` method of `LSTM` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst lstm = tf.layers.lstm({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = lstm.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `LSTMCell`'s number of units.",
              "fileName": "#1251",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1251-L1253",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.lstm",
              "urlHash": "layers.lstm"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "lstmCell",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "recurrentActivation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unitForgetBias",
                  "type": "boolean",
                  "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "implementation",
                  "type": "number",
                  "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "units: Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "LSTMCell",
              "documentation": "Cell class for `LSTM`.\n\n`LSTMCell` is distinct from the `RNN` subclass `LSTM` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `LSTM` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.lstmCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `LSTMCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.lstmCell({units: 4}),\n   tf.layers.lstmCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `lstmCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `LSTMCell`, use the\n[tf.layers.lstm()](#layers.lstm).",
              "fileName": "#1300",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1300-L1302",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.lstmCell",
              "urlHash": "layers.lstmCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "rnn",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cell",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnSequences",
                  "type": "boolean",
                  "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnState",
                  "type": "boolean",
                  "documentation": "Whether to return the last state in addition to the output.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "goBackwards",
                  "type": "boolean",
                  "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stateful",
                  "type": "boolean",
                  "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unroll",
                  "type": "boolean",
                  "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "number",
                  "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "RNN",
              "documentation": "Base class for recurrent layers.\n\nInput shape:\n   3D tensor with shape `[batchSize, timeSteps, inputDim]`.\n\nOutput shape:\n   - if `returnState`, an Array of tensors (i.e., [tf.Tensor](#class:Tensor)s). The first\n     tensor is the output. The remaining tensors are the states at the\n     last time step, each with shape `[batchSize, units]`.\n   - if `returnSequences`, the output will have shape\n     `[batchSize, timeSteps, units]`.\n   - else, the output will have shape `[batchSize, units]`.\n\nMasking:\n   This layer supports masking for input data with a variable number\n   of timesteps. To introduce masks to your data,\n   use an embedding layer with the `mask_zero` parameter\n   set to `True`.\n\nNotes on using statefulness in RNNs:\n   You can set RNN layers to be 'stateful', which means that the states\n   computed for the samples in one batch will be reused as initial states\n   for the samples in the next batch. This assumes a one-to-one mapping\n   between samples in different successive batches.\n\n   To enable statefulness:\n     - specify `stateful: true` in the layer constructor.\n     - specify a fixed batch size for your model, by passing\n       if sequential model:\n         `batchInputShape=[...]` to the first layer in your model.\n       else for functional model with 1 or more Input layers:\n         `batchShape=[...]` to all the first layers in your model.\n       This is the expected shape of your inputs *including the batch size*.\n       It should be a tuple of integers, e.g. `(32, 10, 100)`.\n     - specify `shuffle=False` when calling fit().\n\n   To reset the states of your model, call `.resetStates()` on either\n   a specific layer, or on your entire model.\n\nNote on specifying the initial state of RNNs\n   You can specify the initial state of RNN layers symbolically by\n   calling them with the option `initialState`. The value of\n   `initialState` should be a tensor or list of tensors representing\n   the initial state of the RNN layer.\n\n   You can specify the initial state of RNN layers numerically by\n   calling `resetStates` with the keyword argument `states`. The value of\n   `states` should be a numpy array or list of numpy arrays representing\n   the initial state of the RNN layer.\n\nNote on passing external constants to RNNs\n   You can pass \"external\" constants to the cell using the `constants`\n   keyword argument of `RNN.call` method. This requires that the `cell.call`\n   method accepts the same keyword argument `constants`. Such constants\n   can be used to condition the cell transformation on additional static\n   inputs (not changing over time), a.k.a. an attention mechanism.",
              "fileName": "#1509",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1509-L1511",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.rnn",
              "urlHash": "layers.rnn"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "simpleRNN",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the kernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "cell",
                  "type": "[tf.RNNCell](#class:RNNCell)|[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnSequences",
                  "type": "boolean",
                  "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "returnState",
                  "type": "boolean",
                  "documentation": "Whether to return the last state in addition to the output.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "goBackwards",
                  "type": "boolean",
                  "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stateful",
                  "type": "boolean",
                  "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "unroll",
                  "type": "boolean",
                  "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDim",
                  "type": "number",
                  "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputLength",
                  "type": "number",
                  "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "SimpleRNN",
              "documentation": "Fully-connected RNN where the output is to be fed back to input.\n\nThis is an `RNN` layer consisting of one `SimpleRNNCell`. However, unlike\nthe underlying `SimpleRNNCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.simpleRNN({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `SimpleRNNCell`'s number of units.\n```",
              "fileName": "#1328",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1328-L1330",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.simpleRNN",
              "urlHash": "layers.simpleRNN"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "simpleRNNCell",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "units",
                  "type": "number",
                  "documentation": "units: Positive integer, dimensionality of the output space.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "activation",
                  "type": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'",
                  "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "useBias",
                  "type": "boolean",
                  "documentation": "Whether the layer uses a bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasInitializer",
                  "type": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|[tf.initializers.Initializer](#class:initializers.Initializer)",
                  "documentation": "Initializer for the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasRegularizer",
                  "type": "'l1l2'|string|Regularizer",
                  "documentation": "Regularizer function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "kernelConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `kernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "biasConstraint",
                  "type": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|[tf.constraints.Constraint](#class:constraints.Constraint)",
                  "documentation": "Constraint function applied to the bias vector.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "recurrentDropout",
                  "type": "number",
                  "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dropoutFunc",
                  "type": "Function",
                  "documentation": "This is added for test DI purpose.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "SimpleRNNCell",
              "documentation": "Cell class for `SimpleRNN`.\n\n`SimpleRNNCell` is distinct from the `RNN` subclass `SimpleRNN` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `SimpleRNN` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.simpleRNNCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `SimpleRNNCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.simpleRNNCell({units: 4}),\n   tf.layers.simpleRNNCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `SimpleRNNCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `SimpleRNNCell`, use the\n[tf.layers.simpleRNN()](#layers.simpleRNN).",
              "fileName": "#1377",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1377-L1379",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.simpleRNNCell",
              "urlHash": "layers.simpleRNNCell"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Recurrent",
                "namespace": "layers"
              },
              "symbolName": "stackedRNNCells",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cells",
                  "type": "[tf.RNNCell](#class:RNNCell)[]",
                  "documentation": "An `Array` of `RNNCell` instances.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "StackedRNNCells",
              "documentation": "Wrapper allowing a stack of RNN cells to behave as a single cell.\n\nUsed to implement efficient stacked RNNs.",
              "fileName": "#1520",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1520-L1522",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.stackedRNNCells",
              "urlHash": "layers.stackedRNNCells"
            }
          ]
        },
        {
          "name": "Wrapper",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Wrapper",
                "namespace": "layers"
              },
              "symbolName": "bidirectional",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "layer",
                  "type": "RNN",
                  "documentation": "The instance of an `RNN` layer to be wrapped.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "mergeMode",
                  "type": "'sum'|'mul'|'concat'|'ave'",
                  "documentation": "Mode by which outputs of the forward and backward RNNs are\ncombined. If `null` or `undefined`, the output will not be\ncombined, they will be returned as an `Array`.\n\nIf `undefined` (i.e., not provided), defaults to `'concat'`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Bidirectional",
              "documentation": "",
              "fileName": "#1527",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1527-L1529",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.bidirectional",
              "urlHash": "layers.bidirectional"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Wrapper",
                "namespace": "layers"
              },
              "symbolName": "timeDistributed",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "layer",
                  "type": "[tf.layers.Layer](#class:layers.Layer)",
                  "documentation": "The layer to be wrapped.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "TimeDistributed",
              "documentation": "This wrapper applies a layer to every temporal slice of an input.\n\nThe input should be at least 3D,  and the dimension of the index `1` will be\nconsidered to be the temporal dimension.\n\nConsider a batch of 32 samples, where each sample is a sequence of 10 vectors\nof 16 dimensions. The batch input shape of the layer is then `[32,  10,\n16]`, and the `inputShape`, not including the sample dimension, is\n`[10, 16]`.\n\nYou can then use `TimeDistributed` to apply a `Dense` layer to each of the 10\ntimesteps, independently:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.dense({units: 8}),\n   inputShape: [10, 16],\n}));\n\n// Now model.outputShape = [null, 10, 8].\n// The output will then have shape `[32, 10, 8]`.\n\n// In subsequent layers, there is no need for `inputShape`:\nmodel.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: 32})}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n// Now model.outputShape = [null, 10, 32].\n```\n\nThe output will then have shape `[32, 10, 32]`.\n\n`TimeDistributed` can be used with arbitrary layers, not just `Dense`, for\ninstance a `Conv2D` layer.\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.conv2d({filters: 64, kernelSize: [3, 3]}),\n   inputShape: [10, 299, 299, 3],\n}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
              "fileName": "#1577",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1577-L1579",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.timeDistributed",
              "urlHash": "layers.timeDistributed"
            }
          ]
        },
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Classes",
                "namespace": "layers"
              },
              "symbolName": "Layer",
              "namespace": "layers",
              "documentation": "A layer is a grouping of operations and weights that can be composed to\ncreate a [tf.LayersModel](#class:LayersModel).\n\nLayers are constructed by using the functions under the\n[tf.layers](#Layers-Basic) namespace.",
              "fileName": "#405",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L405-L1566",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "apply",
                  "paramStr": "(inputs, kwargs?)",
                  "parameters": [
                    {
                      "name": "inputs",
                      "documentation": "a [tf.Tensor](#class:Tensor) or [tf.SymbolicTensor](#class:SymbolicTensor) or an Array of them.",
                      "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "kwargs",
                      "documentation": "Additional keyword arguments to be passed to `call()`.",
                      "type": "Kwargs",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|[tf.SymbolicTensor](#class:SymbolicTensor)|[tf.SymbolicTensor](#class:SymbolicTensor)[]",
                  "documentation": "Builds or executes a `Layer`'s logic.\n\nWhen called with [tf.Tensor](#class:Tensor)(s), execute the `Layer`'s computation and\nreturn Tensor(s). For example:\n\n```js\nconst denseLayer = tf.layers.dense({\n   units: 1,\n   kernelInitializer: 'zeros',\n   useBias: false\n});\n\n// Invoke the layer's apply() method with a [tf.Tensor](#class:Tensor) (with concrete\n// numeric values).\nconst input = tf.ones([2, 2]);\nconst output = denseLayer.apply(input);\n\n// The output's value is expected to be [[0], [0]], due to the fact that\n// the dense layer has a kernel initialized to all-zeros and does not have\n// a bias.\noutput.print();\n```\n\nWhen called with [tf.SymbolicTensor](#class:SymbolicTensor)(s), this will prepare the layer for\nfuture execution.  This entails internal book-keeping on shapes of\nexpected Tensors, wiring layers together, and initializing weights.\n\nCalling `apply` with [tf.SymbolicTensor](#class:SymbolicTensor)s are typically used during the\nbuilding of non-[tf.Sequential](#class:Sequential) models. For example:\n\n```js\nconst flattenLayer = tf.layers.flatten();\nconst denseLayer = tf.layers.dense({units: 1});\n\n// Use tf.layers.input() to obtain a SymbolicTensor as input to apply().\nconst input = tf.input({shape: [2, 2]});\nconst output1 = flattenLayer.apply(input);\n\n// output1.shape is [null, 4]. The first dimension is the undetermined\n// batch size. The second dimension comes from flattening the [2, 2]\n// shape.\nconsole.log(JSON.stringify(output1.shape));\n\n// The output SymbolicTensor of the flatten layer can be used to call\n// the apply() of the dense layer:\nconst output2 = denseLayer.apply(output1);\n\n// output2.shape is [null, 1]. The first dimension is the undetermined\n// batch size. The second dimension matches the number of units of the\n// dense layer.\nconsole.log(JSON.stringify(output2.shape));\n\n// The input and output can be used to construct a model that consists\n// of the flatten and dense layers.\nconst model = tf.model({inputs: input, outputs: output2});\n```",
                  "fileName": "#947",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L947-L1090",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.apply"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "countParams",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "number",
                  "documentation": "Counts the total number of numbers (e.g., float32, int32) in the\nweights.",
                  "fileName": "#1179",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1179-L1187",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.countParams"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "build",
                  "paramStr": "(inputShape)",
                  "parameters": [
                    {
                      "name": "inputShape",
                      "documentation": "A `Shape` or array of `Shape` (unused).",
                      "type": "(null | number)[]|(null | number)[][]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Creates the layer weights.\n\nMust be implemented on all layers that have weights.\n\nCalled when apply() is called to construct the weights.",
                  "fileName": "#1200",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1200-L1202",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.build"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "getWeights",
                  "paramStr": "(trainableOnly?)",
                  "parameters": [
                    {
                      "name": "trainableOnly",
                      "documentation": "Whether to get the values of only trainable weights.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Returns the current values of the weights of the layer.",
                  "fileName": "#1212",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1212-L1214",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.getWeights"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "setWeights",
                  "paramStr": "(weights)",
                  "parameters": [
                    {
                      "name": "weights",
                      "documentation": "a list of Tensors. The number of arrays and their shape\nmust match number of the dimensions of the weights of the layer (i.e.\nit should match the output of `getWeights`).",
                      "type": "[tf.Tensor](#class:Tensor)[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Sets the weights of the layer, from Tensors.",
                  "fileName": "#1228",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1228-L1260",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.setWeights"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "addWeight",
                  "paramStr": "(name, shape, dtype?, initializer?, regularizer?, trainable?, constraint?, getInitializerFunc?)",
                  "parameters": [
                    {
                      "name": "name",
                      "documentation": "Name of the new weight variable.",
                      "type": "string",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "shape",
                      "documentation": "The shape of the weight.",
                      "type": "(null | number)[]",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "dtype",
                      "documentation": "The dtype of the weight.",
                      "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "initializer",
                      "documentation": "An initializer instance.",
                      "type": "[tf.initializers.Initializer](#class:initializers.Initializer)",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "regularizer",
                      "documentation": "A regularizer instance.",
                      "type": "Regularizer",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "trainable",
                      "documentation": "Whether the weight should be trained via backprop or not\n(assuming that the layer itself is also trainable).",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "constraint",
                      "documentation": "An optional trainable.",
                      "type": "[tf.constraints.Constraint](#class:constraints.Constraint)",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "getInitializerFunc",
                      "documentation": "",
                      "type": "Function",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "LayerVariable",
                  "documentation": "Adds a weight variable to the layer.",
                  "fileName": "#1277",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1277-L1313",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.addWeight"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "addLoss",
                  "paramStr": "(losses)",
                  "parameters": [
                    {
                      "name": "losses",
                      "documentation": "",
                      "type": "RegularizerFn|RegularizerFn[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Add losses to the layer.\n\nThe loss may potentially be conditional on some inputs tensors,\nfor instance activity losses are conditional on the layer's inputs.",
                  "fileName": "#1337",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1337-L1346",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.addLoss"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "computeOutputShape",
                  "paramStr": "(inputShape)",
                  "parameters": [
                    {
                      "name": "inputShape",
                      "documentation": "A shape (tuple of integers) or a list of shape tuples\n(one per output tensor of the layer). Shape tuples can include null for\nfree dimensions, instead of an integer.",
                      "type": "(null | number)[]|(null | number)[][]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "(null | number)[]|(null | number)[][]",
                  "documentation": "Computes the output shape of the layer.\n\nAssumes that the layer will be built to match that input shape provided.",
                  "fileName": "#1359",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1359-L1361",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.computeOutputShape"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "getConfig",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "serialization.ConfigDict",
                  "documentation": "Returns the config of the layer.\n\nA layer config is a TS dictionary (serializable)\ncontaining the configuration of a layer.\nThe same layer can be reinstantiated later\n(without its trained weights) from this configuration.\n\nThe config of a layer does not include connectivity\ninformation, nor the layer class name.  These are handled\nby 'Container' (one layer of abstraction above).\n\nPorting Note: The TS dictionary follows TS naming standards for\nkeys, and uses tfjs-layers type-safe Enums.  Serialization methods\nshould use a helper function to convert to the pythonic storage\nstandard. (see serialization_utils.convertTsToPythonic)",
                  "fileName": "#1486",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1486-L1496",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.getConfig"
                },
                {
                  "docInfo": {
                    "heading": "Models",
                    "subheading": "Classes"
                  },
                  "symbolName": "dispose",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "DisposeResult",
                  "documentation": "Attempt to dispose layer's weights.\n\nThis method decreases the reference count of the Layer object by 1.\n\nA Layer is reference-counted. Its reference count is incremented by 1\nthe first item its `apply()` method is called and when it becomes a part\nof a new `Node` (through calling the `apply()` method on a\n[tf.SymbolicTensor](#class:SymbolicTensor)).\n\nIf the reference count of a Layer becomes 0, all the weights will be\ndisposed and the underlying memory (e.g., the textures allocated in WebGL)\nwill be freed.\n\nNote: If the reference count is greater than 0 after the decrement, the\nweights of the Layer will *not* be disposed.\n\nAfter a Layer is disposed, it cannot be used in calls such as `apply()`,\n`getWeights()` or `setWeights()` anymore.",
                  "fileName": "#1544",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1544-L1565",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.layers.Layer.dispose"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "serialization.Serializable",
              "displayName": "tf.layers.Layer",
              "urlHash": "class:layers.Layer"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Classes"
              },
              "symbolName": "RNNCell",
              "documentation": "An RNNCell layer.",
              "fileName": "#861",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/layers/recurrent.ts#L861-L871",
              "methods": [],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "[tf.layers.Layer](#class:layers.Layer)",
              "displayName": "tf.RNNCell",
              "urlHash": "class:RNNCell"
            }
          ]
        },
        {
          "name": "Inputs",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Inputs",
                "namespace": "layers"
              },
              "symbolName": "inputLayer",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "Input shape, not including the batch axis.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "Optional input batch size (integer or null).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "Batch input shape, including the batch axis.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Datatype of the input.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "sparse",
                  "type": "boolean",
                  "documentation": "Whether the placeholder created is meant to be sparse.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name of the layer.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "InputLayer",
              "documentation": "An input layer is an entry point into a [tf.LayersModel](#class:LayersModel).\n\n`InputLayer` is generated automatically for [tf.Sequential](#class:Sequential) models by\nspecifying the `inputshape` or `batchInputShape` for the first layer.  It\nshould not be specified explicitly. However, it can be useful sometimes,\ne.g., when constructing a sequential model from a subset of another\nsequential model's layers. Like the code snippet below shows.\n\n```js\n// Define a model which simply adds two inputs.\nconst model1 = tf.sequential();\nmodel1.add(tf.layers.dense({inputShape: [4], units: 3, activation: 'relu'}));\nmodel1.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\nmodel1.summary();\nmodel1.predict(tf.zeros([1, 4])).print();\n\n// Construct another model, reusing the second layer of `model1` while\n// not using the first layer of `model1`. Note that you cannot add the second\n// layer of `model` directly as the first layer of the new sequential model,\n// because doing so will lead to an error related to the fact that the layer\n// is not an input layer. Instead, you need to create an `inputLayer` and add\n// it to the new sequential model before adding the reused layer.\nconst model2 = tf.sequential();\n// Use an inputShape that matches the input shape of `model1`'s second\n// layer.\nmodel2.add(tf.layers.inputLayer({inputShape: [3]}));\nmodel2.add(model1.layers[1]);\nmodel2.summary();\nmodel2.predict(tf.zeros([1, 3])).print();\n```",
              "fileName": "#72",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L72-L74",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.inputLayer",
              "urlHash": "layers.inputLayer"
            }
          ]
        },
        {
          "name": "Padding",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Padding",
                "namespace": "layers"
              },
              "symbolName": "zeroPadding2d",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "padding",
                  "type": "number|[number, number]|[[number, number], [number, number]]",
                  "documentation": "Integer, or `Array` of 2 integers, or `Array` of 2 `Array`s, each of\nwhich is an `Array` of 2 integers.\n- If integer, the same symmetric padding is applied to width and height.\n- If `Array` of 2 integers, interpreted as two different symmetric values\n   for height and width:\n   `[symmetricHeightPad, symmetricWidthPad]`.\n- If `Array` of 2 `Array`s, interpreted as:\n   `[[topPad, bottomPad], [leftPad, rightPad]]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dataFormat",
                  "type": "'channelsFirst'|'channelsLast'",
                  "documentation": "One of `'channelsLast'` (default) and `'channelsFirst'`.\n\nThe ordering of the dimensions in the inputs.\n`channelsLast` corresponds to inputs with shape\n`[batch, height, width, channels]` while `channelsFirst`\ncorresponds to inputs with shape\n`[batch, channels, height, width]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "ZeroPadding2D",
              "documentation": "Zero-padding layer for 2D input (e.g., image).\n\nThis layer can add rows and columns of zeros\nat the top, bottom, left and right side of an image tensor.\n\nInput shape:\n   4D tensor with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, rows, cols, channels]`\n   - If `data_format` is `\"channels_first\"`:\n     `[batch, channels, rows, cols]`.\n\nOutput shape:\n   4D with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, paddedRows, paddedCols, channels]`\n    - If `dataFormat` is `\"channelsFirst\"`:\n     `[batch, channels, paddedRows, paddedCols]`.",
              "fileName": "#928",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L928-L930",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.zeroPadding2d",
              "urlHash": "layers.zeroPadding2d"
            }
          ]
        },
        {
          "name": "Noise",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Noise",
                "namespace": "layers"
              },
              "symbolName": "alphaDropout",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "type": "number",
                  "documentation": "drop probability.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "noiseShape",
                  "type": "(null | number)[]",
                  "documentation": "A 1-D `Tensor` of type `int32`, representing the\nshape for randomly generated keep/drop flags.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "AlphaDropout",
              "documentation": "Applies Alpha Dropout to the input.\n\nAs it is a regularization layer, it is only active at training time.\n\nAlpha Dropout is a `Dropout` that keeps mean and variance of inputs\nto their original values, in order to ensure the self-normalizing property\neven after this dropout.\nAlpha Dropout fits well to Scaled Exponential Linear Units\nby randomly setting activations to the negative saturation value.\n\nArguments:\n   - `rate`: float, drop probability (as with `Dropout`).\n     The multiplicative noise will have\n     standard deviation `sqrt(rate / (1 - rate))`.\n   - `noise_shape`: A 1-D `Tensor` of type `int32`, representing the\n     shape for randomly generated keep/drop flags.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)",
              "fileName": "#1675",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1675-L1677",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.alphaDropout",
              "urlHash": "layers.alphaDropout"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Noise",
                "namespace": "layers"
              },
              "symbolName": "gaussianDropout",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "type": "number",
                  "documentation": "drop probability.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GaussianDropout",
              "documentation": "Apply multiplicative 1-centered Gaussian noise.\n\nAs it is a regularization layer, it is only active at training time.\n\nArguments:\n   - `rate`: float, drop probability (as with `Dropout`).\n     The multiplicative noise will have\n     standard deviation `sqrt(rate / (1 - rate))`.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting](\n      http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
              "fileName": "#1640",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1640-L1642",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.gaussianDropout",
              "urlHash": "layers.gaussianDropout"
            },
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Noise",
                "namespace": "layers"
              },
              "symbolName": "gaussianNoise",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stddev",
                  "type": "number",
                  "documentation": "Standard Deviation.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "GaussianNoise",
              "documentation": "Apply additive zero-centered Gaussian noise.\n\nAs it is a regularization layer, it is only active at training time.\n\nThis is useful to mitigate overfitting\n(you could see it as a form of random data augmentation).\nGaussian Noise (GS) is a natural choice as corruption process\nfor real valued inputs.\n\n# Arguments\nstddev: float, standard deviation of the noise distribution.\n\n# Input shape\nArbitrary. Use the keyword argument `input_shape`\n(tuple of integers, does not include the samples axis)\nwhen using this layer as the first layer in a model.\n\n# Output shape\nSame shape as input.",
              "fileName": "#1612",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1612-L1614",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.gaussianNoise",
              "urlHash": "layers.gaussianNoise"
            }
          ]
        },
        {
          "name": "Mask",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Mask",
                "namespace": "layers"
              },
              "symbolName": "masking",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "maskValue",
                  "type": "number",
                  "documentation": "Masking Value. Defaults to `0.0`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Masking",
              "documentation": "Masks a sequence by using a mask value to skip timesteps.\n\nIf all features for a given sample timestep are equal to `mask_value`,\nthen the sample timestep will be masked (skipped) in all downstream layers\n(as long as they support masking).\n\nIf any downstream layer does not support masking yet receives such\nan input mask, an exception will be raised.\n\nArguments:\n   - `maskValue`: Either None or mask value to skip.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.",
              "fileName": "#1702",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1702-L1704",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.masking",
              "urlHash": "layers.masking"
            }
          ]
        },
        {
          "name": "Rescaling",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Rescaling",
                "namespace": "layers"
              },
              "symbolName": "rescaling",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scale",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "offset",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Rescaling",
              "documentation": "A preprocessing layer which rescales input values to a new range.\n\nThis layer rescales every value of an input (often an image) by multiplying\nby `scale` and adding `offset`.\n\nFor instance:\n1. To rescale an input in the ``[0, 255]`` range\nto be in the `[0, 1]` range, you would pass `scale=1/255`.\n2. To rescale an input in the ``[0, 255]`` range to be in the `[-1, 1]`\nrange, you would pass `scale=1./127.5, offset=-1`.\nThe rescaling is applied both during training and inference. Inputs can be\nof integer or floating point dtype, and by default the layer will output\nfloats.\n\nArguments:\n   - `scale`: Float, the scale to apply to the inputs.\n   - `offset`: Float, the offset to apply to the inputs.\n\nInput shape:\n   Arbitrary.\n\nOutput shape:\n   Same as input.",
              "fileName": "#1733",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1733-L1735",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.rescaling",
              "urlHash": "layers.rescaling"
            }
          ]
        },
        {
          "name": "CenterCrop",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "CenterCrop",
                "namespace": "layers"
              },
              "symbolName": "centerCrop",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "height",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "width",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "CenterCrop",
              "documentation": "A preprocessing layer which center crops images.\n\n  This layers crops the central portion of the images to a target size. If an\n  image is smaller than the target size, it will be resized and cropped so as\n  to return the largest possible window in the image that matches the target\n  aspect ratio.\n\n  Input pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\n  of integer or floating point dtype.\n\n  If the input height/width is even and the target height/width is odd (or\n  inversely), the input image is left-padded by 1 pixel.\n\n  Arguments:\n    `height`: Integer, the height of the output shape.\n    `width`: Integer, the width of the output shape.\n\n  Input shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `channelsLast` format.\n\n  Output shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., targetHeight, targetWidth, channels)`.",
              "fileName": "#1766",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1766-L1768",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.centerCrop",
              "urlHash": "layers.centerCrop"
            }
          ]
        },
        {
          "name": "Resizing",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Resizing",
                "namespace": "layers"
              },
              "symbolName": "resizing",
              "namespace": "layers",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "height",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "width",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "interpolation",
                  "type": "InterpolationType",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "cropToAspectRatio",
                  "type": "boolean",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Resizing",
              "documentation": "A preprocessing layer which resizes images.\nThis layer resizes an image input to a target height and width. The input\nshould be a 4D (batched) or 3D (unbatched) tensor in `\"channels_last\"`\nformat.  Input pixel values can be of any range (e.g. `[0., 1.)` or `[0,\n255]`) and of interger or floating point dtype. By default, the layer will\noutput floats.\n\nArguments:\n   - `height`: number, the height for the output tensor.\n   - `width`: number, the width for the output tensor.\n   - `interpolation`: string, the method for image resizing interpolation.\n   - `cropToAspectRatio`: boolean, whether to keep image aspect ratio.\n\nInput shape:\n   Arbitrary.\n\nOutput shape:\n   height, width, num channels.",
              "fileName": "#1792",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1792-L1794",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.resizing",
              "urlHash": "layers.resizing"
            }
          ]
        },
        {
          "name": "CategoryEncoding",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "CategoryEncoding",
                "namespace": "layers"
              },
              "symbolName": "categoryEncoding",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numTokens",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "outputMode",
                  "type": "OutputMode",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "CategoryEncoding",
              "documentation": "A preprocessing layer which encodes integer features.\n\nThis layer provides options for condensing data into a categorical encoding\nwhen the total number of tokens are known in advance. It accepts integer\nvalues as inputs, and it outputs a dense representation of those\ninputs.\n\nArguments:\n\nnumTokens: The total number of tokens the layer should support. All\n  inputs to the layer must integers in the range `0 <= value <\n  numTokens`, or an error will be thrown.\n\noutputMode: Specification for the output of the layer.\n  Defaults to `multiHot`. Values can be `oneHot`, `multiHot` or\n  `count`, configuring the layer as follows:\n\n    oneHot: Encodes each individual element in the input into an\n      array of `numTokens` size, containing a 1 at the element index. If\n      the last dimension is size 1, will encode on that dimension. If the\n      last dimension is not size 1, will append a new dimension for the\n      encoded output.\n\n    multiHot: Encodes each sample in the input into a single array\n     of `numTokens` size, containing a 1 for each vocabulary term\n     present in the sample. Treats the last dimension as the sample\n     dimension, if input shape is `(..., sampleLength)`, output shape\n     will be `(..., numTokens)`.\n\n    count: Like `multiHot`, but the int array contains a count of\n     the number of times the token at that index appeared in the sample.\n\n  For all output modes, currently only output up to rank 2 is supported.\n   Call arguments:\n    inputs: A 1D or 2D tensor of integer inputs.\n    countWeights: A tensor in the same shape as `inputs` indicating the\n    weight for each sample value when summing up in `count` mode. Not used\n    in `multiHot` or `oneHot` modes.",
              "fileName": "#1839",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1839-L1841",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.categoryEncoding",
              "urlHash": "layers.categoryEncoding"
            }
          ]
        },
        {
          "name": "RandomWidth",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "RandomWidth",
                "namespace": "layers"
              },
              "symbolName": "randomWidth",
              "namespace": "layers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "factor",
                  "type": "number | [number, number]",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "interpolation",
                  "type": "InterpolationType",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "autoVectorize",
                  "type": "boolean",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchInputShape",
                  "type": "(null | number)[]",
                  "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "batchSize",
                  "type": "number",
                  "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "dtype",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "name",
                  "type": "string",
                  "documentation": "Name for this layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "trainable",
                  "type": "boolean",
                  "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "weights",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "documentation": "Initial weight values of the layer.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "inputDType",
                  "type": "'float32'|'int32'|'bool'|'complex64'|'string'",
                  "documentation": "Legacy support. Do not use for new code.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "RandomWidth",
              "documentation": "A preprocessing layer which randomly varies image width during training.\n\nThis layer will randomly adjusts the width of a batch of images of a batch\nof images by a random factor.\n\nThe input should be a 3D (unbatched) or 4D (batched) tensor in\nthe `\"channels_last\"` image data format. Input pixel values can be of any\nrange (e.g. `[0., 1.)` or `[0, 255]`) and of integer or floating point\ndtype. By default, the layer will output floats. By default, this layer is\ninactive during inference. For an overview and full list of preprocessing\nlayers, see the preprocessing [guide]\n(https://www.tensorflow.org/guide/keras/preprocessing_layers).\n\nArguments:\n\nfactor:\n   A positive float (fraction of original width), or a tuple of size 2\n   representing lower and upper bound for resizing vertically.\n   When represented as a single float, this value is used for both the upper\n   and lower bound. For instance, `factor=(0.2, 0.3)` results in an output\n   with width changed by a random amount in the range `[20%, 30%]`.\n   `factor=(-0.2, 0.3)` results in an output with width changed by a random\n   amount in the range `[-20%, +30%]`. `factor=0.2` results in an output\n   with width changed by a random amount in the range `[-20%, +20%]`.\ninterpolation:\n   String, the interpolation method.\n   Defaults to `bilinear`.\n   Supports `\"bilinear\"`, `\"nearest\"`.\n   The tf methods `\"bicubic\"`, `\"area\"`, `\"lanczos3\"`, `\"lanczos5\"`,\n   `\"gaussian\"`, `\"mitchellcubic\"` are unimplemented in tfjs.\nseed:\n   Integer. Used to create a random seed.\n\nInput shape:\n     3D (unbatched) or 4D (batched) tensor with shape:\n     `(..., height, width, channels)`, in `\"channels_last\"` format.\nOutput shape:\n     3D (unbatched) or 4D (batched) tensor with shape:\n     `(..., height, random_width, channels)`.",
              "fileName": "#1887",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1887-L1889",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.layers.randomWidth",
              "urlHash": "layers.randomWidth"
            }
          ]
        }
      ]
    },
    {
      "name": "Operations",
      "description": "",
      "subheadings": [
        {
          "name": "Arithmetic",
          "description": "<p>To perform mathematical computation on Tensors, we use\noperations. Tensors are immutable, so all operations always return\nnew Tensors and never modify input Tensors.</p>",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "add",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first [tf.Tensor](#class:Tensor) to add.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second [tf.Tensor](#class:Tensor) to add. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Adds two [tf.Tensor](#class:Tensor)s element-wise, A + B. Supports broadcasting.\n\n\n```js\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.tensor1d([10, 20, 30, 40]);\n\na.add(b).print();  // or tf.add(a, b)\n```\n\n```js\n// Broadcast add a with b.\nconst a = tf.scalar(5);\nconst b = tf.tensor1d([10, 20, 30, 40]);\n\na.add(b).print();  // or tf.add(a, b)\n```",
              "fileName": "#50",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/add.ts#L50-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.add",
              "urlHash": "add"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "sub",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first [tf.Tensor](#class:Tensor) to subtract from.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second [tf.Tensor](#class:Tensor) to be subtracted. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Subtracts two [tf.Tensor](#class:Tensor)s element-wise, A - B. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([10, 20, 30, 40]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\n\na.sub(b).print();  // or tf.sub(a, b)\n```\n\n```js\n// Broadcast subtract a with b.\nconst a = tf.tensor1d([10, 20, 30, 40]);\nconst b = tf.scalar(5);\n\na.sub(b).print();  // or tf.sub(a, b)\n```",
              "fileName": "#50",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sub.ts#L50-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sub",
              "urlHash": "sub"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "mul",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor to multiply.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor to multiply. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Multiplies two [tf.Tensor](#class:Tensor)s element-wise, A * B. Supports broadcasting.\n\nWe also expose `tf.mulStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.tensor1d([2, 3, 4, 5]);\n\na.mul(b).print();  // or tf.mul(a, b)\n```\n\n```js\n// Broadcast mul a with b.\nconst a = tf.tensor1d([1, 2, 3, 4]);\nconst b = tf.scalar(5);\n\na.mul(b).print();  // or tf.mul(a, b)\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/mul.ts#L53-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.mul",
              "urlHash": "mul"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "div",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor as the numerator.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor as the denominator. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Divides two [tf.Tensor](#class:Tensor)s element-wise, A / B. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 4, 9, 16]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\n\na.div(b).print();  // or tf.div(a, b)\n```\n\n```js\n// Broadcast div a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(2);\n\na.div(b).print();  // or tf.div(a, b)\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/div.ts#L53-L68",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.div",
              "urlHash": "div"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "addN",
              "paramStr": "(tensors)",
              "parameters": [
                {
                  "name": "tensors",
                  "documentation": "A list of tensors with the same shape and dtype.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Adds a list of [tf.Tensor](#class:Tensor)s element-wise, each with the same shape and dtype.\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor1d([3, 4]);\nconst c = tf.tensor1d([5, 6]);\n\ntf.addN([a, b, c]).print();\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/add_n.ts#L40-L70",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.addN",
              "urlHash": "addN"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "divNoNan",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor as the numerator.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor as the denominator. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Divides two [tf.Tensor](#class:Tensor)s element-wise, A / B. Supports broadcasting. Return 0\nif denominator is 0.\n\n\n```js\nconst a = tf.tensor1d([1, 4, 9, 16]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\nconst c = tf.tensor1d([0, 0, 0, 0]);\n\na.divNoNan(b).print();  // or tf.divNoNan(a, b)\na.divNoNan(c).print();  // or tf.divNoNan(a, c)\n```\n\n```js\n// Broadcast div a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(2);\nconst c = tf.scalar(0);\n\na.divNoNan(b).print();  // or tf.divNoNan(a, b)\na.divNoNan(c).print();  // or tf.divNoNan(a, c)\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/div_no_nan.ts#L59-L70",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.divNoNan",
              "urlHash": "divNoNan"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "floorDiv",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor as the numerator.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor as the denominator. Must have the same dtype as\n`a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Divides two [tf.Tensor](#class:Tensor)s element-wise, A / B. Supports broadcasting.\nThe result is rounded with floor function.\n\n\n```js\nconst a = tf.tensor1d([1, 4, 9, 16]);\nconst b = tf.tensor1d([1, 2, 3, 4]);\n\na.floorDiv(b).print();  // or tf.div(a, b)\n```\n\n```js\n// Broadcast div a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(2);\n\na.floorDiv(b).print();  // or tf.floorDiv(a, b)\n```",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/floorDiv.ts#L54-L63",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.floorDiv",
              "urlHash": "floorDiv"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "maximum",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the max of a and b (`a > b ? a : b`) element-wise.\nSupports broadcasting.\n\nWe also expose `tf.maximumStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.maximum(b).print();  // or tf.maximum(a, b)\n```\n\n```js\n// Broadcast maximum a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.maximum(b).print();  // or tf.maximum(a, b)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/maximum.ts#L57-L72",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.maximum",
              "urlHash": "maximum"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "minimum",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the min of a and b (`a < b ? a : b`) element-wise.\nSupports broadcasting.\n\nWe also expose `minimumStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.minimum(b).print();  // or tf.minimum(a, b)\n```\n\n```js\n// Broadcast minimum a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.minimum(b).print();  // or tf.minimum(a, b)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/minimum.ts#L57-L73",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.minimum",
              "urlHash": "minimum"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "mod",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the mod of a and b element-wise.\n`floor(x / y) * y + mod(x, y) = x`\nSupports broadcasting.\n\nWe also expose `tf.modStrict` which has the same signature as this op and\nasserts that `a` and `b` are the same shape (does not broadcast).\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.mod(b).print();  // or tf.mod(a, b)\n```\n\n```js\n// Broadcast a mod b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.mod(b).print();  // or tf.mod(a, b)\n```",
              "fileName": "#56",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/mod.ts#L56-L64",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.mod",
              "urlHash": "mod"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "pow",
              "paramStr": "(base, exp)",
              "parameters": [
                {
                  "name": "base",
                  "documentation": "The base [tf.Tensor](#class:Tensor) to pow element-wise.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "exp",
                  "documentation": "The exponent [tf.Tensor](#class:Tensor) to pow element-wise.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the power of one [tf.Tensor](#class:Tensor) to another. Supports broadcasting.\n\nGiven a [tf.Tensor](#class:Tensor) x and a [tf.Tensor](#class:Tensor) y, this operation computes x^y for\ncorresponding elements in x and y. The result's dtype will be the upcasted\ntype of the `base` and `exp` dtypes.\n\n```js\nconst a = tf.tensor([[2, 3], [4, 5]])\nconst b = tf.tensor([[1, 2], [3, 0]]).toInt();\n\na.pow(b).print();  // or tf.pow(a, b)\n```\n\n```js\nconst a = tf.tensor([[1, 2], [3, 4]])\nconst b = tf.tensor(2).toInt();\n\na.pow(b).print();  // or tf.pow(a, b)\n```\nWe also expose `powStrict` which has the same signature as this op and\nasserts that `base` and `exp` are the same shape (does not broadcast).",
              "fileName": "#55",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/pow.ts#L55-L64",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.pow",
              "urlHash": "pow"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Arithmetic"
              },
              "symbolName": "squaredDifference",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same type as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns (a - b) * (a - b) element-wise.\nSupports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 4, 3, 16]);\nconst b = tf.tensor1d([1, 2, 9, 4]);\n\na.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n```\n\n```js\n// Broadcast squared difference  a with b.\nconst a = tf.tensor1d([2, 4, 6, 8]);\nconst b = tf.scalar(5);\n\na.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/squared_difference.ts#L53-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.squaredDifference",
              "urlHash": "squaredDifference"
            }
          ]
        },
        {
          "name": "Basic math",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "abs",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input [tf.Tensor](#class:Tensor).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes absolute value element-wise: `abs(x)`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.abs().print();  // or tf.abs(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/abs.ts#L39-L49",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.abs",
              "urlHash": "abs"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "acos",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes acos of the input [tf.Tensor](#class:Tensor) element-wise: `acos(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.acos().print();  // or tf.acos(x)\n```",
              "fileName": "#37",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/acos.ts#L37-L42",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.acos",
              "urlHash": "acos"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "acosh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the inverse hyperbolic cos of the input [tf.Tensor](#class:Tensor) element-wise:\n`acosh(x)`\n\n```js\nconst x = tf.tensor1d([10, 1, 3, 5.7]);\n\nx.acosh().print();  // or tf.acosh(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/acosh.ts#L40-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.acosh",
              "urlHash": "acosh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "asin",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes asin of the input [tf.Tensor](#class:Tensor) element-wise: `asin(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.asin().print();  // or tf.asin(x)\n```",
              "fileName": "#38",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/asin.ts#L38-L43",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.asin",
              "urlHash": "asin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "asinh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes inverse hyperbolic sin of the input [tf.Tensor](#class:Tensor) element-wise:\n`asinh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.asinh().print();  // or tf.asinh(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/asinh.ts#L40-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.asinh",
              "urlHash": "asinh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "atan",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes atan of the input [tf.Tensor](#class:Tensor) element-wise: `atan(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.atan().print();  // or tf.atan(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/atan.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.atan",
              "urlHash": "atan"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "atan2",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes arctangent of [tf.Tensor](#class:Tensor)s a / b element-wise: `atan2(a, b)`.\nSupports broadcasting.\n\n```js\nconst a = tf.tensor1d([1.0, 1.0, -1.0, .7]);\nconst b = tf.tensor1d([2.0, 13.0, 3.5, .21]);\n\ntf.atan2(a, b).print()\n```",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/atan2.ts#L44-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.atan2",
              "urlHash": "atan2"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "atanh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes inverse hyperbolic tan of the input [tf.Tensor](#class:Tensor) element-wise:\n`atanh(x)`\n\n```js\nconst x = tf.tensor1d([0, .1, -.1, .7]);\n\nx.atanh().print();  // or tf.atanh(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/atanh.ts#L40-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.atanh",
              "urlHash": "atanh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "ceil",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes ceiling of input [tf.Tensor](#class:Tensor) element-wise: `ceil(x)`\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3]);\n\nx.ceil().print();  // or tf.ceil(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/ceil.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.ceil",
              "urlHash": "ceil"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "clipByValue",
              "paramStr": "(x, clipValueMin, clipValueMax)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "clipValueMin",
                  "documentation": "Lower bound of range to be clipped to.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "clipValueMax",
                  "documentation": "Upper bound of range to be clipped to.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Clips values element-wise. `max(min(x, clipValueMax), clipValueMin)`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/clip_by_value.ts#L43-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.clipByValue",
              "urlHash": "clipByValue"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "cos",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be float32 type.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes cos of the input [tf.Tensor](#class:Tensor) element-wise: `cos(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.cos().print();  // or tf.cos(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/cos.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.cos",
              "urlHash": "cos"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "cosh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be float32 type.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic cos of the input [tf.Tensor](#class:Tensor) element-wise: `cosh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.cosh().print();  // or tf.cosh(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/cosh.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.cosh",
              "urlHash": "cosh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "elu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential linear element-wise: `x > 0 ? x : (e ^ x) - 1`.\n\n```js\nconst x = tf.tensor1d([-1, 1, -3, 2]);\n\nx.elu().print();  // or tf.elu(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/elu.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.elu",
              "urlHash": "elu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "erf",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes Gauss error function of the input [tf.Tensor](#class:Tensor) element-wise:\n`erf(x)`\n\n```js\nconst x = tf.tensor1d([0, .1, -.1, .7]);\n\nx.erf().print(); // or tf.erf(x);\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/erf.ts#L42-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.erf",
              "urlHash": "erf"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "exp",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential of the input [tf.Tensor](#class:Tensor) element-wise. `e ^ x`\n\n```js\nconst x = tf.tensor1d([1, 2, -3]);\n\nx.exp().print();  // or tf.exp(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/exp.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.exp",
              "urlHash": "exp"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "expm1",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes exponential of the input [tf.Tensor](#class:Tensor) minus one element-wise.\n`e ^ x - 1`\n\n```js\nconst x = tf.tensor1d([1, 2, -3]);\n\nx.expm1().print();  // or tf.expm1(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/expm1.ts#L40-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.expm1",
              "urlHash": "expm1"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "floor",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes floor of input [tf.Tensor](#class:Tensor) element-wise: `floor(x)`.\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3]);\n\nx.floor().print();  // or tf.floor(x)\n```",
              "fileName": "#38",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/floor.ts#L38-L43",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.floor",
              "urlHash": "floor"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "isFinite",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns which elements of x are finite.\n\n```js\nconst x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n\nx.isFinite().print();  // or tf.isNaN(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/is_finite.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.isFinite",
              "urlHash": "isFinite"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "isInf",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns which elements of x are Infinity or -Infinity.\n\n```js\nconst x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n\nx.isInf().print();  // or tf.isNaN(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/is_inf.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.isInf",
              "urlHash": "isInf"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "isNaN",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns which elements of x are NaN.\n\n```js\nconst x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n\nx.isNaN().print();  // or tf.isNaN(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/is_nan.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.isNaN",
              "urlHash": "isNaN"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "leakyRelu",
              "paramStr": "(x, alpha?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "The scaling factor for negative values, defaults to 0.2.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes leaky rectified linear element-wise.\n\nSee\n[http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](\n     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)\n```",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/leaky_relu.ts#L45-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.leakyRelu",
              "urlHash": "leakyRelu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "log",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes natural logarithm of the input [tf.Tensor](#class:Tensor) element-wise: `ln(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.E]);\n\nx.log().print();  // or tf.log(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/log.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.log",
              "urlHash": "log"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "log1p",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes natural logarithm of the input [tf.Tensor](#class:Tensor) plus one\nelement-wise: `ln(1 + x)`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.E - 1]);\n\nx.log1p().print();  // or tf.log1p(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/log1p.ts#L40-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.log1p",
              "urlHash": "log1p"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "logSigmoid",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes log sigmoid of the input [tf.Tensor](#class:Tensor) element-wise:\n`logSigmoid(x)`. For numerical stability, we use `-tf.softplus(-x)`.\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.logSigmoid().print();  // or tf.logSigmoid(x)\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/log_sigmoid.ts#L42-L62",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logSigmoid",
              "urlHash": "logSigmoid"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "neg",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes `-1 * x` element-wise.\n\n```js\nconst x = tf.tensor2d([1, 2, -2, 0], [2, 2]);\n\nx.neg().print();  // or tf.neg(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/neg.ts#L40-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.neg",
              "urlHash": "neg"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "prelu",
              "paramStr": "(x, alpha)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "Scaling factor for negative values.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes leaky rectified linear element-wise with parametric alphas.\n\n`x < 0 ? alpha * x : f(x) = x`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\nconst alpha = tf.scalar(0.1);\n\nx.prelu(alpha).print();  // or tf.prelu(x, alpha)\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/prelu.ts#L43-L49",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.prelu",
              "urlHash": "prelu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "reciprocal",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes reciprocal of x element-wise: `1 / x`\n\n```js\nconst x = tf.tensor1d([0, 1, 2]);\n\nx.reciprocal().print();  // or tf.reciprocal(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/reciprocal.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.reciprocal",
              "urlHash": "reciprocal"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "relu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. If the dtype is `bool`, the output dtype will be\n`int32`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes rectified linear element-wise: `max(x, 0)`.\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.relu().print();  // or tf.relu(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/relu.ts#L40-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.relu",
              "urlHash": "relu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "relu6",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. If the dtype is `bool`, the output dtype will be\n`int32`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 8]);\n\nx.relu6().print();  // or tf.relu6(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/relu6.ts#L40-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.relu6",
              "urlHash": "relu6"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "round",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes round of input [tf.Tensor](#class:Tensor) element-wise: `round(x)`.\nIt implements banker's rounding.\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3]);\n\nx.round().print();  // or tf.round(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/round.ts#L40-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.round",
              "urlHash": "round"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "rsqrt",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes reciprocal of square root of the input [tf.Tensor](#class:Tensor) element-wise:\n`y = 1 / sqrt(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, 4, -1]);\n\nx.rsqrt().print();  // or tf.rsqrt(x)\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/rsqrt.ts#L40-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.rsqrt",
              "urlHash": "rsqrt"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "selu",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes scaled exponential linear element-wise.\n\n`x < 0 ? scale * alpha * (exp(x) - 1) : scale * x`\n\n```js\nconst x = tf.tensor1d([-1, 2, -3, 4]);\n\nx.selu().print();  // or tf.selu(x)\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/selu.ts#L41-L47",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.selu",
              "urlHash": "selu"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sigmoid",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes sigmoid element-wise, `1 / (1 + exp(-x))`\n\n```js\nconst x = tf.tensor1d([0, -1, 2, -3]);\n\nx.sigmoid().print();  // or tf.sigmoid(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sigmoid.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sigmoid",
              "urlHash": "sigmoid"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sign",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns an element-wise indication of the sign of a number.\n\n```js\nconst x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);\n\nx.sign().print();  // or tf.sign(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sign.ts#L39-L43",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sign",
              "urlHash": "sign"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sin",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes sin of the input Tensor element-wise: `sin(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.sin().print();  // or tf.sin(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sin.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sin",
              "urlHash": "sin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sinh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic sin of the input [tf.Tensor](#class:Tensor) element-wise: `sinh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.sinh().print();  // or tf.sinh(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sinh.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sinh",
              "urlHash": "sinh"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "softplus",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes softplus of the input [tf.Tensor](#class:Tensor) element-wise: `log(exp(x) + 1)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, .7]);\n\nx.softplus().print();  // or tf.softplus(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/softplus.ts#L39-L44",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.softplus",
              "urlHash": "softplus"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "sqrt",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes square root of the input [tf.Tensor](#class:Tensor) element-wise: `y = sqrt(x)`\n\n```js\nconst x = tf.tensor1d([1, 2, 4, -1]);\n\nx.sqrt().print();  // or tf.sqrt(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sqrt.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sqrt",
              "urlHash": "sqrt"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "square",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes square of `x` element-wise: `x ^ 2`\n\n```js\nconst x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);\n\nx.square().print();  // or tf.square(x)\n```",
              "fileName": "#36",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/square.ts#L36-L40",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.square",
              "urlHash": "square"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "step",
              "paramStr": "(x, alpha?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "The gradient when input is negative. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes step of the input [tf.Tensor](#class:Tensor) element-wise: `x > 0 ? 1 : alpha`\n\n```js\nconst x = tf.tensor1d([0, 2, -1, -3]);\n\nx.step(.5).print();  // or tf.step(x, .5)\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/step.ts#L41-L50",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.step",
              "urlHash": "step"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "tan",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes tan of the input [tf.Tensor](#class:Tensor) element-wise, `tan(x)`\n\n```js\nconst x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n\nx.tan().print();  // or tf.tan(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tan.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tan",
              "urlHash": "tan"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Basic math"
              },
              "symbolName": "tanh",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes hyperbolic tangent of the input [tf.Tensor](#class:Tensor) element-wise: `tanh(x)`\n\n```js\nconst x = tf.tensor1d([0, 1, -1, 70]);\n\nx.tanh().print();  // or tf.tanh(x)\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tanh.ts#L39-L45",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tanh",
              "urlHash": "tanh"
            }
          ]
        },
        {
          "name": "Matrices",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "dot",
              "paramStr": "(t1, t2)",
              "parameters": [
                {
                  "name": "t1",
                  "documentation": "The first tensor in the dot operation.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "t2",
                  "documentation": "The second tensor in the dot operation.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the dot product of two matrices and/or vectors, `t1` and `t2`.\n\n```js\nconst a = tf.tensor1d([1, 2]);\nconst b = tf.tensor2d([[1, 2], [3, 4]]);\nconst c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\n\na.dot(b).print();  // or tf.dot(a, b)\nb.dot(a).print();\nb.dot(c).print();\n```",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/dot.ts#L44-L80",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.dot",
              "urlHash": "dot"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "euclideanNorm",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input array.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Optional. If axis is null (the default), the input is\nconsidered a vector and a single vector norm is computed over the entire\nset of values in the Tensor, i.e. euclideanNorm(x) is equivalent\nto euclideanNorm(x.reshape([-1])). If axis is an integer, the input\nis considered a batch of vectors, and axis determines the axis in x\nover which to compute vector norms. If axis is a 2-tuple of integer it is\nconsidered a batch of matrices and axis determines the axes in NDArray\nover which to compute a matrix norm.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "Optional. If true, the norm has the same dimensionality\nas the input.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the Euclidean norm of scalar, vectors, and matrices.\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.euclideanNorm().print();  // or tf.euclideanNorm(x)\n```",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/euclidean_norm.ts#L47-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.euclideanNorm",
              "urlHash": "euclideanNorm"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "matMul",
              "paramStr": "(a, b, transposeA?, transposeB?)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "First matrix in dot product operation.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "Second matrix in dot product operation.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "transposeA",
                  "documentation": "If true, `a` is transposed before multiplication.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "transposeB",
                  "documentation": "If true, `b` is transposed before multiplication.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the dot product of two matrices, A * B. These must be matrices.\n\n```js\nconst a = tf.tensor2d([1, 2], [1, 2]);\nconst b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\na.matMul(b).print();  // or tf.matMul(a, b)\n```",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/mat_mul.ts#L44-L57",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.matMul",
              "urlHash": "matMul"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "norm",
              "paramStr": "(x, ord?, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input array.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "ord",
                  "documentation": "Optional. Order of the norm. Supported norm types are\nfollowing:\n\n| ord        | norm for matrices         | norm for vectors\n|------------|---------------------------|---------------------\n|'euclidean' |Frobenius norm             |2-norm\n|'fro'       |Frobenius norm\t           |\n|Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n|-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n|1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n|2           |                           |sum(abs(x)^2)^(1/2)",
                  "type": "number|'euclidean'|'fro'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "Optional. If axis is null (the default), the input is\nconsidered a vector and a single vector norm is computed over the entire\nset of values in the Tensor, i.e. norm(x, ord) is equivalent\nto norm(x.reshape([-1]), ord). If axis is an integer, the input\nis considered a batch of vectors, and axis determines the axis in x\nover which to compute vector norms. If axis is a 2-tuple of integer it is\nconsidered a batch of matrices and axis determines the axes in NDArray\nover which to compute a matrix norm.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "Optional. If true, the norm has the same dimensionality\nas the input.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the norm of scalar, vectors, and matrices.\nThis function can compute several different vector norms (the 1-norm, the\nEuclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\nand matrix norms (Frobenius, 1-norm, and inf-norm).\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\n\nx.norm().print();  // or tf.norm(x)\n```",
              "fileName": "#73",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/norm.ts#L73-L85",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.norm",
              "urlHash": "norm"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "outerProduct",
              "paramStr": "(v1, v2)",
              "parameters": [
                {
                  "name": "v1",
                  "documentation": "The first vector in the outer product operation.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "v2",
                  "documentation": "The second vector in the outer product operation.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Computes the outer product of two vectors, `v1` and `v2`.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([3, 4, 5]);\n\ntf.outerProduct(a, b).print();\n```",
              "fileName": "#40",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/outer_product.ts#L40-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.outerProduct",
              "urlHash": "outerProduct"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Matrices"
              },
              "symbolName": "transpose",
              "paramStr": "(x, perm?, conjugate?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to transpose.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "perm",
                  "documentation": "The permutation of the dimensions of a.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "conjugate",
                  "documentation": "Will conjugate complex input if true.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Transposes the [tf.Tensor](#class:Tensor). Permutes the dimensions according to `perm`.\n\nThe returned [tf.Tensor](#class:Tensor)'s dimension `i` will correspond to the input\ndimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\nwhere `n` is the rank of the input [tf.Tensor](#class:Tensor). Hence by default, this\noperation performs a regular matrix transpose on 2-D input [tf.Tensor](#class:Tensor)s.\n\n```js\nconst a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n\na.transpose().print();  // or tf.transpose(a)\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/transpose.ts#L53-L98",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.transpose",
              "urlHash": "transpose"
            }
          ]
        },
        {
          "name": "Convolution",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "avgPool",
              "paramStr": "(x, filterSize, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size: `[filterHeight, filterWidth]`. If\n`filterSize` is a single number, then `filterHeight == filterWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`. If\n`strides` is a single number, then `strideHeight == strideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm:\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number|conv_util.ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the 2D average pooling of an image.",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/avg_pool.ts#L54-L93",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.avgPool",
              "urlHash": "avgPool"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "avgPool3d",
              "paramStr": "(x, filterSize, strides, pad, dimRoundingMode?, dataFormat?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 5 or rank 4 of shape\n`[batch, depth, height, width, inChannels]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size:\n`[filterDepth, filterHeight, filterWidth]`.\nIf `filterSize` is a single number,\nthen `filterDepth == filterHeight == filterWidth`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling:\n`[strideDepth, strideHeight, strideWidth]`.\nIf `strides` is a single number,\nthen `strideDepth == strideHeight == strideWidth`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1*1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n\"NDHWC\". Specify the data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of: [batch,\ndepth, height, width, channels]. Only \"NDHWC\" is currently supported.",
                  "type": "'NDHWC'|'NCDHW'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)",
              "documentation": "Computes the 3D average pooling.\n\n```js\nconst x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\nconst result = tf.avgPool3d(x, 2, 1, 'valid');\nresult.print();\n```",
              "fileName": "#68",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/avg_pool_3d.ts#L68-L113",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.avgPool3d",
              "urlHash": "avgPool3d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv1d",
              "paramStr": "(x, filter, stride, pad, dataFormat?, dilation?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 3 or rank 2, of shape\n`[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 3, of shape\n`[filterWidth, inDepth, outDepth]`.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "stride",
                  "documentation": "The number of entries by which the filter is moved right at\neach step.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number|conv_util.ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\nthe data is stored in the order of [batch, in_width, in_channels]. Only\n\"NWC\" is currently supported.",
                  "type": "'NWC'|'NCW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilation",
                  "documentation": "The dilation rate in which we sample input values in\natrous convolution. Defaults to `1`. If it is greater than 1, then\nstride must be `1`.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)",
              "documentation": "Computes a 1D convolution over the input x.",
              "fileName": "#55",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/conv1d.ts#L55-L114",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.conv1d",
              "urlHash": "conv1d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv2d",
              "paramStr": "(x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 4, of shape\n`[filterHeight, filterWidth, inDepth, outDepth]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number|conv_util.ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels].",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nin atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\nnumber, then `dilationHeight == dilationWidth`. If it is greater than\n1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes a 2D convolution over the input x.",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/conv2d.ts#L62-L117",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.conv2d",
              "urlHash": "conv2d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv2dTranspose",
              "paramStr": "(x, filter, outputShape, strides, pad, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input image, of rank 4 or rank 3, of shape\n`[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 4, of shape\n`[filterHeight, filterWidth, outDepth, inDepth]`.\n`inDepth` must match `inDepth` in `x`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "outputShape",
                  "documentation": "Output shape, of rank 4 or rank 3:\n`[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.",
                  "type": "[number, number, number, number]|[number, number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the original convolution:\n`[strideHeight, strideWidth]`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm used in the non-transpose version\nof the op.",
                  "type": "'valid'|'same'|number|ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the transposed 2D convolution of an image, also known as a\ndeconvolution.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/conv2d_transpose.ts#L45-L56",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.conv2dTranspose",
              "urlHash": "conv2dTranspose"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv3d",
              "paramStr": "(x, filter, strides, pad, dataFormat?, dilations?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 5 or rank 4, of shape\n`[batch, depth, height, width, channels]`. If rank 4,\nbatch of 1 is assumed.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 5, of shape\n`[filterDepth, filterHeight, filterWidth, inChannels, outChannels]`.\ninChannels must match between input and filter.",
                  "type": "[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideDepth, strideHeight,\nstrideWidth]`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n\"NDHWC\". Specify the data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of: [batch,\ndepth, height, width, channels]. Only \"NDHWC\" is currently supported.",
                  "type": "'NDHWC'|'NCDHW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationDepth, dilationHeight,\ndilationWidth]` in which we sample input values across the height\nand width dimensions in atrous convolution. Defaults to `[1, 1, 1]`.\nIf `dilations` is a single number, then\n`dilationDepth == dilationHeight == dilationWidth`. If it is greater\nthan 1, then all values of `strides` must be 1.",
                  "type": "[number, number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)",
              "documentation": "Computes a 3D convolution over the input x.",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/conv3d.ts#L62-L118",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.conv3d",
              "urlHash": "conv3d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "conv3dTranspose",
              "paramStr": "(x, filter, outputShape, strides, pad)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input image, of rank 5 or rank 4, of shape\n`[batch, depth, height, width, inDepth]`. If rank 4, batch of 1 is assumed.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter, rank 4, of shape\n`[depth, filterHeight, filterWidth, outDepth, inDepth]`.\n`inDepth` must match `inDepth` in `x`.",
                  "type": "[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "outputShape",
                  "documentation": "Output shape, of rank 5 or rank 4:\n`[batch, depth, height, width, outDepth]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[number, number, number, number,\n         number]|[number, number, number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the original convolution:\n`[strideDepth, strideHeight, strideWidth]`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm used in the non-transpose version\nof the op.",
                  "type": "'valid'|'same'",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)",
              "documentation": "Computes the transposed 3D convolution of a volume, also known as a\ndeconvolution.",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/conv3d_transpose.ts#L43-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.conv3dTranspose",
              "urlHash": "conv3dTranspose"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "depthwiseConv2d",
              "paramStr": "(x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter tensor, rank 4, of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`. If strides is a single number, then `strideHeight ==\nstrideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number|conv_util.ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels]. Only \"NHWC\" is currently supported.",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nin atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\nnumber, then `dilationHeight == dilationWidth`. If it is greater than\n1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Depthwise 2D convolution.\n\nGiven a 4D `input` array and a `filter` array of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n`inChannels` convolutional filters of depth 1, this op applies a\ndifferent filter to each input channel (expanding from 1 channel to\n`channelMultiplier` channels for each), then concatenates the results\ntogether. The output has `inChannels * channelMultiplier` channels.\n\nSee\n[https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\nfor more details.",
              "fileName": "#75",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/depthwise_conv2d.ts#L75-L120",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.depthwiseConv2d",
              "urlHash": "depthwiseConv2d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "dilation2d",
              "paramStr": "(x, filter, strides, pad, dilations?, dataFormat?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, rank 3 or rank 4 of shape\n`[batch, height, width, depth]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filter",
                  "documentation": "The filter tensor, rank 3, of shape\n`[filterHeight, filterWidth, depth]`.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the sliding window for each dimension of the\ninput tensor: `[strideHeight, strideWidth]`.\nIf `strides` is a single number,\nthen `strideHeight == strideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1*1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nfor atrous morphological dilation. Defaults to `[1, 1]`. If `dilations`\nis a single number, then `dilationHeight == dilationWidth`. If it is\ngreater than 1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "Specify the data format of the input and output data.\nDefaults to 'NHWC'. Only 'NHWC' is currently supported. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels].",
                  "type": "'NHWC'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Computes the grayscale dilation over the input `x`.",
              "fileName": "#61",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/dilation2d.ts#L61-L108",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.dilation2d",
              "urlHash": "dilation2d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "maxPool3d",
              "paramStr": "(x, filterSize, strides, pad, dimRoundingMode?, dataFormat?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 5 or rank 4 of shape\n`[batch, depth, height, width, inChannels]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size:\n`[filterDepth, filterHeight, filterWidth]`.\nIf `filterSize` is a single number,\nthen `filterDepth == filterHeight == filterWidth`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling:\n`[strideDepth, strideHeight, strideWidth]`.\nIf `strides` is a single number,\nthen `strideDepth == strideHeight == strideWidth`.",
                  "type": "[number, number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1*1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n\"NDHWC\". Specify the data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of: [batch,\ndepth, height, width, channels]. Only \"NDHWC\" is currently supported.",
                  "type": "'NDHWC'|'NCDHW'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)",
              "documentation": "Computes the 3D max pooling.\n\n```js\nconst x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\nconst result = tf.maxPool3d(x, 2, 1, 'valid');\nresult.print();\n```",
              "fileName": "#66",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/max_pool_3d.ts#L66-L104",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.maxPool3d",
              "urlHash": "maxPool3d"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "maxPoolWithArgmax",
              "paramStr": "(x, filterSize, strides, pad, includeBatchInIndex?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "filterSize",
                  "documentation": "The filter size: `[filterHeight, filterWidth]`. If\n`filterSize` is a single number, then `filterHeight == filterWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`. If\n`strides` is a single number, then `strideHeight == strideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "includeBatchInIndex",
                  "documentation": "",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "Computes the 2D max pooling of an image with Argmax index.\nThe indices in argmax are flattened, so that a maximum value at position `[b,\ny, x, c]` becomes flattened index: `(y * width + x) * channels + c` if\ninclude_batch_in_index is False; `((b * height + y) * width + x) * channels\n+c` if include_batch_in_index is True.\n\nThe indices returned are always in `[0, height) x [0, width)` before\nflattening.",
              "fileName": "#61",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/max_pool_with_argmax.ts#L61-L77",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.maxPoolWithArgmax",
              "urlHash": "maxPoolWithArgmax"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "pool",
              "paramStr": "(input, windowShape, poolingType, pad, dilations?, strides?, dimRoundingMode?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The input tensor, of rank 4 or rank 3 of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "windowShape",
                  "documentation": "The filter size: `[filterHeight, filterWidth]`. If\n`filterSize` is a single number, then `filterHeight == filterWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "poolingType",
                  "documentation": "The type of pooling, either 'max' or 'avg'.",
                  "type": "'avg'|'max'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm:\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_guides/python/nn#Convolution](\nhttps://www.tensorflow.org/api_guides/python/nn#Convolution)",
                  "type": "'valid'|'same'|number|conv_util.ExplicitPadding",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dilations",
                  "documentation": "The dilation rates: `[dilationHeight, dilationWidth]`\nin which we sample input values across the height and width dimensions\nin dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single\nnumber, then `dilationHeight == dilationWidth`. If it is greater than\n1, then all values of `strides` must be 1.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the pooling: `[strideHeight, strideWidth]`. If\n`strides` is a single number, then `strideHeight == strideWidth`.",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dimRoundingMode",
                  "documentation": "A string from: 'ceil', 'round', 'floor'. If none is\nprovided, it will default to truncate.",
                  "type": "'floor'|'round'|'ceil'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Performs an N-D pooling operation",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/pool.ts#L59-L128",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.pool",
              "urlHash": "pool"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Convolution"
              },
              "symbolName": "separableConv2d",
              "paramStr": "(x, depthwiseFilter, pointwiseFilter, strides, pad, dilation?, dataFormat?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is\nassumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depthwiseFilter",
                  "documentation": "The depthwise filter tensor, rank 4, of shape\n`[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\nthe filter used in the first step.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pointwiseFilter",
                  "documentation": "The pointwise filter tensor, rank 4, of shape\n`[1, 1, inChannels * channelMultiplier, outChannels]`. This is\nthe filter used in the second step.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": "The strides of the convolution: `[strideHeight,\nstrideWidth]`. If strides is a single number, then `strideHeight ==\nstrideWidth`.",
                  "type": "[number, number]|number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pad",
                  "documentation": "The type of padding algorithm.\n- `same` and stride 1: output will be of same size as input,\nregardless of filter size.\n- `valid`: output will be smaller than input if filter is larger\nthan 1x1.\n- For more info, see this guide:\n[https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\nhttps://www.tensorflow.org/api_docs/python/tf/nn/convolution)",
                  "type": "'valid'|'same'",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dilation",
                  "documentation": "",
                  "type": "[number, number]|number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "dataFormat",
                  "documentation": ": An optional string from: \"NHWC\", \"NCHW\". Defaults to\n\"NHWC\". Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of: [batch,\nheight, width, channels]. Only \"NHWC\" is currently supported.",
                  "type": "'NHWC'|'NCHW'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "2-D convolution with separable filters.\n\nPerforms a depthwise convolution that acts separately on channels followed\nby a pointwise convolution that mixes channels. Note that this is\nseparability between dimensions [1, 2] and 3, not spatial separability\nbetween dimensions 1 and 2.\n\nSee\n[https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\nfor more details.",
              "fileName": "#72",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/separable_conv2d.ts#L72-L137",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.separableConv2d",
              "urlHash": "separableConv2d"
            }
          ]
        },
        {
          "name": "Reduction",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "all",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the logical and of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in\n`axes`. If `keepDims` is true, the reduced dimensions are retained with\nlength 1. If `axes` has no entries, all dimensions are reduced, and a\n[tf.Tensor](#class:Tensor) with a single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 1, 1], 'bool');\n\nx.all().print();  // or tf.all(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n\nconst axis = 1;\nx.all(axis).print();  // or tf.all(x, axis)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/all.ts#L57-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.all",
              "urlHash": "all"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "any",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the logical or of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in\n`axes`. If `keepDims` is true, the reduced dimensions are retained with\nlength 1. If `axes` has no entries, all dimensions are reduced, and a\n[tf.Tensor](#class:Tensor) with a single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 1, 1], 'bool');\n\nx.any().print();  // or tf.any(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n\nconst axis = 1;\nx.any(axis).print();  // or tf.any(x, axis)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/any.ts#L57-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.any",
              "urlHash": "any"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "argMax",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension to reduce. Defaults to 0 (outer-most dimension).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the indices of the maximum values along an `axis`.\n\nThe result has the same shape as `input` with the dimension along `axis`\nremoved.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.argMax().print();  // or tf.argMax(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n\nconst axis = 1;\nx.argMax(axis).print();  // or tf.argMax(x, axis)\n```",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/arg_max.ts#L52-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.argMax",
              "urlHash": "argMax"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "argMin",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension to reduce. Defaults to 0 (outer-most dimension).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the indices of the minimum values along an `axis`.\n\nThe result has the same shape as `input` with the dimension along `axis`\nremoved.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.argMin().print();  // or tf.argMin(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n\nconst axis = 1;\nx.argMin(axis).print();  // or tf.argMin(x, axis)\n```",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/arg_min.ts#L52-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.argMin",
              "urlHash": "argMin"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "bincount",
              "paramStr": "(x, weights, size)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input int tensor, rank 1.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "The weights tensor, must have the same shape as x, or a\nlength-0 Tensor, in which case it acts as all weights equal to 1.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "Non-negative integer.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Outputs a vector with length `size` and the same dtype as `weights`.\n\nIf `weights` are empty, then index `i` stores the number of times the value\n`i` is counted in `x`. If `weights` are non-empty, then index `i` stores the\nsum of the value in `weights` at each index where the corresponding value in\n`x` is `i`.\n\nValues in `x` outside of the range [0, size) are ignored.",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/bincount.ts#L46-L68",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.bincount",
              "urlHash": "bincount"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "denseBincount",
              "paramStr": "(x, weights, size, binaryOutput?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input int tensor, rank 1 or rank 2.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "The weights tensor, must have the same shape as x, or a\nlength-0 Tensor, in which case it acts as all weights equal to 1.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "Non-negative integer.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "binaryOutput",
                  "documentation": "Optional. Whether the kernel should count the appearance\nor number of occurrences. Defaults to False.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)|[tf.Tensor2D](#class:Tensor)",
              "documentation": "Outputs a vector with length `size` and the same dtype as `weights`.\n\nIf `weights` are empty, then index `i` stores the number of times the value\n`i` is counted in `x`. If `weights` are non-empty, then index `i` stores the\nsum of the value in `weights` at each index where the corresponding value in\n`x` is `i`.\n\nValues in `x` outside of the range [0, size) are ignored.",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/dense_bincount.ts#L48-L76",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.denseBincount",
              "urlHash": "denseBincount"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "logSumExp",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. If null (the default),\nreduces all dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with length\nof 1. Defaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the log(sum(exp(elements across the reduction dimensions))).\n\nReduces the input along the dimensions given in `axis`. Unless `keepDims`\nis true, the rank of the array is reduced by 1 for each entry in `axis`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axis` has no entries, all dimensions are reduced, and an array with a\nsingle element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.logSumExp().print();  // or tf.logSumExp(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.logSumExp(axis).print();  // or tf.logSumExp(a, axis)\n```",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/log_sum_exp.ts#L62-L79",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logSumExp",
              "urlHash": "logSumExp"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "max",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the maximum of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in\n`axes`. If `keepDims` is true, the reduced dimensions are retained with\nlength 1. If `axes` has no entries, all dimensions are reduced, and a\n[tf.Tensor](#class:Tensor) with a single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.max().print();  // or tf.max(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.max(axis).print();  // or tf.max(x, axis)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/max.ts#L57-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.max",
              "urlHash": "max"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "mean",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the mean of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces `x` along the dimensions given in `axis`. Unless `keepDims` is\ntrue, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in `axis`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axis` has no entries, all dimensions are reduced, and a [tf.Tensor](#class:Tensor) with\na single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.mean().print();  // or tf.mean(a)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.mean(axis).print();  // or tf.mean(x, axis)\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/mean.ts#L57-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.mean",
              "urlHash": "mean"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "min",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the minimum value from the input.\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the array is reduced by 1 for each entry in `axes`.\nIf `keepDims` is true, the reduced dimensions are retained with length 1.\nIf `axes` has no entries, all dimensions are reduced, and an array with a\nsingle element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.min().print();  // or tf.min(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.min(axis).print();  // or tf.min(x, axis)\n```",
              "fileName": "#56",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/min.ts#L56-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.min",
              "urlHash": "min"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "prod",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to compute the product over. If the dtype is `bool`\nit will be converted to `int32` and the output dtype will be `int32`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the product of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in\n`axes`. If `keepDims` is true, the reduced dimensions are retained with\nlength 1. If `axes` has no entries, all dimensions are reduced, and a\n[tf.Tensor](#class:Tensor) with a single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.prod().print();  // or tf.prod(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.prod(axis).print();  // or tf.prod(x, axis)\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/prod.ts#L59-L74",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.prod",
              "urlHash": "prod"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Reduction"
              },
              "symbolName": "sum",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to compute the sum over. If the dtype is `bool`\nit will be converted to `int32` and the output dtype will be `int32`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) to reduce. By default it reduces\nall dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, retains reduced dimensions with size 1.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the sum of elements across dimensions of a [tf.Tensor](#class:Tensor).\n\nReduces the input along the dimensions given in `axes`. Unless `keepDims`\nis true, the rank of the [tf.Tensor](#class:Tensor) is reduced by 1 for each entry in\n`axes`. If `keepDims` is true, the reduced dimensions are retained with\nlength 1. If axes has no entries, all dimensions are reduced, and a\n[tf.Tensor](#class:Tensor) with a single element is returned.\n\n```js\nconst x = tf.tensor1d([1, 2, 3]);\n\nx.sum().print();  // or tf.sum(x)\n```\n\n```js\nconst x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n\nconst axis = 1;\nx.sum(axis).print();  // or tf.sum(x, axis)\n```",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sum.ts#L58-L71",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sum",
              "urlHash": "sum"
            }
          ]
        },
        {
          "name": "Normalization",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "batchNorm",
              "paramStr": "(x, mean, variance, offset?, scale?, varianceEpsilon?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "documentation": "A mean Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "variance",
                  "documentation": "A variance Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "offset",
                  "documentation": "An offset Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scale",
                  "documentation": "A scale Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "varianceEpsilon",
                  "documentation": "A small float number to avoid dividing by 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Batch normalization.\n\nAs described in\n[http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).\n\nMean, variance, scale, and offset can be of two shapes:\n   - The same shape as the input.\n   - In the common case, the depth dimension is the last dimension of x, so\n     the values would be a [tf.Tensor1D](#class:Tensor) of shape [depth].\n\nAlso available are stricter rank-specific methods with the same signature\nas this method that assert that parameters passed are of given rank\n   - `tf.batchNorm2d`\n   - `tf.batchNorm3d`\n   - `tf.batchNorm4d`",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/batchnorm.ts#L57-L109",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.batchNorm",
              "urlHash": "batchNorm"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "localResponseNormalization",
              "paramStr": "(x, depthRadius?, bias?, alpha?, beta?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. The 4-D input tensor is treated as a 3-D array\nof 1D vectors (along the last dimension), and each vector is\nnormalized independently.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "depthRadius",
                  "documentation": "The number of adjacent channels in the 1D normalization\nwindow.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "bias",
                  "documentation": "A constant bias term for the basis.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "alpha",
                  "documentation": "A scale factor, usually positive.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta",
                  "documentation": "An exponent.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Normalizes the activation of a local neighborhood across or within\nchannels.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/local_response_normalization.ts#L45-L78",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.localResponseNormalization",
              "urlHash": "localResponseNormalization"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "logSoftmax",
              "paramStr": "(logits, axis?)",
              "parameters": [
                {
                  "name": "logits",
                  "documentation": "The logits array.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension softmax would be performed on. Defaults to `-1`\nwhich indicates the last dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the log softmax.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\n\na.logSoftmax().print();  // or tf.logSoftmax(a)\n```\n\n```js\nconst a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n\na.logSoftmax().print();  // or tf.logSoftmax(a)\n```",
              "fileName": "#55",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/log_softmax.ts#L55-L104",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logSoftmax",
              "urlHash": "logSoftmax"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "moments",
              "paramStr": "(x, axis?, keepDims?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension(s) along with to compute mean and\nvariance. By default it reduces all dimensions.",
                  "type": "number|number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "keepDims",
                  "documentation": "If true, the moments have the same dimensionality as the\ninput.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{mean: [tf.Tensor](#class:Tensor), variance: [tf.Tensor](#class:Tensor)}",
              "documentation": "Calculates the mean and variance of `x`. The mean and variance are\ncalculated by aggregating the contents of `x` across `axes`. If `x` is\n1-D and `axes = [0]` this is just the mean and variance of a vector.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/moments.ts#L45-L59",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.moments",
              "urlHash": "moments"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "softmax",
              "paramStr": "(logits, dim?)",
              "parameters": [
                {
                  "name": "logits",
                  "documentation": "The logits array.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dim",
                  "documentation": "The dimension softmax would be performed on. Defaults to `-1`\nwhich indicates the last dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the softmax normalized vector given the logits.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\n\na.softmax().print();  // or tf.softmax(a)\n```\n\n```js\nconst a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n\na.softmax().print();  // or tf.softmax(a)\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/softmax.ts#L49-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.softmax",
              "urlHash": "softmax"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Normalization"
              },
              "symbolName": "sparseToDense",
              "paramStr": "(sparseIndices, sparseValues, outputShape, defaultValue?)",
              "parameters": [
                {
                  "name": "sparseIndices",
                  "documentation": "A 0-D, 1-D, or 2-D Tensor of type int32.\nsparseIndices[i] contains the complete index where sparseValues[i] will be\nplaced.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "sparseValues",
                  "documentation": "A 0-D or 1-D Tensor. Values\ncorresponding to each row of sparseIndices, or a scalar value to be used for\nall sparse indices.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "outputShape",
                  "documentation": "Shape of the dense output tensor. The type is inferred.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "defaultValue",
                  "documentation": "Scalar. Value to set for indices not specified in\nsparseIndices. Defaults to zero.",
                  "type": "[tf.Scalar](#class:Tensor)|ScalarLike",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Converts a sparse representation into a dense tensor.\n\nBuilds an array dense with shape outputShape such that:\n\n// If sparseIndices is scalar\ndense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n\n// If sparseIndices is a vector, then for each i\ndense[sparseIndices[i]] = sparseValues[i]\n\n// If sparseIndices is an n by d matrix, then for each i in [0, n)\ndense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\nAll other values in dense are set to defaultValue. If sparseValues is a\nscalar, all sparse indices are set to this single value.\n\nIf indices are repeated the final value is summed over all values for those\nindices.\n\n```js\nconst indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\nconst values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\nconst shape = [8];\ntf.sparseToDense(indices, values, shape).print();\n```",
              "fileName": "#68",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sparse_to_dense.ts#L68-L94",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sparseToDense",
              "urlHash": "sparseToDense"
            }
          ]
        },
        {
          "name": "Images",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "cropAndResize",
              "namespace": "image",
              "paramStr": "(image, boxes, boxInd, cropSize, method?, extrapolationValue?)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\nwhere imageHeight and imageWidth must be positive, specifying the\nbatch of images from which to take crops",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "boxes",
                  "documentation": "2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\ncoordinates of the box in the `boxInd[i]`th image in the batch",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "boxInd",
                  "documentation": "1d int32 tensor of shape `[numBoxes]` with values in range\n`[0, batch)` that specifies the image that the `i`-th box refers to.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "cropSize",
                  "documentation": "1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\nspecifying the size to which all crops are resized to.",
                  "type": "[number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "method",
                  "documentation": "Optional string from `'bilinear' | 'nearest'`,\ndefaults to bilinear, which specifies the sampling method for resizing",
                  "type": "'bilinear'|'nearest'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "extrapolationValue",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Extracts crops from the input image tensor and resizes them using bilinear\nsampling or nearest neighbor sampling (possibly with aspect ratio change)\nto a common output size specified by cropSize.",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/crop_and_resize.ts#L52-L96",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.cropAndResize",
              "urlHash": "image.cropAndResize"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "flipLeftRight",
              "namespace": "image",
              "paramStr": "(image)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Flips the image left to right. Currently available in the CPU, WebGL, and\nWASM backends.",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/flip_left_right.ts#L34-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.flipLeftRight",
              "urlHash": "image.flipLeftRight"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "grayscaleToRGB",
              "namespace": "image",
              "paramStr": "(image)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "A grayscale tensor to convert. The `image`'s last dimension must\nbe size 1 with at least a two-dimensional shape.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|\n                         [tf.Tensor6D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[tf.Tensor5D](#class:Tensor)|\n                         [tf.Tensor6D](#class:Tensor)",
              "documentation": "Converts images from grayscale to RGB format.",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/grayscale_to_rgb.ts#L34-L57",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.grayscaleToRGB",
              "urlHash": "image.grayscaleToRGB"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppression",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Performs non maximum suppression of bounding boxes based on\niou (intersection over union).",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression.ts#L44-L62",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppression",
              "urlHash": "image.nonMaxSuppression"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppressionAsync",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.Tensor1D](#class:Tensor)>",
              "documentation": "Performs non maximum suppression of bounding boxes based on\niou (intersection over union).\n\nThis is the async version of `nonMaxSuppression`",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression_async.ts#L45-L75",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppressionAsync",
              "urlHash": "image.nonMaxSuppressionAsync"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppressionPadded",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "padToMaxOutputSize",
                  "documentation": "Defaults to false. If true, size of output\n`selectedIndices` is padded to maxOutputSize.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "Asynchronously performs non maximum suppression of bounding boxes based on\niou (intersection over union), with an option to pad results.",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression_padded.ts#L52-L81",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppressionPadded",
              "urlHash": "image.nonMaxSuppressionPadded"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppressionPaddedAsync",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "padToMaxOutputSize",
                  "documentation": "Defaults to false. If true, size of output\n`selectedIndices` is padded to maxOutputSize.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<{[name: string]: [tf.Tensor](#class:Tensor)}>",
              "documentation": "Asynchronously performs non maximum suppression of bounding boxes based on\niou (intersection over union), with an option to pad results.",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression_padded_async.ts#L49-L85",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppressionPaddedAsync",
              "urlHash": "image.nonMaxSuppressionPaddedAsync"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppressionWithScore",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "softNmsSigma",
                  "documentation": "A float representing the sigma parameter for Soft NMS.\nWhen sigma is 0, it falls back to nonMaxSuppression.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "Performs non maximum suppression of bounding boxes based on\niou (intersection over union).\n\nThis op also supports a Soft-NMS mode (cf.\nBodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\nof other overlapping boxes, therefore favoring different regions of the image\nwith high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\nparameter to be larger than 0.",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression_with_score.ts#L58-L84",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppressionWithScore",
              "urlHash": "image.nonMaxSuppressionWithScore"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "nonMaxSuppressionWithScoreAsync",
              "namespace": "image",
              "paramStr": "(boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?)",
              "parameters": [
                {
                  "name": "boxes",
                  "documentation": "a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n`[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\nthe bounding box.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scores",
                  "documentation": "a 1d tensor providing the box scores of shape `[numBoxes]`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxOutputSize",
                  "documentation": "The maximum number of boxes to be selected.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "iouThreshold",
                  "documentation": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to IOU. Must be between [0, 1].\nDefaults to 0.5 (50% box overlap).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "scoreThreshold",
                  "documentation": "A threshold for deciding when to remove boxes based\non score. Defaults to -inf, which means any score is accepted.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "softNmsSigma",
                  "documentation": "A float representing the sigma parameter for Soft NMS.\nWhen sigma is 0, it falls back to nonMaxSuppression.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<{[name: string]: [tf.Tensor](#class:Tensor)}>",
              "documentation": "Asynchronously performs non maximum suppression of bounding boxes based on\niou (intersection over union).\n\nThis op also supports a Soft-NMS mode (cf.\nBodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\nof other overlapping boxes, therefore favoring different regions of the image\nwith high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\nparameter to be larger than 0.",
              "fileName": "#54",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/non_max_suppression_with_score_async.ts#L54-L92",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.nonMaxSuppressionWithScoreAsync",
              "urlHash": "image.nonMaxSuppressionWithScoreAsync"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "resizeBilinear",
              "namespace": "image",
              "paramStr": "(images, size, alignCorners?, halfPixelCenters?)",
              "parameters": [
                {
                  "name": "images",
                  "documentation": "The images, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "The new shape `[newHeight, newWidth]` to resize the\nimages to. Each channel is resized individually.",
                  "type": "[number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alignCorners",
                  "documentation": "Defaults to `false`. If true, rescale\ninput by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\ncorners of images and resized images. If false, rescale by\n`new_height / height`. Treat similarly the width dimension.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "halfPixelCenters",
                  "documentation": "Defaults to `false`. Whether to assume pixel centers\nare at 0.5, which would make the floating point coordinates of the top\nleft pixel 0.5, 0.5.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "Bilinear resize a single 3D image or a batch of 3D images to a new shape.",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/resize_bilinear.ts#L47-L87",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.resizeBilinear",
              "urlHash": "image.resizeBilinear"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "resizeNearestNeighbor",
              "namespace": "image",
              "paramStr": "(images, size, alignCorners?, halfPixelCenters?)",
              "parameters": [
                {
                  "name": "images",
                  "documentation": "The images, of rank 4 or rank 3, of shape\n`[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.",
                  "type": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "size",
                  "documentation": "The new shape `[newHeight, newWidth]` to resize the\nimages to. Each channel is resized individually.",
                  "type": "[number, number]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "alignCorners",
                  "documentation": "Defaults to False. If true, rescale\ninput by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\ncorners of images and resized images. If false, rescale by\n`new_height / height`. Treat similarly the width dimension.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "halfPixelCenters",
                  "documentation": "Defaults to `false`. Whether to assume pixels are of\nhalf the actual dimensions, and yield more accurate resizes. This flag\nwould also make the floating point coordinates of the top left pixel\n0.5, 0.5.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)|[tf.Tensor4D](#class:Tensor)",
              "documentation": "NearestNeighbor resize a batch of 3D images to a new shape.",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/resize_nearest_neighbor.ts#L48-L91",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.resizeNearestNeighbor",
              "urlHash": "image.resizeNearestNeighbor"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "rotateWithOffset",
              "namespace": "image",
              "paramStr": "(image, radians, fillValue?, center?)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "radians",
                  "documentation": "The amount of rotation.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fillValue",
                  "documentation": "The value to fill in the empty space leftover\nafter rotation. Can be either a single grayscale value (0-255), or an\narray of three numbers `[red, green, blue]` specifying the red, green,\nand blue channels. Defaults to `0` (black).",
                  "type": "number|[number, number, number]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "center",
                  "documentation": "The center of rotation. Can be either a single value (0-1), or\nan array of two numbers `[centerX, centerY]`. Defaults to `0.5` (rotates\nthe image around its center).",
                  "type": "number|[number, number]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Rotates the input image tensor counter-clockwise with an optional offset\ncenter of rotation. Currently available in the CPU, WebGL, and WASM backends.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/rotate_with_offset.ts#L45-L62",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.rotateWithOffset",
              "urlHash": "image.rotateWithOffset"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Images",
                "namespace": "image"
              },
              "symbolName": "transform",
              "namespace": "image",
              "paramStr": "(image, transforms, interpolation?, fillMode?, fillValue?, outputShape?)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.",
                  "type": "[tf.Tensor4D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "transforms",
                  "documentation": "Projective transform matrix/matrices. A tensor1d of length\n8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,\nb1, b2, c0, c1], then it maps the output point (x, y) to a transformed\ninput point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),\nwhere k = c0 x + c1 y + 1. The transforms are inverted compared to the\ntransform mapping input points to output points.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "interpolation",
                  "documentation": "Interpolation mode.\nSupported values: 'nearest', 'bilinear'. Default to 'nearest'.",
                  "type": "'nearest'|'bilinear'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "fillMode",
                  "documentation": "Points outside the boundaries of the input are filled\naccording to the given mode, one of 'constant', 'reflect', 'wrap',\n'nearest'. Default to 'constant'.\n'reflect': (d c b a | a b c d | d c b a ) The input is extended by\nreflecting about the edge of the last pixel.\n'constant': (k k k k | a b c d | k k k k) The input is extended by\nfilling all values beyond the edge with the same constant value k.\n'wrap': (a b c d | a b c d | a b c d) The input is extended by\nwrapping around to the opposite edge.\n'nearest': (a a a a | a b c d | d d d d) The input is extended by\nthe nearest pixel.",
                  "type": "'constant'|'reflect'|'wrap'|'nearest'",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "fillValue",
                  "documentation": "A float represents the value to be filled outside the\nboundaries when fillMode is 'constant'.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "outputShape",
                  "documentation": "",
                  "type": "[number, number]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor4D](#class:Tensor)",
              "documentation": "Applies the given transform(s) to the image(s).",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/image/transform.ts#L58-L92",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.image.transform",
              "urlHash": "image.transform"
            }
          ]
        },
        {
          "name": "RNN",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "RNN"
              },
              "symbolName": "basicLSTMCell",
              "paramStr": "(forgetBias, lstmKernel, lstmBias, data, c, h)",
              "parameters": [
                {
                  "name": "forgetBias",
                  "documentation": "Forget bias for the cell.",
                  "type": "[tf.Scalar](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "lstmKernel",
                  "documentation": "The weights for the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "lstmBias",
                  "documentation": "The bias for the cell.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "data",
                  "documentation": "The input to the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "c",
                  "documentation": "Previous cell state.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "h",
                  "documentation": "Previous cell output.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[[tf.Tensor2D](#class:Tensor), [tf.Tensor2D](#class:Tensor)]",
              "documentation": "Computes the next state and output of a BasicLSTMCell.\n\nReturns `[newC, newH]`.\n\nDerived from tf.contrib.rnn.BasicLSTMCell.",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/basic_lstm_cell.ts#L47-L78",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.basicLSTMCell",
              "urlHash": "basicLSTMCell"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "RNN"
              },
              "symbolName": "multiRNNCell",
              "paramStr": "(lstmCells, data, c, h)",
              "parameters": [
                {
                  "name": "lstmCells",
                  "documentation": "Array of LSTMCell functions.",
                  "type": "(data: [tf.Tensor2D](#class:Tensor), c: [tf.Tensor2D](#class:Tensor), h: [tf.Tensor2D](#class:Tensor)): [[tf.Tensor2D](#class:Tensor), [tf.Tensor2D](#class:Tensor)][]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "data",
                  "documentation": "The input to the cell.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "c",
                  "documentation": "Array of previous cell states.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "h",
                  "documentation": "Array of previous cell outputs.",
                  "type": "Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[[tf.Tensor2D](#class:Tensor)[], [tf.Tensor2D](#class:Tensor)[]]",
              "documentation": "Computes the next states and outputs of a stack of LSTMCells.\n\nEach cell output is used as input to the next cell.\n\nReturns `[cellState, cellOutput]`.\n\nDerived from tf.contrib.rn.MultiRNNCell.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/multi_rnn_cell.ts#L45-L68",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.multiRNNCell",
              "urlHash": "multiRNNCell"
            }
          ]
        },
        {
          "name": "Logical",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "bitwiseAnd",
              "paramStr": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be calculated.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "y",
                  "documentation": "The input tensor to be calculated.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Bitwise `AND` operation for input tensors.\n\nGiven two input tensors, returns a new tensor\nwith the `AND` calculated values.\n\nThe method supports int32 values\n\n\n```js\nconst x = tf.tensor1d([0, 5, 3, 14], 'int32');\nconst y = tf.tensor1d([5, 0, 7, 11], 'int32');\ntf.bitwiseAnd(x, y).print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/bitwise_and.ts#L48-L64",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.bitwiseAnd",
              "urlHash": "bitwiseAnd"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "equal",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a == b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([2, 2, 2]);\n\na.equal(b).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/equal.ts#L43-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.equal",
              "urlHash": "equal"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "greater",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a > b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([2, 2, 2]);\n\na.greater(b).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/greater.ts#L43-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.greater",
              "urlHash": "greater"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "greaterEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a >= b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([2, 2, 2]);\n\na.greaterEqual(b).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/greater_equal.ts#L43-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.greaterEqual",
              "urlHash": "greaterEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "less",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a < b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([2, 2, 2]);\n\na.less(b).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/less.ts#L42-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.less",
              "urlHash": "less"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "lessEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a <= b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([2, 2, 2]);\n\na.lessEqual(b).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/less_equal.ts#L43-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.lessEqual",
              "urlHash": "lessEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalAnd",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `a AND b` element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([false, false, true, true], 'bool');\nconst b = tf.tensor1d([false, true, false, true], 'bool');\n\na.logicalAnd(b).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/logical_and.ts#L42-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logicalAnd",
              "urlHash": "logicalAnd"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalNot",
              "paramStr": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor. Must be of dtype 'bool'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `NOT x` element-wise.\n\n```js\nconst a = tf.tensor1d([false, true], 'bool');\n\na.logicalNot().print();\n```",
              "fileName": "#39",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/logical_not.ts#L39-L43",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logicalNot",
              "urlHash": "logicalNot"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalOr",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `a OR b` element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([false, false, true, true], 'bool');\nconst b = tf.tensor1d([false, true, false, true], 'bool');\n\na.logicalOr(b).print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/logical_or.ts#L41-L49",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logicalOr",
              "urlHash": "logicalOr"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "logicalXor",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of `a XOR b` element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([false, false, true, true], 'bool');\nconst b = tf.tensor1d([false, true, false, true], 'bool');\n\na.logicalXor(b).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/logical_xor.ts#L43-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.logicalXor",
              "urlHash": "logicalXor"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "notEqual",
              "paramStr": "(a, b)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "The first input tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "The second input tensor. Must have the same dtype as `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the truth value of (a != b) element-wise. Supports broadcasting.\n\n```js\nconst a = tf.tensor1d([1, 2, 3]);\nconst b = tf.tensor1d([0, 2, 3]);\n\na.notEqual(b).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/not_equal.ts#L42-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.notEqual",
              "urlHash": "notEqual"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "where",
              "paramStr": "(condition, a, b)",
              "parameters": [
                {
                  "name": "condition",
                  "documentation": "The input condition. Must be of dtype bool.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "a",
                  "documentation": "If `condition` is rank 1, `a` may have a higher rank but\nits first dimension must match the size of `condition`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "b",
                  "documentation": "A tensor with the same dtype as `a` and with shape that is\ncompatible with `a`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Returns the elements, either `a` or `b` depending on the `condition`.\n\nIf the condition is true, select from `a`, otherwise select from `b`.\n\n```js\nconst cond = tf.tensor1d([false, false, true], 'bool');\nconst a = tf.tensor1d([1 , 2, 3]);\nconst b = tf.tensor1d([-1, -2, -3]);\n\na.where(cond, b).print();\n```",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/where.ts#L52-L72",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.where",
              "urlHash": "where"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Logical"
              },
              "symbolName": "whereAsync",
              "paramStr": "(condition)",
              "parameters": [
                {
                  "name": "condition",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.Tensor2D](#class:Tensor)>",
              "documentation": "Returns the coordinates of true elements of condition.\n\nThe coordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\ninput. Indices are output in row-major order. The resulting tensor has the\nshape `[numTrueElems, condition.rank]`.\n\nThis is analogous to calling the python `tf.where(cond)` without an x or y.\n\n```js\nconst cond = tf.tensor1d([false, false, true], 'bool');\nconst result = await tf.whereAsync(cond);\nresult.print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/where_async.ts#L42-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.whereAsync",
              "urlHash": "whereAsync"
            }
          ]
        },
        {
          "name": "Scan",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Scan"
              },
              "symbolName": "cumprod",
              "paramStr": "(x, axis?, exclusive?, reverse?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to cumulatively multiply.",
                  "type": "[tf.Tensor](#class:Tensor) | [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis along which to multiply. Optional. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "exclusive",
                  "documentation": "Whether to perform exclusive cumulative product. Optional.\nDefaults to false. If set to true then the product of each tensor entry\ndoes not include its own value, but only the values previous to it\nalong the specified axis.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reverse",
                  "documentation": "Whether to multiply in the opposite direction. Optional.\nDefaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the cumulative product of a [tf.Tensor](#class:Tensor) along `axis`.\n\n```js\nconst x = tf.tensor([1, 2, 3, 4]);\nx.cumprod().print();\n```\n```js\nconst x = tf.tensor([[1, 2], [3, 4]]);\nx.cumprod().print();\n```",
              "fileName": "#51",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/cumprod.ts#L51-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.cumprod",
              "urlHash": "cumprod"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Scan"
              },
              "symbolName": "cumsum",
              "paramStr": "(x, axis?, exclusive?, reverse?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The input tensor to be summed.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis along which to sum. Optional. Defaults to 0.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "exclusive",
                  "documentation": "Whether to perform exclusive cumulative sum. Optional.\nDefaults to false. If set to true then the sum of each tensor entry\ndoes not include its own value, but only the values previous to it\nalong the specified axis.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reverse",
                  "documentation": "Whether to sum in the opposite direction. Optional.\nDefaults to false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the cumulative sum of a [tf.Tensor](#class:Tensor) along `axis`.\n\n```js\nconst x = tf.tensor([1, 2, 3, 4]);\nx.cumsum().print();\n```\n```js\nconst x = tf.tensor([[1, 2], [3, 4]]);\nx.cumsum().print();\n```",
              "fileName": "#51",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/cumsum.ts#L51-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.cumsum",
              "urlHash": "cumsum"
            }
          ]
        },
        {
          "name": "Evaluation",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "confusionMatrix",
              "paramStr": "(labels, predictions, numClasses)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The target labels, assumed to be 0-based integers\nfor the classes. The shape is `[numExamples]`, where\n`numExamples` is the number of examples included.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted classes, assumed to be\n0-based integers for the classes. Must have the same shape as `labels`.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numClasses",
                  "documentation": "Number of all classes, as an integer.\nIts value must be larger than the largest element in `labels` and\n`predictions`.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor2D](#class:Tensor)",
              "documentation": "Computes the confusion matrix from true labels and predicted labels.\n\n```js\nconst labels = tf.tensor1d([0, 1, 2, 1, 0], 'int32');\nconst predictions = tf.tensor1d([0, 2, 2, 1, 0], 'int32');\nconst numClasses = 3;\nconst out = tf.math.confusionMatrix(labels, predictions, numClasses);\nout.print();\n// Expected output matrix:\n// [[2, 0, 0],\n//  [0, 1, 1],\n//  [0, 0, 1]]\n```",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/confusion_matrix.ts#L58-L94",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.confusionMatrix",
              "urlHash": "confusionMatrix"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "inTopKAsync",
              "paramStr": "(predictions, targets, k?)",
              "parameters": [
                {
                  "name": "predictions",
                  "documentation": "2-D or higher [tf.Tensor](#class:Tensor) with last dimension being\nat least `k`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "targets",
                  "documentation": "1-D or higher [tf.Tensor](#class:Tensor).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "k",
                  "documentation": "Optional Number of top elements to look at for computing precision,\ndefault to 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.Tensor](#class:Tensor)>",
              "documentation": "Returns whether the targets are in the top K predictions.\n\n```js\nconst predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\nconst targets = tf.tensor1d([2, 0]);\nconst precision = await tf.inTopKAsync(predictions, targets);\nprecision.print();\n```",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/in_top_k.ts#L41-L101",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.inTopKAsync",
              "urlHash": "inTopKAsync"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "lowerBound",
              "paramStr": "(sortedSequence, values)",
              "parameters": [
                {
                  "name": "sortedSequence",
                  "documentation": ": N-D. Sorted sequence.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": ": N-D. Search values.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Searches for where a value would go in a sorted sequence.\n\nThis is not a method for checking containment (like javascript in).\n\nThe typical use case for this operation is \"binning\", \"bucketing\", or\n\"discretizing\". The values are assigned to bucket-indices based on the edges\nlisted in 'sortedSequence'. This operation returns the bucket-index for each\nvalue.\n\nThe index returned corresponds to the first edge greater than or equal to the\nvalue.\n\nThe axis is not settable for this operation. It always operates on the\ninnermost dimension (axis=-1). The operation will accept any number of outer\ndimensions.\n\nNote: This operation assumes that 'lowerBound' is sorted along the\ninnermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not\nsorted no error is raised and the content of the returned tensor is not well\ndefined.\n\n```js\nconst edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);\nlet values = tf.tensor1d([0.0, 4.1, 12.0]);\nconst result1 = tf.lowerBound(edges, values);\nresult1.print(); // [1, 2, 4]\n\nconst seq = tf.tensor1d([0, 3, 9, 10, 10]);\nvalues = tf.tensor1d([0, 4, 10]);\nconst result2 = tf.lowerBound(seq, values);\nresult2.print(); // [0, 2, 3]\n\nconst sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],\n                                     [1., 2., 3., 4., 5.]]);\nvalues = tf.tensor2d([[9.8, 2.1, 4.3],\n                       [0.1, 6.6, 4.5, ]]);\nconst result3 = tf.lowerBound(sortedSequence, values);\nresult3.print(); // [[4, 1, 2], [0, 5, 4]]\n```",
              "fileName": "#69",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/lower_bound.ts#L69-L72",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.lowerBound",
              "urlHash": "lowerBound"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "searchSorted",
              "paramStr": "(sortedSequence, values, side?)",
              "parameters": [
                {
                  "name": "sortedSequence",
                  "documentation": ": N-D. Sorted sequence.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": ": N-D. Search values.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "side",
                  "documentation": ": 'left'|'right'. Defaults to 'left'. 'left' corresponds to lower\nbound and 'right' to upper bound.",
                  "type": "'left'|'right'",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Searches for where a value would go in a sorted sequence.\n\nThis is not a method for checking containment (like javascript in).\n\nThe typical use case for this operation is \"binning\", \"bucketing\", or\n\"discretizing\". The values are assigned to bucket-indices based on the edges\nlisted in 'sortedSequence'. This operation returns the bucket-index for each\nvalue.\n\nThe side argument controls which index is returned if a value lands exactly\non an edge.\n\nThe axis is not settable for this operation. It always operates on the\ninnermost dimension (axis=-1). The operation will accept any number of outer\ndimensions.\n\nNote: This operation assumes that 'sortedSequence' is sorted along the\ninnermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not\nsorted no error is raised and the content of the returned tensor is not well\ndefined.\n\n```js\nconst edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);\nlet values = tf.tensor1d([0.0, 4.1, 12.0]);\nconst result1 = tf.searchSorted(edges, values, 'left');\nresult1.print(); // [1, 2, 4]\n\nconst seq = tf.tensor1d([0, 3, 9, 10, 10]);\nvalues = tf.tensor1d([0, 4, 10]);\nconst result2 = tf.searchSorted(seq, values, 'left');\nresult2.print(); // [0, 2, 3]\nconst result3 = tf.searchSorted(seq, values, 'right');\nresult3.print(); // [1, 2, 5]\n\nconst sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],\n                                     [1., 2., 3., 4., 5.]]);\nvalues = tf.tensor2d([[9.8, 2.1, 4.3],\n                       [0.1, 6.6, 4.5, ]]);\nconst result4 = tf.searchSorted(sortedSequence, values, 'left');\nresult4.print(); // [[4, 1, 2], [0, 5, 4]]\n```",
              "fileName": "#80",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/search_sorted.ts#L80-L114",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.searchSorted",
              "urlHash": "searchSorted"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "topk",
              "paramStr": "(x, k?, sorted?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "1-D or higher [tf.Tensor](#class:Tensor) with last dimension being at least `k`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "k",
                  "documentation": "Number of top elements to look for along the last dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "sorted",
                  "documentation": "If true, the resulting `k` elements will be sorted by the\nvalues in descending order.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{values: [tf.Tensor](#class:Tensor), indices: [tf.Tensor](#class:Tensor)}",
              "documentation": "Finds the values and indices of the `k` largest entries along the last\ndimension.\n\nIf the input is a vector (rank=1), finds the k largest entries in the vector\nand outputs their values and indices as vectors. Thus values[j] is the j-th\nlargest entry in input, and its index is indices[j].\nFor higher rank inputs, computes the top k entries along the last dimension.\n\nIf two elements are equal, the lower-index element appears first.\n\n```js\nconst a = tf.tensor2d([[1, 5], [4, 3]]);\nconst {values, indices} = tf.topk(a);\nvalues.print();\nindices.print();\n```",
              "fileName": "#52",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/topk.ts#L52-L78",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.topk",
              "urlHash": "topk"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "unique",
              "paramStr": "(x, axis?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A tensor (int32, string, bool).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The axis of the tensor to find the unique elements.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{values: [tf.Tensor](#class:Tensor), indices: [tf.Tensor1D](#class:Tensor)}",
              "documentation": "Finds unique elements along an axis of a tensor.\n\nIt returns a tensor `values` containing all of the unique elements along the\n`axis` of the given tensor `x` in the same order that they occur along the\n`axis` in `x`; `x` does not need to be sorted. It also returns a tensor\n`indices` the same size as the number of the elements in `x` along the `axis`\ndimension. It contains the index in the unique output `values`.\n\n```js\n// A 1-D tensor\nconst a = tf.tensor1d([1, 1, 2, 4, 4, 4, 7, 8, 8]);\nconst {values, indices} = tf.unique(a);\nvalues.print();   // [1, 2, 4, 7, 8,]\nindices.print();  // [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```\n\n```js\n// A 2-D tensor with axis=0\n//\n// 'a' is: [[1, 0, 0],\n//          [1, 0, 0],\n//          [2, 0, 0]]\nconst a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);\nconst {values, indices} = tf.unique(a, 0)\nvalues.print();   // [[1, 0, 0],\n                   //  [2, 0, 0]]\nindices.print();  // [0, 0, 1]\n```\n\n```js\n// A 2-D tensor with axis=1\n//\n// 'a' is: [[1, 0, 0],\n//          [1, 0, 0],\n//          [2, 0, 0]]\nconst a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);\nconst {values, indices} = tf.unique(a, 1)\nvalues.print();   // [[1, 0],\n                   //  [1, 0],\n                   //  [2, 0]]\nindices.print();  // [0, 1, 1]\n```",
              "fileName": "#78",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/unique.ts#L78-L89",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.unique",
              "urlHash": "unique"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Evaluation"
              },
              "symbolName": "upperBound",
              "paramStr": "(sortedSequence, values)",
              "parameters": [
                {
                  "name": "sortedSequence",
                  "documentation": ": N-D. Sorted sequence.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": ": N-D. Search values.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Searches for where a value would go in a sorted sequence.\n\nThis is not a method for checking containment (like javascript in).\n\nThe typical use case for this operation is \"binning\", \"bucketing\", or\n\"discretizing\". The values are assigned to bucket-indices based on the edges\nlisted in 'sortedSequence'. This operation returns the bucket-index for each\nvalue.\n\nThe index returned corresponds to the first edge greater than the value.\n\nThe axis is not settable for this operation. It always operates on the\ninnermost dimension (axis=-1). The operation will accept any number of outer\ndimensions.\n\nNote: This operation assumes that 'upperBound' is sorted along the\ninnermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not\nsorted no error is raised and the content of the returned tensor is not well\ndefined.\n\n```js\nconst seq = tf.tensor1d([0, 3, 9, 10, 10]);\nconst values = tf.tensor1d([0, 4, 10]);\nconst result = tf.upperBound(seq, values);\nresult.print(); // [1, 2, 5]\n```",
              "fileName": "#56",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/upper_bound.ts#L56-L59",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.upperBound",
              "urlHash": "upperBound"
            }
          ]
        },
        {
          "name": "Slicing and Joining",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "gatherND",
              "paramStr": "(x, indices)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor from which to gather values.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": "Index tensor, must be of type int32.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Gather slices from input tensor into a Tensor with shape specified by\n`indices`.\n\n`indices` is a K-dimensional integer tensor, best thought of as a\n(K-1)-dimensional tensor of indices into input, where each element defines a\nslice of input:\noutput[\\\\(i_0, ..., i_{K-2}\\\\)] = input[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n\nWhereas in [tf.gather()](#gather), `indices` defines slices into the first dimension of\ninput, in [tf.gatherND()](#gatherND), `indices` defines slices into the first N dimensions\nof input, where N = indices.shape[-1].\n\nThe last dimension of indices can be at most the rank of input:\nindices.shape[-1] <= input.rank\n\nThe last dimension of `indices` corresponds to elements\n(if indices.shape[-1] == input.rank) or slices\n(if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of\ninput.\nThe output tensor has shape\nindices.shape[:-1] + input.shape[indices.shape[-1]:]\n\nNote that on CPU, if an out of bound index is found, an error is returned. On\nGPU, if an out of bound index is found, a 0 is stored in the corresponding\noutput value.\n\n```js\nconst indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');\nconst input = tf.tensor2d([9, 10, 11, 12], [2, 2]);\ntf.gatherND(input, indices).print() // [10, 11]\n```",
              "fileName": "#63",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/gather_nd.ts#L63-L70",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.gatherND",
              "urlHash": "gatherND"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "meshgrid",
              "paramStr": "(x?, y?, __2?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "Tensor with rank geq 1.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "y",
                  "documentation": "Tensor with rank geq 1.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "__2",
                  "documentation": "",
                  "type": "{ indexing?: string; }",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)[]",
              "documentation": "Broadcasts parameters for evaluation on an N-D grid.\n\nGiven N one-dimensional coordinate arrays `*args`, returns a list `outputs`\nof N-D coordinate arrays for evaluating expressions on an N-D grid.\n\nNotes:\n`meshgrid` supports cartesian ('xy') and matrix ('ij') indexing conventions.\nWhen the `indexing` argument is set to 'xy' (the default), the broadcasting\ninstructions for the first two dimensions are swapped.\nExamples:\nCalling `const [X, Y] = meshgrid(x, y)` with the tensors\n\n```javascript\nconst x = [1, 2, 3];\nconst y = [4, 5, 6];\nconst [X, Y] = tf.meshgrid(x, y);\n// X = [[1, 2, 3],\n//      [1, 2, 3],\n//      [1, 2, 3]]\n// Y = [[4, 4, 4],\n//      [5, 5, 5],\n//      [6, 6, 6]]\n```",
              "fileName": "#57",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/meshgrid.ts#L57-L93",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.meshgrid",
              "urlHash": "meshgrid"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "scatterND",
              "paramStr": "(indices, updates, shape)",
              "parameters": [
                {
                  "name": "indices",
                  "documentation": "The tensor contains the indices into the output tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "updates",
                  "documentation": "The tensor contains the value for the indices.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "shape",
                  "documentation": ": The shape of the output tensor.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a new tensor by applying sparse updates to individual\nvalues or slices within a zero tensor of the given shape tensor according to\nindices. This operator is the inverse of the [tf.gatherND()](#gatherND) operator which\nextracts values or slices from a given tensor.\n\n```js\nconst indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\nconst updates = tf.tensor1d([9, 10, 11, 12]);\nconst shape = [8];\ntf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/scatter_nd.ts#L49-L64",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.scatterND",
              "urlHash": "scatterND"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "stridedSlice",
              "paramStr": "(x, begin, end, strides?, beginMask?, endMask?, ellipsisMask?, newAxisMask?, shrinkAxisMask?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The tensor to stride slice.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "begin",
                  "documentation": "The coordinates to start the slice from.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "end",
                  "documentation": ": The coordinates to end the slice at.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "strides",
                  "documentation": ": The size of the slice.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beginMask",
                  "documentation": ": If the ith bit of beginMask is set, begin[i] is ignored\nand the fullest possible range in that dimension is used instead.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "endMask",
                  "documentation": ": If the ith bit of endMask is set, end[i] is ignored\nand the fullest possible range in that dimension is used instead.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "ellipsisMask",
                  "documentation": "",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "newAxisMask",
                  "documentation": "",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "shrinkAxisMask",
                  "documentation": ": a bitmask where bit i implies that\nthe ith specification should shrink the dimensionality. begin and end must\nimply a slice of size 1 in the dimension.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Extracts a strided slice of a tensor.\n\nRoughly speaking, this op extracts a slice of size (end-begin)/stride from\nthe given input tensor (x). Starting at the location specified by begin the\nslice continues by adding stride to the index until all dimensions are not\nless than end. Note that a stride can be negative, which causes a reverse\nslice.\n\n```js\nconst t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n    [3, 2, 3]);\nt.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\nt.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n                                                     // [4, 4, 4]]]\nt.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n                                                     // [3, 3, 3]]]\n```",
              "fileName": "#61",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/strided_slice.ts#L61-L82",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.stridedSlice",
              "urlHash": "stridedSlice"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Slicing and Joining"
              },
              "symbolName": "tensorScatterUpdate",
              "paramStr": "(tensor, indices, updates)",
              "parameters": [
                {
                  "name": "tensor",
                  "documentation": "A Tensor. Tensor to copy/update.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": "The tensor contains the indices into the output tensor, must\nhave at least 2 axes: (num_updates, index_depth).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "updates",
                  "documentation": "The tensor contains the value for the indices.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Creates a new tensor by applying sparse updates to individual\nvalues or slices to the passed in tensor according to\nindices. This operator is the similar to scatterNd op, except that the\nudpates are scattered on an existing tensor (as opposed to a zero-tensor).\n\nIf indices contains duplicates, then we pick the last update for the index.\n\nIf an out of bound index is found on CPU, an error is returned.\n\nWarning: There are some GPU specific semantics for this operation.\n  - If an out of bound index is found, the index is ignored.\n  - The order in which updates are applied is nondeterministic, so the output\nwill be nondeterministic if indices contains duplicates.\n```js\nconst shape = [8];\nconst tensor = tf.ones(shape);\nconst indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\nconst updates = tf.tensor1d([9, 10, 11, 12]);\n\ntf.tensorScatterUpdate(tensor, indices, updates).print();\n    //[1, 11, 1, 10, 9, 1, 1, 12]\n```",
              "fileName": "#60",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/tensor_scatter_update.ts#L60-L85",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tensorScatterUpdate",
              "urlHash": "tensorScatterUpdate"
            }
          ]
        },
        {
          "name": "Ragged",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Ragged"
              },
              "symbolName": "raggedTensorToTensor",
              "paramStr": "(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": ": A Tensor. Must be one of the following types: 'int32'. The\ndesired shape of the output tensor. If left unspecified (empty), the\nminimal shape required to contain all the elements in the ragged tensor\n(the natural shape) will be used. If some dimensions are left\nunspecified, then the size of the natural shape is used in that\ndimension.\n\nNote that dense dimensions cannot be modified by the shape argument.\nTrying to change the size of a dense dimension will cause the op to fail.\nExamples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]\n\nnatural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]\n\nnatural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": ": A Tensor. A 1D tensor representing the values of the ragged\ntensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "defaultValue",
                  "documentation": ": A Tensor. Must have the same type as values. The\ndefaultValue when the shape is larger than the ragged tensor. The\ndefaultValue is broadcast until it is the shape of the output tensor,\nand then overwritten by values in the ragged tensor. The default value\nmust be compatible with this broadcast operation, and must have fewer\ndimensions than the value tensor.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rowPartitionTensors",
                  "documentation": ": A list of at least 1 Tensor objects with the same\ntype in: 'int32'.",
                  "type": "[tf.Tensor](#class:Tensor)[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rowPartitionTypes",
                  "documentation": ": A list of strings. The types of the row partition\ntensors. At present, these can be:\n\"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n\"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n\"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then\nit is preceeded by \"FIRST_DIM_SIZE\". The tensors are in the order of\nthe dimensions.",
                  "type": "string[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Create a dense tensor from a ragged tensor, possibly altering its shape.\n\nThe raggedTensorToTensor op creates a dense tensor from am array of row\npartition tensors, a value vector, and default values. If the shape is\nunspecified, the minimal shape required to contain all the elements in the\nragged tensor (the natural shape) will be used. If some dimensions are left\nunspecified, then the size of the natural shape is used in that dimension.\n\nThe defaultValue will be broadcast to the output shape. After that, the\nvalues from the ragged tensor overwrite the default values. Note that the\ndefaultValue must have less dimensions than the value.\n\nThe row partition tensors are in the order of the dimensions. At present, the\ntypes can be: \"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n   \"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n   \"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then it\nis preceded by \"FIRST_DIM_SIZE\".\n```",
              "fileName": "#78",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/ragged_tensor_to_tensor.ts#L78-L100",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.raggedTensorToTensor",
              "urlHash": "raggedTensorToTensor"
            }
          ]
        },
        {
          "name": "Spectral",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Spectral",
                "namespace": "spectral"
              },
              "symbolName": "fft",
              "namespace": "spectral",
              "paramStr": "(input)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The complex input to compute an fft over.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Fast Fourier transform.\n\nComputes the 1-dimensional discrete Fourier transform over the inner-most\ndimension of input.\n\n```js\nconst real = tf.tensor1d([1, 2, 3]);\nconst imag = tf.tensor1d([1, 2, 3]);\nconst x = tf.complex(real, imag);\n\nx.fft().print();  // tf.spectral.fft(x).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/spectral/fft.ts#L42-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.spectral.fft",
              "urlHash": "spectral.fft"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Spectral",
                "namespace": "spectral"
              },
              "symbolName": "ifft",
              "namespace": "spectral",
              "paramStr": "(input)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The complex input to compute an ifft over.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Inverse fast Fourier transform.\n\nComputes the inverse 1-dimensional discrete Fourier transform over the\ninner-most dimension of input.\n\n```js\nconst real = tf.tensor1d([1, 2, 3]);\nconst imag = tf.tensor1d([1, 2, 3]);\nconst x = tf.complex(real, imag);\n\nx.ifft().print();  // tf.spectral.ifft(x).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/spectral/ifft.ts#L42-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.spectral.ifft",
              "urlHash": "spectral.ifft"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Spectral",
                "namespace": "spectral"
              },
              "symbolName": "irfft",
              "namespace": "spectral",
              "paramStr": "(input)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The real value input to compute an irfft over.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Inversed real value input fast Fourier transform.\n\nComputes the 1-dimensional inversed discrete Fourier transform over the\ninner-most dimension of the real input.\n\n```js\nconst real = tf.tensor1d([1, 2, 3]);\nconst imag = tf.tensor1d([0, 0, 0]);\nconst x = tf.complex(real, imag);\n\nx.irfft().print();\n```",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/spectral/irfft.ts#L49-L84",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.spectral.irfft",
              "urlHash": "spectral.irfft"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Spectral",
                "namespace": "spectral"
              },
              "symbolName": "rfft",
              "namespace": "spectral",
              "paramStr": "(input, fftLength?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": "The real value input to compute an rfft over.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fftLength",
                  "documentation": "",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Real value input fast Fourier transform.\n\nComputes the 1-dimensional discrete Fourier transform over the\ninner-most dimension of the real input.\n\n```js\nconst real = tf.tensor1d([1, 2, 3]);\n\nreal.rfft().print();\n```",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/spectral/rfft.ts#L48-L97",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.spectral.rfft",
              "urlHash": "spectral.rfft"
            }
          ]
        },
        {
          "name": "Segment",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Segment"
              },
              "symbolName": "unsortedSegmentSum",
              "paramStr": "(x, segmentIds, numSegments)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The [tf.Tensor](#class:Tensor) that will be summed along its segments.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "segmentIds",
                  "documentation": "A [tf.Tensor1D](#class:Tensor) whose rank is equal to the rank of `x`'s\ndimension along the `axis`.  Maps each element of `x` to a segment.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numSegments",
                  "documentation": "The number of distinct `segmentIds`.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the sum along segments of a [tf.Tensor](#class:Tensor).\n\n```js\nconst x = tf.tensor1d([1, 2, 3, 4]);\nconst segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\nconst numSegments = 3;\n\nx.unsortedSegmentSum(segmentIds, numSegments).print()\n//or tf.unsortedSegmentSum(x, segmentIds, numSegments)\n```",
              "fileName": "#47",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/unsorted_segment_sum.ts#L47-L60",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.unsortedSegmentSum",
              "urlHash": "unsortedSegmentSum"
            }
          ]
        },
        {
          "name": "Moving Average",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Moving Average"
              },
              "symbolName": "movingAverage",
              "paramStr": "(v, x, decay, step?, zeroDebias?)",
              "parameters": [
                {
                  "name": "v",
                  "documentation": "The current moving average value.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "x",
                  "documentation": "New input value, must have the same shape and dtype as `v`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "decay",
                  "documentation": "The decay factor. Typical values are 0.95 and 0.99.",
                  "type": "number|[tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "step",
                  "documentation": "Step count.",
                  "type": "number|[tf.Scalar](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "zeroDebias",
                  "documentation": ": Whether zeroDebias is to be performed (default: `true`).",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Compute the moving average of a variable.\n\nWithout zeroDebias, the moving average operation is defined by:\n   `v += delta`\nwhere\n   `delta = (1 - decay) * (x - v)`\n\nWith zeroDebias (default), the `delta` term is scaled to debias the\neffect of the (assumed) zero-initialization of `v`.\n   `delta /= (1 - decay ^ step)`\n\nFor more details on the zero-debiasing algorithm, see:\n   https://arxiv.org/abs/1412.6980\n\nNote that this function is completely stateless and does not keep track of\nstep count. The step count needs to be maintained by the caller and passed\nin as `step`.",
              "fileName": "#60",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/moving_average.ts#L60-L82",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.movingAverage",
              "urlHash": "movingAverage"
            }
          ]
        },
        {
          "name": "Dropout",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Dropout"
              },
              "symbolName": "dropout",
              "paramStr": "(x, rate, noiseShape?, seed?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "A floating point Tensor or TensorLike.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rate",
                  "documentation": "A float in the range [0, 1). The probability that each element\nof x is discarded.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "noiseShape",
                  "documentation": "An array of numbers of type int32, representing the\nshape for randomly generated keep/drop flags. If the noiseShape has null\nvalue, it will be automatically replaced with the x's relative dimension\nsize. Optional.",
                  "type": "number[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "documentation": "Used to create random seeds. Optional.",
                  "type": "number|string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes dropout.\n\n```js\nconst x = tf.tensor1d([1, 2, 2, 1]);\nconst rate = 0.75;\nconst output = tf.dropout(x, rate);\noutput.print();\n```",
              "fileName": "#53",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/dropout.ts#L53-L77",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.dropout",
              "urlHash": "dropout"
            }
          ]
        },
        {
          "name": "Signal",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Signal",
                "namespace": "signal"
              },
              "symbolName": "frame",
              "namespace": "signal",
              "paramStr": "(signal, frameLength, frameStep, padEnd?, padValue?)",
              "parameters": [
                {
                  "name": "signal",
                  "documentation": "The input tensor to be expanded",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "frameLength",
                  "documentation": "Length of each frame",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "frameStep",
                  "documentation": "The frame hop size in samples.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "padEnd",
                  "documentation": "Whether to pad the end of signal with padValue.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "padValue",
                  "documentation": "A number to use where the input signal does\nnot exist when padEnd is True.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Expands input into frames of frameLength.\nSlides a window size with frameStep.\n\n```js\ntf.signal.frame([1, 2, 3], 2, 1).print();\n```",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/signal/frame.ts#L42-L68",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.signal.frame",
              "urlHash": "signal.frame"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Signal",
                "namespace": "signal"
              },
              "symbolName": "hammingWindow",
              "namespace": "signal",
              "paramStr": "(windowLength)",
              "parameters": [
                {
                  "name": "windowLength",
                  "documentation": "",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Generate a hamming window.\n\nSee: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n\n```js\ntf.signal.hammingWindow(10).print();\n```",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/signal/hamming_window.ts#L34-L36",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.signal.hammingWindow",
              "urlHash": "signal.hammingWindow"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Signal",
                "namespace": "signal"
              },
              "symbolName": "hannWindow",
              "namespace": "signal",
              "paramStr": "(windowLength)",
              "parameters": [
                {
                  "name": "windowLength",
                  "documentation": "",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)",
              "documentation": "Generate a Hann window.\n\nSee: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n\n```js\ntf.signal.hannWindow(10).print();\n```",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/signal/hann_window.ts#L34-L36",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.signal.hannWindow",
              "urlHash": "signal.hannWindow"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Signal",
                "namespace": "signal"
              },
              "symbolName": "stft",
              "namespace": "signal",
              "paramStr": "(signal, frameLength, frameStep, fftLength?, windowFn?)",
              "parameters": [
                {
                  "name": "signal",
                  "documentation": "1-dimensional real value tensor.",
                  "type": "[tf.Tensor1D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "frameLength",
                  "documentation": "The window length of samples.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "frameStep",
                  "documentation": "The number of samples to step.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fftLength",
                  "documentation": "The size of the FFT to apply.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "windowFn",
                  "documentation": "A callable that takes a window length and returns 1-d tensor.",
                  "type": "(length: number) => [tf.Tensor1D](#class:Tensor)",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the Short-time Fourier Transform of signals\nSee: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n\n```js\nconst input = tf.tensor1d([1, 1, 1, 1, 1])\ntf.signal.stft(input, 3, 1).print();\n```",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/signal/stft.ts#L43-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.signal.stft",
              "urlHash": "signal.stft"
            }
          ]
        },
        {
          "name": "Linear Algebra",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Linear Algebra",
                "namespace": "linalg"
              },
              "symbolName": "bandPart",
              "namespace": "linalg",
              "paramStr": "(a, numLower, numUpper)",
              "parameters": [
                {
                  "name": "a",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numLower",
                  "documentation": "Number of subdiagonals to keep.\nIf negative, keep entire lower triangle.",
                  "type": "number|[tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numUpper",
                  "documentation": "Number of subdiagonals to keep.\nIf negative, keep entire upper triangle.",
                  "type": "number|[tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Copy a tensor setting everything outside a central band in each innermost\nmatrix to zero.\n\nThe band part is computed as follows: Assume input has `k` dimensions\n`[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where\n`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\nThe indicator function\n`in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)`\n`&& (num_upper < 0 || (n-m) <= num_upper)`\n\n```js\nconst x = tf.tensor2d([[ 0,  1,  2, 3],\n                        [-1,  0,  1, 2],\n                        [-2, -1,  0, 1],\n                        [-3, -2, -1, 0]]);\nlet y = tf.linalg.bandPart(x, 1, -1);\ny.print(); // [[ 0,  1,  2, 3],\n            //  [-1,  0,  1, 2],\n            //  [ 0, -1,  0, 1],\n            //  [ 0, 0 , -1, 0]]\nlet z = tf.linalg.bandPart(x, 2, 1);\nz.print(); // [[ 0,  1,  0, 0],\n            //  [-1,  0,  1, 0],\n            //  [-2, -1,  0, 1],\n            //  [ 0, -2, -1, 0]]\n```",
              "fileName": "#76",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/linalg/band_part.ts#L76-L139",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.linalg.bandPart",
              "urlHash": "linalg.bandPart"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Linear Algebra",
                "namespace": "linalg"
              },
              "symbolName": "gramSchmidt",
              "namespace": "linalg",
              "paramStr": "(xs)",
              "parameters": [
                {
                  "name": "xs",
                  "documentation": "The vectors to be orthogonalized, in one of the two following\nformats:\n- An Array of [tf.Tensor1D](#class:Tensor).\n- A [tf.Tensor2D](#class:Tensor), i.e., a matrix, in which case the vectors are the rows\nof `xs`.\nIn each case, all the vectors must have the same length and the length\nmust be greater than or equal to the number of vectors.",
                  "type": "[tf.Tensor1D](#class:Tensor)[]|[tf.Tensor2D](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor1D](#class:Tensor)[]|[tf.Tensor2D](#class:Tensor)",
              "documentation": "Gram-Schmidt orthogonalization.\n\n```js\nconst x = tf.tensor2d([[1, 2], [3, 4]]);\nlet y = tf.linalg.gramSchmidt(x);\ny.print();\nconsole.log('Orthogonalized:');\ny.dot(y.transpose()).print();  // should be nearly the identity matrix.\nconsole.log('First row direction maintained:');\nconst data = await y.array();\nconsole.log(data[0][1] / data[0][0]);  // should be nearly 2.\n```",
              "fileName": "#60",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/linalg/gram_schmidt.ts#L60-L107",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.linalg.gramSchmidt",
              "urlHash": "linalg.gramSchmidt"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Linear Algebra",
                "namespace": "linalg"
              },
              "symbolName": "qr",
              "namespace": "linalg",
              "paramStr": "(x, fullMatrices?)",
              "parameters": [
                {
                  "name": "x",
                  "documentation": "The [tf.Tensor](#class:Tensor) to be QR-decomposed. Must have rank >= 2. Suppose\nit has the shape `[..., M, N]`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fullMatrices",
                  "documentation": "An optional boolean parameter. Defaults to `false`.\nIf `true`, compute full-sized `Q`. If `false` (the default),\ncompute only the leading N columns of `Q` and `R`.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[[tf.Tensor](#class:Tensor), [tf.Tensor](#class:Tensor)]",
              "documentation": "Compute QR decomposition of m-by-n matrix using Householder transformation.\n\nImplementation based on\n   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]\n(http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)\n\n```js\nconst a = tf.tensor2d([[1, 2], [3, 4]]);\nlet [q, r] = tf.linalg.qr(a);\nconsole.log('Q');\nq.print();\nconsole.log('R');\nr.print();\nconsole.log('Orthogonalized');\nq.dot(q.transpose()).print()  // should be nearly the identity matrix.\nconsole.log('Reconstructed');\nq.dot(r).print(); // should be nearly [[1, 2], [3, 4]];\n```",
              "fileName": "#84",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/linalg/qr.ts#L84-L118",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.linalg.qr",
              "urlHash": "linalg.qr"
            }
          ]
        },
        {
          "name": "Sparse",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Sparse"
              },
              "symbolName": "sparseFillEmptyRows",
              "paramStr": "(indices, values, denseShape, defaultValue)",
              "parameters": [
                {
                  "name": "indices",
                  "documentation": ": 2-D. The indices of the sparse tensor.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "values",
                  "documentation": ": 1-D. The values of the sparse tensor.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "denseShape",
                  "documentation": ": 1-D. The shape of the sparse tensor.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "defaultValue",
                  "documentation": ": 0-D. Default value to insert into location [row, 0, ...,\n0] for rows missing from the input sparse tensor.",
                  "type": "[tf.Scalar](#class:Tensor)|ScalarLike",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "The input SparseTensor is represented via the map of inputs {`indices`,\n`values`, `denseShape`}. The output SparseTensor has the same `denseShape`\nbut with indices `outputIndices` and values `outputValues`. This op inserts a\nsingle entry for every row that doesn't have any values. The index is created\nas `[row, 0, ..., 0]` and the inserted value is `defaultValue`.\n\nFor example, suppose `spInput` has shape [5, 6] and non-empty values:\n[0, 1]: a\n[0, 3]: b\n[2, 0]: c\n[3, 1]: d\n\nRows 1 and 4 are empty, so the output will be of shape [5, 6] with values:\n[0, 1]: a\n[0, 3]: b\n[1, 0]: `defaultValue`\n[2, 0]: c\n[3, 1]: d\n[4, 0]: `defaultValue`\n\nThe output SparseTensor will be in row-major order and will have the same\nshape as the input.\n\nThis op also returns an indicator vector shaped [dense_shape[0]] such that\nemptyRowIndicator[i] = True iff row i was an empty row.\n\nAnd a reverse index map vector shaped [indices.shape[0]] that is used during\nbackpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==\noutputIndices[outi, j] for all j\n\n```js\nconst result = tf.sparse.sparseFillEmptyRows(\n   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],\n   [0, 10, 13, 14, 32, 33], [5, 6], -1);\nconsole.log(result);\nresult['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],\n                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]\nresult['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]\nresult['emptyRowIndicator'].print(); // [false, false, true, false, true]\nresult['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]\n```",
              "fileName": "#82",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sparse/sparse_fill_empty_rows.ts#L82-L125",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sparseFillEmptyRows",
              "urlHash": "sparseFillEmptyRows"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Sparse"
              },
              "symbolName": "sparseReshape",
              "paramStr": "(inputIndices, inputShape, newShape)",
              "parameters": [
                {
                  "name": "inputIndices",
                  "documentation": ": 2-D. N x R_in matrix with the indices of non-empty\nvalues in a SparseTensor.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "inputShape",
                  "documentation": ": 1-D. R_in Tensor1D with the input SparseTensor's dense\nshape.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "newShape",
                  "documentation": ": 1-D. R_out Tensor1D with the requested new dense shape.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "This operation has the same semantics as reshape on the represented dense\ntensor. The `inputIndices` are recomputed based on the requested `newShape`.\nIf one component of `newShape` is the special value -1, the size of that\ndimension is computed so that the total dense size remains constant. At most\none component of `newShape` can be -1. The number of dense elements implied\nby `newShape` must be the same as the number of dense elements originally\nimplied by `inputShape`. Reshaping does not affect the order of values in the\nSparseTensor. If the input tensor has rank R_in and N non-empty values, and\n`newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n`inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n`outputShape` has length R_out.\n\n```js\nconst result = tf.sparse.sparseReshape(\n   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n   [2, 3, 6], [9, -1]);\nconsole.log(result);\nresult['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\nresult['outputShape'].print(); // [9, 4]\n```",
              "fileName": "#60",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sparse/sparse_reshape.ts#L60-L90",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sparseReshape",
              "urlHash": "sparseReshape"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Sparse"
              },
              "symbolName": "sparseSegmentMean",
              "paramStr": "(data, indices, segmentIds)",
              "parameters": [
                {
                  "name": "data",
                  "documentation": ": A Tensor of at least one dimension with data that will be\nassembled in the output.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": ": A 1-D Tensor with indices into data. Has same rank as\nsegmentIds.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "segmentIds",
                  "documentation": ": A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the mean along sparse segments of a tensor.\n\n```js\nconst c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);\n// Select two rows, one segment.\nconst result1 = tf.sparse.sparseSegmentMean(c,\n                                           tf.tensor1d([0, 1], 'int32'),\n                                           tf.tensor1d([0, 0], 'int32'));\nresult1.print(); // [[0, 0, 0, 0]]\n\n// Select two rows, two segments.\nconst result2 = tf.sparse.sparseSegmentMean(c,\n                                             tf.tensor1d([0, 1], 'int32'),\n                                             tf.tensor1d([0, 1], 'int32'));\nresult2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n\n// Select all rows, two segments.\nconst result3 = tf.sparse.sparseSegmentMean(c,\n                                             tf.tensor1d([0, 1, 2], 'int32'),\n                                             tf.tensor1d([0, 1, 1], 'int32'));\nresult3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sparse/sparse_segment_mean.ts#L59-L88",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sparseSegmentMean",
              "urlHash": "sparseSegmentMean"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "Sparse"
              },
              "symbolName": "sparseSegmentSum",
              "paramStr": "(data, indices, segmentIds)",
              "parameters": [
                {
                  "name": "data",
                  "documentation": ": A Tensor of at least one dimension with data that will be\nassembled in the output.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "indices",
                  "documentation": ": A 1-D Tensor with indices into data. Has same rank as\nsegmentIds.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "segmentIds",
                  "documentation": ": A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the sum along sparse segments of a tensor.\n\n```js\nconst c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);\n// Select two rows, one segment.\nconst result1 = tf.sparse.sparseSegmentSum(c,\n                                           tf.tensor1d([0, 1], 'int32'),\n                                           tf.tensor1d([0, 0], 'int32'));\nresult1.print(); // [[0, 0, 0, 0]]\n\n// Select two rows, two segments.\nconst result2 = tf.sparse.sparseSegmentSum(c,\n                                           tf.tensor1d([0, 1], 'int32'),\n                                           tf.tensor1d([0, 1], 'int32'));\nresult2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n\n// Select all rows, two segments.\nconst result3 = tf.sparse.sparseSegmentSum(c,\n                                           tf.tensor1d([0, 1, 2], 'int32'),\n                                           tf.tensor1d([0, 0, 1], 'int32'));\nresult3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/sparse/sparse_segment_sum.ts#L59-L88",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.sparseSegmentSum",
              "urlHash": "sparseSegmentSum"
            }
          ]
        },
        {
          "name": "String",
          "symbols": [
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "String"
              },
              "symbolName": "staticRegexReplace",
              "paramStr": "(input, pattern, rewrite, replaceGlobal?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": ": A Tensor of type string. The text to be processed.",
                  "type": "[tf.Tensor](#class:Tensor) | [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "pattern",
                  "documentation": ": A string. The regular expression to match the input.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rewrite",
                  "documentation": ": A string. The rewrite to be applied to the matched\nexpression.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "replaceGlobal",
                  "documentation": ": An optional bool. Defaults to True. If True, the\nreplacement is global, otherwise the replacement is done only on the\nfirst match.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Replace the match of a `pattern` in `input` with `rewrite`.\n\n```js\nconst result = tf.string.staticRegexReplace(\n     ['format       this   spacing      better'], ' +', ' ');\nresult.print(); // ['format this spacing better']\n```",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/string/static_regex_replace.ts#L45-L54",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.staticRegexReplace",
              "urlHash": "staticRegexReplace"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "String"
              },
              "symbolName": "stringNGrams",
              "paramStr": "(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences)",
              "parameters": [
                {
                  "name": "data",
                  "documentation": ": The values tensor of the ragged string tensor to make ngrams out\nof. Must be a 1D string tensor.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "dataSplits",
                  "documentation": ": The splits tensor of the ragged string tensor to make\nngrams out of.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "separator",
                  "documentation": ": The string to append between elements of the token. Use \"\"\nfor no separator.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "nGramWidths",
                  "documentation": ": The sizes of the ngrams to create.",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "leftPad",
                  "documentation": ": The string to use to pad the left side of the ngram sequence.\nOnly used if pad_width !== 0.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "rightPad",
                  "documentation": ": The string to use to pad the right side of the ngram\nsequence. Only used if pad_width !== 0.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "padWidth",
                  "documentation": ": The number of padding elements to add to each side of each\nsequence. Note that padding will never be greater than `nGramWidths`-1\nregardless of this value. If `padWidth`=-1, then add max(`nGramWidths`)-1\nelements.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "preserveShortSequences",
                  "documentation": ": If true, then ensure that at least one ngram\nis generated for each input sequence. In particular, if an input sequence\nis shorter than min(ngramWidth) + 2*padWidth, then generate a single\nngram containing the entire sequence. If false, then no ngrams are\ngenerated for these short input sequences.",
                  "type": "boolean",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "Creates ngrams from ragged string data.\n\nThis op accepts a ragged tensor with 1 ragged dimension containing only\nstrings and outputs a ragged tensor with 1 ragged dimension containing ngrams\nof that string, joined along the innermost axis.\n\n```js\nconst result = tf.string.stringNGrams(\n   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),\n   '|', [1, 2], 'LP', 'RP', -1, false);\nresult['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',\n                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']\nresult['nGramsSplits'].print(); // [0, 5, 10]\n```",
              "fileName": "#67",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/string/string_n_grams.ts#L67-L97",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.stringNGrams",
              "urlHash": "stringNGrams"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "String"
              },
              "symbolName": "stringSplit",
              "paramStr": "(input, delimiter, skipEmpty?)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": ": 1-D. Strings to split.",
                  "type": "[tf.Tensor1D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "delimiter",
                  "documentation": ": 0-D. Delimiter characters, or empty string.",
                  "type": "[tf.Scalar](#class:Tensor)|ScalarLike",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "skipEmpty",
                  "documentation": ": Optional. If true, skip the empty strings from the result.\nDefaults to true.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{[name: string]: [tf.Tensor](#class:Tensor)}",
              "documentation": "Split elements of `input` based on `delimiter` into a SparseTensor .\n\nLet N be the size of source (typically N will be the batch size). Split each\nelement of `input` based on `delimiter` and return a SparseTensor containing\nthe splitted tokens. Empty tokens are ignored if `skipEmpty` is set to True.\n\n`delimiter` can be empty, or a string of split characters. If `delimiter` is\nan empty string, each element of `input` is split into individual\ncharacter strings. Otherwise every character of `delimiter` is a potential\nsplit point.\n\n```js\nconst result = tf.string.stringSplit(['hello world',  'a b c'], ' ');\nresult['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\nresult['values'].print(); // ['hello', 'world', 'a', 'b', 'c']\nresult['shape'].print(); // [2, 3]\n```",
              "fileName": "#58",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/string/string_split.ts#L58-L79",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.stringSplit",
              "urlHash": "stringSplit"
            },
            {
              "docInfo": {
                "heading": "Operations",
                "subheading": "String"
              },
              "symbolName": "stringToHashBucketFast",
              "paramStr": "(input, numBuckets)",
              "parameters": [
                {
                  "name": "input",
                  "documentation": ": The strings to assign a hash bucket.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numBuckets",
                  "documentation": ": The number of buckets.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Converts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\nThe hash function is deterministic on the content of the string within the\nprocess and will never change. However, it is not suitable for cryptography.\nThis function may be used when CPU time is scarce and inputs are trusted or\nunimportant. There is a risk of adversaries constructing inputs that all hash\nto the same bucket.\n\n```js\nconst result = tf.string.stringToHashBucketFast(\n   ['Hello', 'TensorFlow', '2.x'], 3);\nresult.print(); // [0, 2, 2]\n```",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/string/string_to_hash_bucket_fast.ts#L46-L58",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.stringToHashBucketFast",
              "urlHash": "stringToHashBucketFast"
            }
          ]
        }
      ]
    },
    {
      "name": "Training",
      "description": "<p>We also provide an API to do perform training, and\ncompute gradients. We compute gradients eagerly, users provide a function\nthat is a combination of operations and we automatically differentiate\nthat function's output with respect to its inputs.\n<p>For those familiar with TensorFlow, the API we expose exactly mirrors\nthe TensorFlow Eager API.\n</p>",
      "subheadings": [
        {
          "name": "Gradients",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "grad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function f(x), to compute gradient for.",
                  "type": "(x: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(\n    x: [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array|[tf.Tensor](#class:Tensor), dy?: [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array|[tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
              "documentation": "Provided `f(x)`, returns another function `g(x, dy?)`, which gives the\ngradient of `f(x)` with respect to `x`.\n\nIf `dy` is provided, the gradient of `f(x).mul(dy).sum()` with respect to\n`x` is computed instead. `f(x)` must take a single tensor `x` and return a\nsingle tensor `y`. If `f()` takes multiple inputs, use [tf.grads()](#grads) instead.\n\n```js\n// f(x) = x ^ 2\nconst f = x => x.square();\n// f'(x) = 2x\nconst g = tf.grad(f);\n\nconst x = tf.tensor1d([2, 3]);\ng(x).print();\n```\n\n```js\n// f(x) = x ^ 3\nconst f = x => x.pow(tf.scalar(3, 'int32'));\n// f'(x) = 3x ^ 2\nconst g = tf.grad(f);\n// f''(x) = 6x\nconst gg = tf.grad(g);\n\nconst x = tf.tensor1d([2, 3]);\ngg(x).print();\n```",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L59-L80",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.grad",
              "urlHash": "grad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "grads",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function `f(x1, x2,...)` to compute gradients for.",
                  "type": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(\n    args: Array, dy?: [tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array) => [tf.Tensor](#class:Tensor)[]",
              "documentation": "Provided `f(x1, x2,...)`, returns another function `g([x1, x2,...], dy?)`,\nwhich gives an array of gradients of `f()` with respect to each input\n[`x1`,`x2`,...].\n\nIf `dy` is passed when calling `g()`, the gradient of\n`f(x1,...).mul(dy).sum()` with respect to each input is computed instead.\nThe provided `f` must take one or more tensors and return a single tensor\n`y`. If `f()` takes a single input, we recommend using [tf.grad()](#grad) instead.\n\n```js\n// f(a, b) = a * b\nconst f = (a, b) => a.mul(b);\n// df / da = b, df / db = a\nconst g = tf.grads(f);\n\nconst a = tf.tensor1d([2, 3]);\nconst b = tf.tensor1d([-2, -3]);\nconst [da, db] = g([a, b]);\nconsole.log('da');\nda.print();\nconsole.log('db');\ndb.print();\n```",
              "fileName": "#111",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L111-L137",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.grads",
              "urlHash": "grads"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "customGrad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to evaluate in forward mode, which should return\n`{value: Tensor, gradFunc: (dy, saved) => Tensor[]}`, where `gradFunc`\nreturns the custom gradients of `f` with respect to its inputs.",
                  "type": "(a: [tf.Tensor](#class:Tensor), b: [tf.Tensor](#class:Tensor),..., [tf.GraphModel.[tf.LayersModel.save()](#tf.LayersModel.save)()](#tf.GraphModel.[tf.LayersModel.save()](#tf.LayersModel.save))?: Function) => {\nvalue: [tf.Tensor](#class:Tensor),\ngradFunc: (dy: [tf.Tensor](#class:Tensor), saved?: NamedTensorMap) => [tf.Tensor](#class:Tensor) | [tf.Tensor](#class:Tensor)[]\n}",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
              "documentation": "Overrides the gradient computation of a function `f`.\n\nTakes a function\n`f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]}`\nand returns another function `g(...inputs)` which takes the same inputs as\n`f`. When called, `g` returns `f().value`. In backward mode, custom gradients\nwith respect to each input of `f` are computed using `f().gradFunc`.\n\nThe `save` function passed to `f` should be used for saving tensors needed\nin the gradient. And the `saved` passed to the `gradFunc` is a\n`NamedTensorMap`, which contains those saved tensors.\n\n```js\nconst customOp = tf.customGrad((x, save) => {\n   // Save x to make sure it's available later for the gradient.\n   save([x]);\n   // Override gradient of our custom x ^ 2 op to be dy * abs(x);\n   return {\n     value: x.square(),\n     // Note `saved.x` which points to the `x` we saved earlier.\n     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]\n   };\n});\n\nconst x = tf.tensor1d([-1, -2, 3]);\nconst dx = tf.grad(x => customOp(x));\n\nconsole.log(`f(x):`);\ncustomOp(x).print();\nconsole.log(`f'(x):`);\ndx(x).print();\n```",
              "fileName": "#374",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L374-L377",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.customGrad",
              "urlHash": "customGrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "valueAndGrad",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "",
                  "type": "(x: [tf.Tensor](#class:Tensor)) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(\n    x: [tf.Tensor](#class:Tensor), dy?: [tf.Tensor](#class:Tensor)) => {\n  value: [tf.Tensor](#class:Tensor);\n  grad: [tf.Tensor](#class:Tensor);\n}",
              "documentation": "Like [tf.grad()](#grad), but also returns the value of `f()`. Useful when `f()`\nreturns a metric you want to show.\n\nThe result is a rich object with the following properties:\n- grad: The gradient of `f(x)` w.r.t. `x` (result of [tf.grad()](#grad)).\n- value: The value returned by `f(x)`.\n\n```js\n// f(x) = x ^ 2\nconst f = x => x.square();\n// f'(x) = 2x\nconst g = tf.valueAndGrad(f);\n\nconst x = tf.tensor1d([2, 3]);\nconst {value, grad} = g(x);\n\nconsole.log('value');\nvalue.print();\nconsole.log('grad');\ngrad.print();\n```",
              "fileName": "#164",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L164-L183",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.valueAndGrad",
              "urlHash": "valueAndGrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "valueAndGrads",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "",
                  "type": "(...args: [tf.Tensor](#class:Tensor)[]) => [tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "(\n    args: [tf.Tensor](#class:Tensor)[], dy?: [tf.Tensor](#class:Tensor)) => {\n  grads: [tf.Tensor](#class:Tensor)[];\n  value: [tf.Tensor](#class:Tensor);\n}",
              "documentation": "Like [tf.grads()](#grads), but returns also the value of `f()`. Useful when `f()`\nreturns a metric you want to show.\n\nThe result is a rich object with the following properties:\n- grads: The gradients of `f()` w.r.t. each input (result of [tf.grads()](#grads)).\n- value: The value returned by `f(x)`.\n\n```js\n// f(a, b) = a * b\nconst f = (a, b) => a.mul(b);\n// df/da = b, df/db = a\nconst g = tf.valueAndGrads(f);\n\nconst a = tf.tensor1d([2, 3]);\nconst b = tf.tensor1d([-2, -3]);\nconst {value, grads} = g([a, b]);\n\nconst [da, db] = grads;\n\nconsole.log('value');\nvalue.print();\n\nconsole.log('da');\nda.print();\nconsole.log('db');\ndb.print();\n```",
              "fileName": "#216",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L216-L242",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.valueAndGrads",
              "urlHash": "valueAndGrads"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Gradients"
              },
              "symbolName": "variableGrads",
              "paramStr": "(f, varList?)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to execute. f() should return a scalar.",
                  "type": "() => [tf.Scalar](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "varList",
                  "documentation": "The list of variables to compute the gradients with respect\nto. Defaults to all trainable variables.",
                  "type": "[tf.Variable](#class:Variable)[]",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "{value: [tf.Scalar](#class:Tensor), grads: {[name: string]: [tf.Tensor](#class:Tensor)}}",
              "documentation": "Computes and returns the gradient of f(x) with respect to the list of\ntrainable variables provided by `varList`. If no list is provided, it\ndefaults to all trainable variables.\n\n```js\nconst a = tf.variable(tf.tensor1d([3, 4]));\nconst b = tf.variable(tf.tensor1d([5, 6]));\nconst x = tf.tensor1d([1, 2]);\n\n// f(a, b) = a * x ^ 2 + b * x\nconst f = () => a.mul(x.square()).add(b.mul(x)).sum();\n// df/da = x ^ 2, df/db = x\nconst {value, grads} = tf.variableGrads(f);\n\nObject.keys(grads).forEach(varName => grads[varName].print());\n```",
              "fileName": "#274",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/gradients.ts#L274-L332",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.variableGrads",
              "urlHash": "variableGrads"
            }
          ]
        },
        {
          "name": "Optimizers",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "sgd",
              "namespace": "train",
              "paramStr": "(learningRate)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the SGD algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.SGDOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.SGDOptimizer](#class:train.Optimizer) that uses stochastic gradient descent.\n\n```js\n// Fit a quadratic function by learning the coefficients a, b, c.\nconst xs = tf.tensor1d([0, 1, 2, 3]);\nconst ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);\n\nconst a = tf.scalar(Math.random()).variable();\nconst b = tf.scalar(Math.random()).variable();\nconst c = tf.scalar(Math.random()).variable();\n\n// y = a * x^2 + b * x + c.\nconst f = x => a.mul(x.square()).add(b.mul(x)).add(c);\nconst loss = (pred, label) => pred.sub(label).square().mean();\n\nconst learningRate = 0.01;\nconst optimizer = tf.train.sgd(learningRate);\n\n// Train the model.\nfor (let i = 0; i < 10; i++) {\n   optimizer.minimize(() => loss(f(xs), ys));\n}\n\n// Make predictions.\nconsole.log(\n     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);\nconst preds = f(xs).dataSync();\npreds.forEach((pred, i) => {\n   console.log(`x: ${i}, pred: ${pred}`);\n});\n```",
              "fileName": "#64",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L64-L66",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.sgd",
              "urlHash": "train.sgd"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "momentum",
              "namespace": "train",
              "paramStr": "(learningRate, momentum, useNesterov?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Momentum gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "momentum",
                  "documentation": "The momentum to use for the momentum gradient descent\nalgorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "useNesterov",
                  "documentation": "",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.MomentumOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.MomentumOptimizer](#class:train.Optimizer) that uses momentum gradient\ndescent.\n\nSee\n[http://proceedings.mlr.press/v28/sutskever13.pdf](\nhttp://proceedings.mlr.press/v28/sutskever13.pdf)",
              "fileName": "#83",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L83-L86",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.momentum",
              "urlHash": "train.momentum"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adagrad",
              "namespace": "train",
              "paramStr": "(learningRate, initialAccumulatorValue?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adagrad gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "initialAccumulatorValue",
                  "documentation": "Starting value for the accumulators, must be\npositive.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.AdagradOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.AdagradOptimizer](#class:train.Optimizer) that uses the Adagrad algorithm.\nSee\n[http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](\nhttp://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)\nor\n[http://ruder.io/optimizing-gradient-descent/index.html#adagrad](\nhttp://ruder.io/optimizing-gradient-descent/index.html#adagrad)",
              "fileName": "#185",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L185-L188",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.adagrad",
              "urlHash": "train.adagrad"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adadelta",
              "namespace": "train",
              "paramStr": "(learningRate?, rho?, epsilon?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adadelta gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "rho",
                  "documentation": "The learning rate decay over each update.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A constant epsilon used to better condition the grad\nupdate.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.AdadeltaOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.AdadeltaOptimizer](#class:train.Optimizer) that uses the Adadelta algorithm.\nSee [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)",
              "fileName": "#145",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L145-L148",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.adadelta",
              "urlHash": "train.adadelta"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adam",
              "namespace": "train",
              "paramStr": "(learningRate?, beta1?, beta2?, epsilon?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adam gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta1",
                  "documentation": "The exponential decay rate for the 1st moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta2",
                  "documentation": "The exponential decay rate for the 2nd moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A small constant for numerical stability.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "AdamOptimizer",
              "documentation": "Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.\nSee [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)",
              "fileName": "#127",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L127-L131",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.adam",
              "urlHash": "train.adam"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "adamax",
              "namespace": "train",
              "paramStr": "(learningRate?, beta1?, beta2?, epsilon?, decay?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the Adamax gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta1",
                  "documentation": "The exponential decay rate for the 1st moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "beta2",
                  "documentation": "The exponential decay rate for the 2nd moment estimates.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A small constant for numerical stability.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "decay",
                  "documentation": "The learning rate decay over each update.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "AdamaxOptimizer",
              "documentation": "Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.\nSee [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)",
              "fileName": "#163",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L163-L167",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.adamax",
              "urlHash": "train.adamax"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Optimizers",
                "namespace": "train"
              },
              "symbolName": "rmsprop",
              "namespace": "train",
              "paramStr": "(learningRate, decay?, momentum?, epsilon?, centered?)",
              "parameters": [
                {
                  "name": "learningRate",
                  "documentation": "The learning rate to use for the RMSProp gradient\ndescent algorithm.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "decay",
                  "documentation": "The discounting factor for the history/coming gradient.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "momentum",
                  "documentation": "The momentum to use for the RMSProp gradient descent\nalgorithm.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "Small value to avoid zero denominator.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "centered",
                  "documentation": "If true, gradients are normalized by the estimated\nvariance of the gradient.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.RMSPropOptimizer](#class:train.Optimizer)",
              "documentation": "Constructs a [tf.RMSPropOptimizer](#class:train.Optimizer) that uses RMSProp gradient\ndescent. This implementation uses plain momentum and is not centered\nversion of RMSProp.\n\nSee\n[http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](\nhttp://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)",
              "fileName": "#108",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer_constructors.ts#L108-L113",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.train.rmsprop",
              "urlHash": "train.rmsprop"
            }
          ]
        },
        {
          "name": "Losses",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "absoluteDifference",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the absolute difference loss between two tensors.",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/absolute_difference.ts#L44-L60",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.absoluteDifference",
              "urlHash": "losses.absoluteDifference"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "computeWeightedLoss",
              "namespace": "losses",
              "paramStr": "(losses, weights?, reduction?)",
              "parameters": [
                {
                  "name": "losses",
                  "documentation": "Tensor of shape `[batch_size, d1, ..., dN]`.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`losses`, and must be broadcastable to `losses` (i.e., all\ndimensions must be either `1`, or the same as the corresponding\n`losses` dimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the weighted loss between two tensors.",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/compute_weighted_loss.ts#L43-L83",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.computeWeightedLoss",
              "urlHash": "losses.computeWeightedLoss"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "cosineDistance",
              "namespace": "losses",
              "paramStr": "(labels, predictions, axis, weights?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "documentation": "The dimension along which the cosine distance is computed.",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the cosine distance loss between two tensors.",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/cosine_distance.ts#L46-L63",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.cosineDistance",
              "urlHash": "losses.cosineDistance"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "hingeLoss",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the Hinge loss between two tensors.",
              "fileName": "#45",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/hinge_loss.ts#L45-L62",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.hingeLoss",
              "urlHash": "losses.hingeLoss"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "huberLoss",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, delta?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "delta",
                  "documentation": "Point where Huber loss changes from quadratic to linear.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`.",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the Huber loss between two tensors.",
              "fileName": "#50",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/huber_loss.ts#L50-L70",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.huberLoss",
              "urlHash": "losses.huberLoss"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "logLoss",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, epsilon?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "epsilon",
                  "documentation": "A small increment to avoid taking log of zero",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the log loss between two tensors.",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/log_loss.ts#L49-L69",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.logLoss",
              "urlHash": "losses.logLoss"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "meanSquaredError",
              "namespace": "losses",
              "paramStr": "(labels, predictions, weights?, reduction?)",
              "parameters": [
                {
                  "name": "labels",
                  "documentation": "The ground truth output tensor, same dimensions as\n'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "predictions",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the mean squared error between two tensors.",
              "fileName": "#43",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/mean_squared_error.ts#L43-L59",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.meanSquaredError",
              "urlHash": "losses.meanSquaredError"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "sigmoidCrossEntropy",
              "namespace": "losses",
              "paramStr": "(multiClassLabels, logits, weights?, labelSmoothing?, reduction?)",
              "parameters": [
                {
                  "name": "multiClassLabels",
                  "documentation": "The ground truth output tensor of shape\n[batch_size, num_classes], same dimensions as 'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "logits",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or the same rank as\n`labels`, and must be broadcastable to `labels` (i.e., all dimensions\nmust be either `1`, or the same as the corresponding `losses`\ndimension).",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "labelSmoothing",
                  "documentation": "If greater than 0, then smooth the labels.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the sigmoid cross entropy loss between two tensors.\n\nIf labelSmoothing is nonzero, smooth the labels towards 1/2:\n\n   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)\n                         + 0.5 * labelSmoothing",
              "fileName": "#93",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/sigmoid_cross_entropy.ts#L93-L119",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.sigmoidCrossEntropy",
              "urlHash": "losses.sigmoidCrossEntropy"
            },
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Losses",
                "namespace": "losses"
              },
              "symbolName": "softmaxCrossEntropy",
              "namespace": "losses",
              "paramStr": "(onehotLabels, logits, weights?, labelSmoothing?, reduction?)",
              "parameters": [
                {
                  "name": "onehotLabels",
                  "documentation": "One hot encoded labels\n[batch_size, num_classes], same dimensions as 'predictions'.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "logits",
                  "documentation": "The predicted outputs.",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "weights",
                  "documentation": "Tensor whose rank is either 0, or 1, and must be\nbroadcastable to `loss`  of shape [batch_size]",
                  "type": "[tf.Tensor](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "labelSmoothing",
                  "documentation": "If greater than 0, then smooth the labels.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "reduction",
                  "documentation": "Type of reduction to apply to loss. Should be of type\n`Reduction`",
                  "type": "Reduction",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the softmax cross entropy loss between two tensors.\n\nIf labelSmoothing is nonzero, smooth the labels towards 1/2:\n\n   newOnehotLabels = onehotLabels * (1 - labelSmoothing)\n                         + labelSmoothing / numClasses",
              "fileName": "#125",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/losses/softmax_cross_entropy.ts#L125-L154",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.losses.softmaxCrossEntropy",
              "urlHash": "losses.softmaxCrossEntropy"
            }
          ]
        },
        {
          "name": "Classes",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Training",
                "subheading": "Classes",
                "namespace": "train"
              },
              "symbolName": "Optimizer",
              "namespace": "train",
              "documentation": "",
              "fileName": "#42",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer.ts#L42-L166",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Training",
                    "subheading": "Optimizers"
                  },
                  "symbolName": "minimize",
                  "paramStr": "(f, returnCost?, varList?)",
                  "parameters": [
                    {
                      "name": "f",
                      "documentation": "The function to execute and whose output to minimize.",
                      "type": "() => [tf.Scalar](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "returnCost",
                      "documentation": "Whether to return the scalar cost value produced by\nexecuting `f()`.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "varList",
                      "documentation": "An optional list of variables to update. If specified, only\nthe trainable variables in varList will be updated by minimize. Defaults to\nall trainable variables.",
                      "type": "[tf.Variable](#class:Variable)[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.Scalar](#class:Tensor)\n      |null",
                  "documentation": "Executes `f()` and minimizes the scalar output of `f()` by computing\ngradients of y with respect to the list of trainable variables provided by\n`varList`. If no list is provided, it defaults to all trainable variables.",
                  "fileName": "#59",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer.ts#L59-L80",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.train.Optimizer.minimize"
                },
                {
                  "docInfo": {
                    "heading": "Training",
                    "subheading": "Optimizers"
                  },
                  "symbolName": "computeGradients",
                  "paramStr": "(f, varList?)",
                  "parameters": [
                    {
                      "name": "f",
                      "documentation": "The function to execute and whose output to use for computing\ngradients with respect to variables.",
                      "type": "() => [tf.Scalar](#class:Tensor)",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "varList",
                      "documentation": "An optional list of variables to compute gradients with\nrespect to. If specified, only the trainable variables in varList will have\ngradients computed with respect to. Defaults to all trainable variables.",
                      "type": "[tf.Variable](#class:Variable)[]",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "{value: [tf.Scalar](#class:Tensor), grads: {[name: string]: [tf.Tensor](#class:Tensor)}}",
                  "documentation": "Executes f() and computes the gradient of the scalar output of f() with\nrespect to the list of trainable variables provided by `varList`. If no\nlist is provided, it defaults to all trainable variables.",
                  "fileName": "#109",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer.ts#L109-L112",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.train.Optimizer.computeGradients"
                },
                {
                  "docInfo": {
                    "heading": "Training",
                    "subheading": "Optimizers"
                  },
                  "symbolName": "applyGradients",
                  "paramStr": "(variableGradients)",
                  "parameters": [
                    {
                      "name": "variableGradients",
                      "documentation": "A mapping of variable name to its gradient value.",
                      "type": "{[name: string]: [tf.Tensor](#class:Tensor)}|\n                          NamedTensor[]",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "void",
                  "documentation": "Updates variables by using the computed gradients.",
                  "fileName": "#121",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/optimizers/optimizer.ts#L121-L122",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.train.Optimizer.applyGradients"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "Serializable",
              "displayName": "tf.train.Optimizer",
              "urlHash": "class:train.Optimizer"
            }
          ]
        }
      ]
    },
    {
      "name": "Performance",
      "description": "",
      "subheadings": [
        {
          "name": "Memory",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "tidy",
              "paramStr": "(nameOrFn, fn?)",
              "parameters": [
                {
                  "name": "nameOrFn",
                  "documentation": "The name of the closure, or the function to execute.\nIf a name is provided, the 2nd argument should be the function.\nIf debug mode is on, the timing and the memory usage of the function\nwill be tracked and displayed on the console using the provided name.",
                  "type": "string|Function",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "fn",
                  "documentation": "The function to execute.",
                  "type": "Function",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}",
              "documentation": "Executes the provided function `fn` and after it is executed, cleans up all\nintermediate tensors allocated by `fn` except those returned by `fn`.\n`fn` must not return a Promise (async functions not allowed). The returned\nresult can be a complex object.\n\nUsing this method helps avoid memory leaks. In general, wrap calls to\noperations in [tf.tidy()](#tidy) for automatic memory cleanup.\n\nNOTE: Variables do *not* get cleaned up when inside a tidy(). If you want to\ndispose variables, please use [tf.disposeVariables()](#disposeVariables) or call dispose()\ndirectly on variables.\n\n```js\n// y = 2 ^ 2 + 1\nconst y = tf.tidy(() => {\n   // a, b, and one will be cleaned up when the tidy ends.\n   const one = tf.scalar(1);\n   const a = tf.scalar(2);\n   const b = a.square();\n\n   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n\n   // The value returned inside the tidy function will return\n   // through the tidy, in this case to the variable y.\n   return b.add(one);\n});\n\nconsole.log('numTensors (outside tidy): ' + tf.memory().numTensors);\ny.print();\n```",
              "fileName": "#190",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L190-L193",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.tidy",
              "urlHash": "tidy"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "dispose",
              "paramStr": "(container)",
              "parameters": [
                {
                  "name": "container",
                  "documentation": "an object that may be a [tf.Tensor](#class:Tensor) or may directly\ncontain [tf.Tensor](#class:Tensor)s, such as a `Tensor[]` or `{key: Tensor, ...}`. If\nthe object is not a [tf.Tensor](#class:Tensor) or does not contain `Tensors`, nothing\nhappens. In general it is safe to pass any object here, except that\n`Promise`s are not supported.",
                  "type": "void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Disposes any [tf.Tensor](#class:Tensor)s found within the provided object.",
              "fileName": "#206",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L206-L209",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.dispose",
              "urlHash": "dispose"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "keep",
              "paramStr": "(result)",
              "parameters": [
                {
                  "name": "result",
                  "documentation": "The tensor to keep from being disposed.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Keeps a [tf.Tensor](#class:Tensor) generated inside a [tf.tidy()](#tidy) from being disposed\nautomatically.\n\n```js\nlet b;\nconst y = tf.tidy(() => {\n   const one = tf.scalar(1);\n   const a = tf.scalar(2);\n\n   // b will not be cleaned up by the tidy. a and one will be cleaned up\n   // when the tidy ends.\n   b = tf.keep(a.square());\n\n   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n\n   // The value returned inside the tidy function will return\n   // through the tidy, in this case to the variable y.\n   return b.add(one);\n});\n\nconsole.log('numTensors (outside tidy): ' + tf.memory().numTensors);\nconsole.log('y:');\ny.print();\nconsole.log('b:');\nb.print();\n```",
              "fileName": "#243",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L243-L245",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.keep",
              "urlHash": "keep"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Memory"
              },
              "symbolName": "memory",
              "paramStr": "()",
              "parameters": [],
              "returnType": "MemoryInfo",
              "documentation": "Returns memory info at the current time in the program. The result is an\nobject with the following properties:\n\n- `numBytes`: Number of bytes allocated (undisposed) at this time.\n- `numTensors`: Number of unique tensors allocated.\n- `numDataBuffers`: Number of unique data buffers allocated\n   (undisposed) at this time, which is  the number of tensors\n   (e.g. `a.reshape(newShape)` makes a new Tensor that shares the same\n   data buffer with `a`).\n- `unreliable`: True if the memory usage is unreliable. See `reasons` when\n    `unreliable` is true.\n- `reasons`: `string[]`, reasons why the memory is unreliable, present if\n    `unreliable` is true.\n\nWebGL Properties:\n- `numBytesInGPU`: Number of bytes allocated (undisposed) in the GPU only at\n     this time.",
              "fileName": "#110",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L110-L112",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.memory",
              "urlHash": "memory"
            }
          ]
        },
        {
          "name": "Timing",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Timing"
              },
              "symbolName": "time",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "The function to execute and time.",
                  "type": "() => void",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<TimingInfo>",
              "documentation": "Executes `f()` and returns a promise that resolves with timing\ninformation.\n\nThe result is an object with the following properties:\n\n- `wallMs`: Wall execution time.\n- `kernelMs`: Kernel execution time, ignoring data transfer. If using the\nWebGL backend and the query timer extension is not available, this will\nreturn an error object.\n- On `WebGL` The following additional properties exist:\n   - `uploadWaitMs`: CPU blocking time on texture uploads.\n   - `downloadWaitMs`: CPU blocking time on texture downloads (readPixels).\n\n```js\nconst x = tf.randomNormal([20, 20]);\nconst time = await tf.time(() => x.matMul(x));\n\nconsole.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);\n```",
              "fileName": "#272",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L272-L274",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.time",
              "urlHash": "time"
            },
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Timing"
              },
              "symbolName": "nextFrame",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Promise<void>",
              "documentation": "Returns a promise that resolves when a requestAnimationFrame has completed.\n\nOn Node.js this uses setImmediate instead of requestAnimationFrame.\n\nThis is simply a sugar method so that users can do the following:\n`await tf.nextFrame();`",
              "fileName": "#37",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/browser_util.ts#L37-L39",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.nextFrame",
              "urlHash": "nextFrame"
            }
          ]
        },
        {
          "name": "Profile",
          "symbols": [
            {
              "docInfo": {
                "heading": "Performance",
                "subheading": "Profile"
              },
              "symbolName": "profile",
              "paramStr": "(f)",
              "parameters": [
                {
                  "name": "f",
                  "documentation": "",
                  "type": "() => (void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string} | Promise<void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}>)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<ProfileInfo>",
              "documentation": "Executes the provided function `f()` and returns a promise that resolves\nwith information about the function's memory use:\n- `newBytes`: the number of new bytes allocated\n- `newTensors`: the number of new tensors created\n- `peakBytes`: the peak number of bytes allocated\n- `kernels`: an array of objects for each kernel involved that reports\ntheir input and output shapes, number of bytes used, and number of new\ntensors created.\n- `kernelNames`: an array of unique strings with just the names of the\nkernels in the `kernels` array.\n\n```js\nconst profile = await tf.profile(() => {\n   const x = tf.tensor1d([1, 2, 3]);\n   let x2 = x.square();\n   x2.dispose();\n   x2 = x.square();\n   x2.dispose();\n   return x;\n});\n\nconsole.log(`newBytes: ${profile.newBytes}`);\nconsole.log(`newTensors: ${profile.newTensors}`);\nconsole.log(`byte usage over all kernels: ${profile.kernels.map(k =>\nk.totalBytesSnapshot)}`);\n```",
              "fileName": "#145",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L145-L148",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.profile",
              "urlHash": "profile"
            }
          ]
        }
      ]
    },
    {
      "name": "Environment",
      "description": "<p>TensorFlow.js can run mathematical operations on\ndifferent backends. Currently, we support WebGL and JavaScript\nCPU. By default, we choose the 'best' backend available, but\nallow users to customize their backend.</p>",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "Environment",
              "documentation": "The environment contains evaluated flags as well as the registered platform.\nThis is always used as a global singleton and can be retrieved with\n`tf.env()`.",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/environment.ts#L41-L177",
              "methods": [],
              "tags": [],
              "isClass": true,
              "displayName": "tf.Environment",
              "urlHash": "class:Environment"
            },
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "disposeVariables",
              "paramStr": "()",
              "parameters": [],
              "returnType": "void",
              "documentation": "Dispose all variables kept in backend engine.",
              "fileName": "#76",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L76-L78",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.disposeVariables",
              "urlHash": "disposeVariables"
            },
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "enableDebugMode",
              "paramStr": "()",
              "parameters": [],
              "returnType": "void",
              "documentation": "Enables debug mode which will log information about all executed kernels:\nthe elapsed time of the kernel execution, as well as the rank, shape, and\nsize of the output tensor.\n\nDebug mode will significantly slow down your application as it will\ndownload the result of every operation to the CPU. This should not be used in\nproduction. Debug mode does not affect the timing information of the kernel\nexecution as we do not measure download time in the kernel execution time.\n\nSee also: [tf.profile()](#profile), [tf.memory()](#memory).",
              "fileName": "#51",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L51-L53",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.enableDebugMode",
              "urlHash": "enableDebugMode"
            },
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "enableProdMode",
              "paramStr": "()",
              "parameters": [],
              "returnType": "void",
              "documentation": "Enables production mode which disables correctness checks in favor of\nperformance.",
              "fileName": "#33",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L33-L35",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.enableProdMode",
              "urlHash": "enableProdMode"
            },
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "engine",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Engine",
              "documentation": "It returns the global engine that keeps track of all tensors and backends.",
              "fileName": "#85",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L85-L87",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.engine",
              "urlHash": "engine"
            },
            {
              "docInfo": {
                "heading": "Environment"
              },
              "symbolName": "env",
              "paramStr": "()",
              "parameters": [],
              "returnType": "[tf.Environment](#class:Environment)",
              "documentation": "Returns the current environment (a global singleton).\n\nThe environment object contains the evaluated feature values as well as the\nactive platform.",
              "fileName": "#212",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/environment.ts#L212-L214",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.env",
              "urlHash": "env"
            }
          ]
        }
      ]
    },
    {
      "name": "Constraints",
      "description": "<p>Constraints are added to attributes\nof a Layer (such as weights, kernels, or biases) at\nconstruction time to clamp, or otherwise enforce an allowed range,\nof values for different components of the Layer.</p>",
      "subheadings": [
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Constraints",
                "subheading": "Classes",
                "namespace": "constraints"
              },
              "symbolName": "Constraint",
              "namespace": "constraints",
              "documentation": "Base class for functions that impose constraints on weight values",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/constraints.ts#L34-L40",
              "methods": [],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "serialization.Serializable",
              "displayName": "tf.constraints.Constraint",
              "urlHash": "class:constraints.Constraint"
            }
          ]
        },
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints"
              },
              "symbolName": "maxNorm",
              "namespace": "constraints",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "maxValue",
                  "type": "number",
                  "documentation": "Maximum norm for incoming weights",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "Axis along which to calculate norms.\n\n  For instance, in a `Dense` layer the weight matrix\n  has shape `[inputDim, outputDim]`,\n  set `axis` to `0` to constrain each weight vector\n  of length `[inputDim,]`.\n  In a `Conv2D` layer with `dataFormat=\"channels_last\"`,\n  the weight tensor has shape\n  `[rows, cols, inputDepth, outputDepth]`,\n  set `axis` to `[0, 1, 2]`\n  to constrain the weights of each filter tensor of size\n  `[rows, cols, inputDepth]`.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "MaxNorm weight constraint.\n\nConstrains the weights incident to each hidden unit\nto have a norm less than or equal to a desired value.\n\nReferences\n       - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting\nSrivastava, Hinton, et al.\n2014](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
              "fileName": "#26",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L26-L28",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.constraints.maxNorm",
              "urlHash": "constraints.maxNorm"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints"
              },
              "symbolName": "minMaxNorm",
              "namespace": "constraints",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minValue",
                  "type": "number",
                  "documentation": "Minimum norm for incoming weights",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "maxValue",
                  "type": "number",
                  "documentation": "Maximum norm for incoming weights",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "Axis along which to calculate norms.\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "rate",
                  "type": "number",
                  "documentation": "Rate for enforcing the constraint: weights will be rescaled to yield:\n`(1 - rate) * norm + rate * norm.clip(minValue, maxValue)`.\nEffectively, this means that rate=1.0 stands for strict\nenforcement of the constraint, while rate<1.0 means that\nweights will be rescaled at each step to slowly move\ntowards a value inside the desired interval.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L49-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.constraints.minMaxNorm",
              "urlHash": "constraints.minMaxNorm"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints"
              },
              "symbolName": "nonNeg",
              "namespace": "constraints",
              "paramStr": "()",
              "parameters": [],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "Constrains the weight to be non-negative.",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L44-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.constraints.nonNeg",
              "urlHash": "constraints.nonNeg"
            },
            {
              "docInfo": {
                "heading": "Constraints",
                "namespace": "constraints"
              },
              "symbolName": "unitNorm",
              "namespace": "constraints",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "axis",
                  "type": "number",
                  "documentation": "Axis along which to calculate norms.\n\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.constraints.Constraint](#class:constraints.Constraint)",
              "documentation": "Constrains the weights incident to each hidden unit to have unit norm.",
              "fileName": "#35",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L35-L37",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.constraints.unitNorm",
              "urlHash": "constraints.unitNorm"
            }
          ]
        }
      ]
    },
    {
      "name": "Initializers",
      "description": "<p>Initializers are used in Layers\nto establish the starting the values of weights, biases, kernels, \netc.</p>",
      "subheadings": [
        {
          "name": "Classes",
          "symbols": [
            {
              "docInfo": {
                "heading": "Initializers",
                "subheading": "Classes",
                "namespace": "initializers"
              },
              "symbolName": "Initializer",
              "namespace": "initializers",
              "documentation": "Initializer base class.",
              "fileName": "#35",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/initializers.ts#L35-L50",
              "methods": [],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "serialization.Serializable",
              "displayName": "tf.initializers.Initializer",
              "urlHash": "class:initializers.Initializer"
            }
          ]
        },
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "constant",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "value",
                  "type": "number",
                  "documentation": "The value for each element in the variable.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates values initialized to some constant.",
              "fileName": "#36",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L36-L38",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.constant",
              "urlHash": "initializers.constant"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "glorotNormal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Glorot normal initializer, also called Xavier normal initializer.\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor.\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf",
              "fileName": "#134",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L134-L136",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.glorotNormal",
              "urlHash": "initializers.glorotNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "glorotUniform",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Glorot uniform initializer, also called Xavier uniform initializer.\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.",
              "fileName": "#117",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L117-L119",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.glorotUniform",
              "urlHash": "initializers.glorotUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "heNormal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "He normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
              "fileName": "#150",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L150-L152",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.heNormal",
              "urlHash": "initializers.heNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "heUniform",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "He uniform initializer.\n\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / fan_in)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
              "fileName": "#166",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L166-L168",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.heUniform",
              "urlHash": "initializers.heUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "identity",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "gain",
                  "type": "number",
                  "documentation": "Multiplicative factor to apply to the identity matrix.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates the identity matrix.\nOnly use for square 2D matrices.",
              "fileName": "#83",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L83-L85",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.identity",
              "urlHash": "initializers.identity"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "leCunNormal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "LeCun normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(1 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReferences:\n   [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)\n   [Efficient Backprop](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf)",
              "fileName": "#183",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L183-L185",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.leCunNormal",
              "urlHash": "initializers.leCunNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "leCunUniform",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "LeCun uniform initializer.\n\nIt draws samples from a uniform distribution in the interval\n`[-limit, limit]` with `limit = sqrt(3 / fanIn)`,\nwhere `fanIn` is the number of input units in the weight tensor.",
              "fileName": "#196",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L196-L198",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.leCunUniform",
              "urlHash": "initializers.leCunUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "ones",
              "namespace": "initializers",
              "paramStr": "()",
              "parameters": [],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates tensors initialized to 1.",
              "fileName": "#27",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L27-L29",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.ones",
              "urlHash": "initializers.ones"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "orthogonal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "gain",
                  "type": "number",
                  "documentation": "Multiplicative factor to apply to the orthogonal matrix. Defaults to 1.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates a random orthogonal matrix.\n\nReference:\n[Saxe et al., http://arxiv.org/abs/1312.6120](http://arxiv.org/abs/1312.6120)",
              "fileName": "#208",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L208-L210",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.orthogonal",
              "urlHash": "initializers.orthogonal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "randomNormal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "type": "number",
                  "documentation": "Mean of the random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stddev",
                  "type": "number",
                  "documentation": "Standard deviation of the random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Used to seed the random generator.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a normal\ndistribution.",
              "fileName": "#59",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L59-L61",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.randomNormal",
              "urlHash": "initializers.randomNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "randomUniform",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "minval",
                  "type": "number",
                  "documentation": "Lower bound of the range of random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "maxval",
                  "type": "number",
                  "documentation": "Upper bound of the range of random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Used to seed the random generator.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a uniform\ndistribution.\n\nValues will be distributed uniformly between the configured minval and\nmaxval.",
              "fileName": "#49",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L49-L51",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.randomUniform",
              "urlHash": "initializers.randomUniform"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "truncatedNormal",
              "namespace": "initializers",
              "paramStr": "(args)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "mean",
                  "type": "number",
                  "documentation": "Mean of the random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "stddev",
                  "type": "number",
                  "documentation": "Standard deviation of the random values to generate.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Used to seed the random generator.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer that generates random values initialized to a truncated normal\ndistribution.\n\nThese values are similar to values from a `RandomNormal` except that values\nmore than two standard deviations from the mean are discarded and re-drawn.\nThis is the recommended initializer for neural network weights and filters.",
              "fileName": "#73",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L73-L75",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.truncatedNormal",
              "urlHash": "initializers.truncatedNormal"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "varianceScaling",
              "namespace": "initializers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "scale",
                  "type": "number",
                  "documentation": "Scaling factor (positive float).",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "mode",
                  "type": "'fanIn'|'fanOut'|'fanAvg'",
                  "documentation": "Fanning mode for inputs and outputs.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "distribution",
                  "type": "'normal'|'uniform'|'truncatedNormal'",
                  "documentation": "Probabilistic distribution of the values.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "seed",
                  "type": "number",
                  "documentation": "Random number generator seed.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.initializers.Initializer](#class:initializers.Initializer)",
              "documentation": "Initializer capable of adapting its scale to the shape of weights.\nWith distribution=NORMAL, samples are drawn from a truncated normal\ndistribution centered on zero, with `stddev = sqrt(scale / n)` where n is:\n   - number of input units in the weight tensor, if mode = FAN_IN.\n   - number of output units, if mode = FAN_OUT.\n   - average of the numbers of input and output units, if mode = FAN_AVG.\nWith distribution=UNIFORM,\nsamples are drawn from a uniform distribution\nwithin [-limit, limit], with `limit = sqrt(3 * scale / n)`.",
              "fileName": "#100",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L100-L102",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.varianceScaling",
              "urlHash": "initializers.varianceScaling"
            },
            {
              "docInfo": {
                "heading": "Initializers",
                "namespace": "initializers"
              },
              "symbolName": "zeros",
              "namespace": "initializers",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Zeros",
              "documentation": "Initializer that generates tensors initialized to 0.",
              "fileName": "#18",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L18-L20",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.initializers.zeros",
              "urlHash": "initializers.zeros"
            }
          ]
        }
      ]
    },
    {
      "name": "Regularizers",
      "description": "<p>Regularizers can be attached to various components\nof a Layer to add a 'scoring' function to help drive weights, or \nother trainable values, away from excessively large values.  They're\ntypically used to promote a notion that a 'simpler' model is better\nthan a complicated model, assuming equal performance.</p>",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers"
              },
              "symbolName": "l1",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "l1",
                  "type": "number",
                  "documentation": "L1 regularization rate. Defaults to 0.01.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L1 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x))",
              "fileName": "#35",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L35-L37",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.regularizers.l1",
              "urlHash": "regularizers.l1"
            },
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers"
              },
              "symbolName": "l1l2",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "l1",
                  "type": "number",
                  "documentation": "L1 regularization rate. Defaults to 0.01.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "l2",
                  "type": "number",
                  "documentation": "L2 regularization rate. Defaults to 0.01.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
              "fileName": "#22",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L22-L24",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.regularizers.l1l2",
              "urlHash": "regularizers.l1l2"
            },
            {
              "docInfo": {
                "heading": "Regularizers",
                "namespace": "regularizers"
              },
              "symbolName": "l2",
              "namespace": "regularizers",
              "paramStr": "(config?)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "l2",
                  "type": "number",
                  "documentation": "L2 regularization rate. Defaults to 0.01.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Regularizer",
              "documentation": "Regularizer for L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l2 * x^2)",
              "fileName": "#48",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L48-L50",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.regularizers.l2",
              "urlHash": "regularizers.l2"
            }
          ]
        }
      ]
    },
    {
      "name": "Data",
      "description": "<p>TensorFlow.js Data provides simple APIs to load and parse data \nfrom disk or over the web in a variety of formats, and to prepare \nthat data for use in machine learning models (e.g. via operations \nlike filter, map, shuffle, and batch).",
      "subheadings": [
        {
          "name": "Creation",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Creation",
                "namespace": "data"
              },
              "symbolName": "array",
              "namespace": "data",
              "paramStr": "(items)",
              "parameters": [
                {
                  "name": "items",
                  "documentation": "An array of elements that will be parsed as items in a dataset.",
                  "type": "tf.void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.data.Dataset](#class:data.Dataset)",
              "documentation": "Create a `Dataset` from an array of elements.\n\nCreate a Dataset from an array of objects:\n```js\nconst a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);\nawait a.forEachAsync(e => console.log(e));\n```\n\nCreate a Dataset from an array of numbers:\n```js\nconst a = tf.data.array([4, 5, 6]);\nawait a.forEachAsync(e => console.log(e));\n```",
              "fileName": "#581",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L581-L584",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.array",
              "urlHash": "data.array"
            },
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Creation",
                "namespace": "data",
                "configParamIndices": [
                  1
                ]
              },
              "symbolName": "csv",
              "namespace": "data",
              "paramStr": "(source, csvConfig?)",
              "parameters": [
                {
                  "name": "source",
                  "documentation": "URL or local path to get CSV file. If it's a local path, it\nmust have prefix `file://` and it only works in node environment.",
                  "type": "RequestInfo",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "csvConfig",
                  "documentation": "(Optional) A CSVConfig object that contains configurations\nof reading and decoding from CSV file(s).",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "hasHeader",
                  "type": "boolean",
                  "documentation": "A boolean value that indicates whether the first row of provided CSV file\nis a header line with column names, and should not be included in the data.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "columnNames",
                  "type": "string[]",
                  "documentation": "A list of strings that corresponds to the CSV column names, in order. If\nprovided, it ignores the column names inferred from the header row. If not\nprovided, infers the column names from the first row of the records. If\n`hasHeader` is false and `columnNames` is not provided, this method will\nthrow an error.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "columnConfigs",
                  "type": "{[key: string]: ColumnConfig}",
                  "documentation": "A dictionary whose key is column names, value is an object stating if this\ncolumn is required, column's data type, default value, and if this column\nis label. If provided, keys must correspond to names provided in\n`columnNames` or inferred from the file header lines. If any column is\nmarked as label, the .csv() API will return an array of two items: the\nfirst item is a dict of features key/value pairs, the second item is a dict\nof labels key/value pairs. If no column is marked as label returns a dict\nof features only.\n\nHas the following fields:\n- `required` If value in this column is required. If set to `true`, throw\nan error when it finds an empty value.\n\n- `dtype` Data type of this column. Could be int32, float32, bool, or\nstring.\n\n- `default` Default value of this column.\n\n- `isLabel` Whether this column is label instead of features. If isLabel is\n`true` for at least one column, the element in returned `CSVDataset` will\nbe an object of {xs: features, ys: labels}: xs is a dict of features\nkey/value pairs, ys is a dict of labels key/value pairs. If no column is\nmarked as label, returns a dict of features only.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "configuredColumnsOnly",
                  "type": "boolean",
                  "documentation": "If true, only columns provided in `columnConfigs` will be parsed and\nprovided during iteration.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "delimiter",
                  "type": "string",
                  "documentation": "The string used to parse each line of the input file.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "delimWhitespace",
                  "type": "boolean",
                  "documentation": "If true, delimiter field should be null. Parsing delimiter is whitespace\nand treat continuous multiple whitespace as one delimiter.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "[tf.data.CSVDataset](#class:data.CSVDataset)",
              "documentation": "Create a `CSVDataset` by reading and decoding CSV file(s) from provided URL\nor local path if it's in Node environment.\n\nNote: If isLabel in columnConfigs is `true` for at least one column, the\nelement in returned `CSVDataset` will be an object of\n`{xs:features, ys:labels}`: xs is a dict of features key/value pairs, ys\nis a dict of labels key/value pairs. If no column is marked as label,\nreturns a dict of features only.\n\n```js\nconst csvUrl =\n'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';\n\nasync function run() {\n   // We want to predict the column \"medv\", which represents a median value of\n   // a home (in $1000s), so we mark it as a label.\n   const csvDataset = tf.data.csv(\n     csvUrl, {\n       columnConfigs: {\n         medv: {\n           isLabel: true\n         }\n       }\n     });\n\n   // Number of features is the number of column names minus one for the label\n   // column.\n   const numOfFeatures = (await csvDataset.columnNames()).length - 1;\n\n   // Prepare the Dataset for training.\n   const flattenedDataset =\n     csvDataset\n     .map(({xs, ys}) =>\n       {\n         // Convert xs(features) and ys(labels) from object form (keyed by\n         // column name) to array form.\n         return {xs:Object.values(xs), ys:Object.values(ys)};\n       })\n     .batch(10);\n\n   // Define the model.\n   const model = tf.sequential();\n   model.add(tf.layers.dense({\n     inputShape: [numOfFeatures],\n     units: 1\n   }));\n   model.compile({\n     optimizer: tf.train.sgd(0.000001),\n     loss: 'meanSquaredError'\n   });\n\n   // Fit the model using the prepared Dataset\n   return model.fitDataset(flattenedDataset, {\n     epochs: 10,\n     callbacks: {\n       onEpochEnd: async (epoch, logs) => {\n         console.log(epoch + ':' + logs.loss);\n       }\n     }\n   });\n}\n\nawait run();\n```",
              "fileName": "#106",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/readers.ts#L106-L109",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.csv",
              "urlHash": "data.csv"
            },
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Creation",
                "namespace": "data",
                "configParamIndices": [
                  1
                ]
              },
              "symbolName": "generator",
              "namespace": "data",
              "paramStr": "(generator)",
              "parameters": [
                {
                  "name": "generator",
                  "documentation": "A JavaScript generator function that returns a JavaScript\niterator.",
                  "type": "() => Iterator| Promise<Iterator<void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}>>",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.data.Dataset](#class:data.Dataset)",
              "documentation": "Create a `Dataset` that produces each element from provided JavaScript\ngenerator, which is a function*\n(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions),\nor a function that returns an\niterator\n(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions).\n\nThe returned iterator should have `.next()` function that returns element in\nformat of `{value: TensorContainer, done:boolean}`.\n\nExample of creating a dataset from an iterator factory:\n```js\nfunction makeIterator() {\n   const numElements = 10;\n   let index = 0;\n\n   const iterator = {\n     next: () => {\n       let result;\n       if (index < numElements) {\n         result = {value: index, done: false};\n         index++;\n         return result;\n       }\n       return {value: index, done: true};\n     }\n   };\n   return iterator;\n}\nconst ds = tf.data.generator(makeIterator);\nawait ds.forEachAsync(e => console.log(e));\n```\n\nExample of creating a dataset from a generator:\n```js\nfunction* dataGenerator() {\n   const numElements = 10;\n   let index = 0;\n   while (index < numElements) {\n     const x = index;\n     index++;\n     yield x;\n   }\n}\n\nconst ds = tf.data.generator(dataGenerator);\nawait ds.forEachAsync(e => console.log(e));\n```",
              "fileName": "#201",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/readers.ts#L201-L207",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.generator",
              "urlHash": "data.generator"
            },
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Creation",
                "namespace": "data",
                "ignoreCI": true
              },
              "symbolName": "microphone",
              "namespace": "data",
              "paramStr": "(microphoneConfig?)",
              "parameters": [
                {
                  "name": "microphoneConfig",
                  "documentation": "A `MicrophoneConfig` object that contains\nconfigurations of reading audio data from microphone.",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "sampleRateHz",
                  "type": "44100|48000",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "fftSize",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "columnTruncateLength",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "numFramesPerSpectrogram",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "audioTrackConstraints",
                  "type": "MediaTrackConstraints",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "smoothingTimeConstant",
                  "type": "number",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "includeSpectrogram",
                  "type": "boolean",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "includeWaveform",
                  "type": "boolean",
                  "documentation": "",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Promise<MicrophoneIterator>",
              "documentation": "Create an iterator that generates frequency-domain spectrogram `Tensor`s from\nmicrophone audio stream with browser's native FFT. This API only works in\nbrowser environment when the device has microphone.\n\nNote: this code snippet only works when the device has a microphone. It will\nrequest permission to open the microphone when running.\n```js\nconst mic = await tf.data.microphone({\n   fftSize: 1024,\n   columnTruncateLength: 232,\n   numFramesPerSpectrogram: 43,\n   sampleRateHz:44100,\n   includeSpectrogram: true,\n   includeWaveform: true\n});\nconst audioData = await mic.capture();\nconst spectrogramTensor = audioData.spectrogram;\nspectrogramTensor.print();\nconst waveformTensor = audioData.waveform;\nwaveformTensor.print();\nmic.stop();\n```",
              "fileName": "#279",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/readers.ts#L279-L282",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.microphone",
              "urlHash": "data.microphone"
            },
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Creation",
                "namespace": "data",
                "ignoreCI": true
              },
              "symbolName": "webcam",
              "namespace": "data",
              "paramStr": "(webcamVideoElement?, webcamConfig?)",
              "parameters": [
                {
                  "name": "webcamVideoElement",
                  "documentation": "A [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) used to play video from\nwebcam. If this element is not provided, a hidden [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) will\nbe created. In that case, `resizeWidth` and `resizeHeight` must be\nprovided to set the generated tensor shape.",
                  "type": "[HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "webcamConfig",
                  "documentation": "A `WebcamConfig` object that contains configurations of\nreading and manipulating data from webcam video stream.",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "facingMode",
                  "type": "'user'|'environment'",
                  "documentation": "A string specifying which camera to use on device. If the value is\n'user', it will use front camera. If the value is 'environment', it will\nuse rear camera.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "deviceId",
                  "type": "string",
                  "documentation": "A string used to request a specific camera. The deviceId can be obtained by\ncalling `mediaDevices.enumerateDevices()`.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "resizeWidth",
                  "type": "number",
                  "documentation": "Specifies the width of the output tensor. The actual width of the\nHTMLVideoElement (if provided) can be different and the final image will be\nresized to match resizeWidth.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "resizeHeight",
                  "type": "number",
                  "documentation": "Specifies the height of the output tensor. The actual height of the\nHTMLVideoElement (if provided) can be different and the final image will be\nresized to match resizeHeight.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "centerCrop",
                  "type": "boolean",
                  "documentation": "A boolean value that indicates whether to crop the video frame from center.\nIf true, `resizeWidth` and `resizeHeight` must be specified; then an image\nof size `[resizeWidth, resizeHeight]` is taken from the center of the frame\nwithout scaling. If false, the entire image is returned (perhaps scaled to\nfit in `[resizeWidth, resizeHeight]`, if those are provided).",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "Promise<WebcamIterator>",
              "documentation": "Create an iterator that generates `Tensor`s from webcam video stream. This\nAPI only works in Browser environment when the device has webcam.\n\nNote: this code snippet only works when the device has a webcam. It will\nrequest permission to open the webcam when running.\n```js\nconst videoElement = document.createElement('video');\nvideoElement.width = 100;\nvideoElement.height = 100;\nconst cam = await tf.data.webcam(videoElement);\nconst img = await cam.capture();\nimg.print();\ncam.stop();\n```",
              "fileName": "#239",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/readers.ts#L239-L243",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.webcam",
              "urlHash": "data.webcam"
            }
          ]
        },
        {
          "name": "Operations",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Operations",
                "namespace": "data"
              },
              "symbolName": "zip",
              "namespace": "data",
              "paramStr": "(datasets)",
              "parameters": [
                {
                  "name": "datasets",
                  "documentation": "",
                  "type": "DatasetContainer",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.data.Dataset](#class:data.Dataset)",
              "documentation": "Create a `Dataset` by zipping together an array, dict, or nested\nstructure of `Dataset`s (and perhaps additional constants).\nThe underlying datasets must provide elements in a consistent order such that\nthey correspond.\n\nThe number of elements in the resulting dataset is the same as the size of\nthe smallest dataset in datasets.\n\nThe nested structure of the `datasets` argument determines the\nstructure of elements in the resulting iterator.\n\nNote this means that, given an array of two datasets that produce dict\nelements, the result is a dataset that produces elements that are arrays\nof two dicts:\n\nZip an array of datasets:\n```js\nconsole.log('Zip two datasets of objects:');\nconst ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\nconst ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\nconst ds3 = tf.data.zip([ds1, ds2]);\nawait ds3.forEachAsync(e => console.log(JSON.stringify(e)));\n\n// If the goal is to merge the dicts in order to produce elements like\n// {a: ..., b: ...}, this requires a second step such as:\nconsole.log('Merge the objects:');\nconst ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});\nawait ds4.forEachAsync(e => console.log(e));\n```\n\nZip a dict of datasets:\n```js\nconst a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\nconst b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\nconst c = tf.data.zip({c: a, d: b});\nawait c.forEachAsync(e => console.log(JSON.stringify(e)));\n```",
              "fileName": "#627",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L627-L659",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.data.zip",
              "urlHash": "data.zip"
            }
          ]
        },
        {
          "name": "Classes",
          "description": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Classes",
                "namespace": "data"
              },
              "symbolName": "CSVDataset",
              "namespace": "data",
              "documentation": "Represents a potentially large collection of delimited text records.\n\nThe produced `TensorContainer`s each contain one key-value pair for\nevery column of the table.  When a field is empty in the incoming data, the\nresulting value is `undefined`, or throw error if it is required.  Values\nthat can be parsed as numbers are emitted as type `number`, other values\nare parsed as `string`.\n\nThe results are not batched.",
              "fileName": "#46",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/datasets/csv_dataset.ts#L46-L392",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "columnNames",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise<string[]>",
                  "documentation": "Returns column names of the csv dataset. If `configuredColumnsOnly` is\ntrue, return column names in `columnConfigs`. If `configuredColumnsOnly` is\nfalse and `columnNames` is provided, `columnNames`. If\n`configuredColumnsOnly` is false and `columnNames` is not provided, return\nall column names parsed from the csv file. For example usage please go to\n[tf.data.csv()](#data.csv).",
                  "fileName": "#66",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/datasets/csv_dataset.ts#L66-L72",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.CSVDataset.columnNames"
                }
              ],
              "tags": [],
              "isClass": true,
              "inheritsFrom": "[tf.data.Dataset](#class:data.Dataset)",
              "displayName": "tf.data.CSVDataset",
              "urlHash": "class:data.CSVDataset"
            },
            {
              "docInfo": {
                "heading": "Data",
                "subheading": "Classes",
                "namespace": "data"
              },
              "symbolName": "Dataset",
              "namespace": "data",
              "documentation": "Represents a potentially large list of independent data elements (typically\n'samples' or 'examples').\n\nA 'data example' may be a primitive, an array, a map from string keys to\nvalues, or any nested structure of these.\n\nA `Dataset` represents an ordered collection of elements, together with a\nchain of transformations to be performed on those elements. Each\ntransformation is a method of `Dataset` that returns another `Dataset`, so\nthese may be chained, e.g.\n`const processedDataset = rawDataset.filter(...).map(...).batch(...)`.\n\nData loading and transformation is done in a lazy, streaming fashion.  The\ndataset may be iterated over multiple times; each iteration starts the data\nloading anew and recapitulates the transformations.\n\nA `Dataset` is typically processed as a stream of unbatched examples -- i.e.,\nits transformations are applied one example at a time. Batching produces a\nnew `Dataset` where each element is a batch. Batching should usually come\nlast in a pipeline, because data transformations are easier to express on a\nper-example basis than on a per-batch basis.\n\nThe following code examples are calling `await dataset.forEachAsync(...)` to\niterate once over the entire dataset in order to print out the data.",
              "fileName": "#62",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L62-L532",
              "methods": [
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "batch",
                  "paramStr": "(batchSize, smallLastBatch?)",
                  "parameters": [
                    {
                      "name": "batchSize",
                      "documentation": "The number of elements desired per batch.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "smallLastBatch",
                      "documentation": "Whether to emit the final batch when it has fewer\nthan batchSize elements. Default true.",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Groups elements into batches.\n\nIt is assumed that each of the incoming dataset elements has the same\nstructure -- i.e. the same set of keys at each location in an object\nhierarchy.  For each key, the resulting `Dataset` provides a batched\nelement collecting all of the incoming values for that key.\n\nIncoming primitives are grouped into a 1-D Tensor.\nIncoming Tensors are grouped into a new Tensor where the 0th axis is\n    the batch dimension.\nIncoming arrays are converted to Tensor and then batched.\nA nested array is interpreted as an n-D Tensor, so the batched result\n    has n+1 dimensions.\nAn array that cannot be converted to Tensor produces an error.\n\nIf an array should not be batched as a unit, it should first be converted\nto an object with integer keys.\n\nHere are a few examples:\n\nBatch a dataset of numbers:\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);\nawait a.forEachAsync(e => e.print());\n```\n\nBatch a dataset of arrays:\n```js\nconst b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);\nawait b.forEachAsync(e => e.print());\n```\n\nBatch a dataset of objects:\n```js\nconst c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},\n   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},\n   {a: 8, b: 18}]).batch(4);\nawait c.forEachAsync(e => {\n   console.log('{');\n   for(var key in e) {\n     console.log(key+':');\n     e[key].print();\n   }\n   console.log('}');\n})\n```",
                  "fileName": "#136",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L136-L159",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.batch"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "concatenate",
                  "paramStr": "(dataset)",
                  "parameters": [
                    {
                      "name": "dataset",
                      "documentation": "A `Dataset` to be concatenated onto this one.",
                      "type": "[tf.data.Dataset](#class:data.Dataset)",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Concatenates this `Dataset` with another.\n\n```js\nconst a = tf.data.array([1, 2, 3]);\nconst b = tf.data.array([4, 5, 6]);\nconst c = a.concatenate(b);\nawait c.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#176",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L176-L196",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.concatenate"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "filter",
                  "paramStr": "(predicate)",
                  "parameters": [
                    {
                      "name": "predicate",
                      "documentation": "A function mapping a dataset element to a boolean or a\n`Promise` for one.",
                      "type": "(value: T) => boolean",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Filters this dataset according to `predicate`.\n\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n   .filter(x => x%2 === 0);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#214",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L214-L228",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.filter"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "forEachAsync",
                  "paramStr": "(f)",
                  "parameters": [
                    {
                      "name": "f",
                      "documentation": "A function to apply to each dataset element.",
                      "type": "(input: T) => void",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "Promise<void>",
                  "documentation": "Apply a function to every element of the dataset.\n\nAfter the function is applied to a dataset element, any Tensors contained\nwithin that element are disposed.\n\n```js\nconst a = tf.data.array([1, 2, 3]);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#246",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L246-L248",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.forEachAsync"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "map",
                  "paramStr": "(transform)",
                  "parameters": [
                    {
                      "name": "transform",
                      "documentation": "A function mapping a dataset element to a transformed\ndataset element.",
                      "type": "(value: T) => tf.void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Maps this dataset through a 1-to-1 transform.\n\n```js\nconst a = tf.data.array([1, 2, 3]).map(x => x*x);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#265",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L265-L270",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.map"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "mapAsync",
                  "paramStr": "(transform)",
                  "parameters": [
                    {
                      "name": "transform",
                      "documentation": "A function mapping a dataset element to a `Promise` for a\ntransformed dataset element.  This transform is responsible for disposing\nany intermediate `Tensor`s, i.e. by wrapping its computation in\n`tf.tidy()`; that cannot be automated here (as it is in the synchronous\n`map()` case).",
                      "type": "(value: T) => Promise<tf.void|number|string|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|[tf.Tensor](#class:Tensor)|[tf.Tensor](#class:Tensor)[]|{[key:\nstring]:[tf.Tensor](#class:Tensor)|number|string}>",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Maps this dataset through an async 1-to-1 transform.\n\n```js\nconst a =\n  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){\n    setTimeout(() => {\n      resolve(x * x);\n    }, Math.random()*1000 + 500);\n  }));\nconsole.log(await a.toArray());\n```",
                  "fileName": "#295",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L295-L301",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.mapAsync"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "prefetch",
                  "paramStr": "(bufferSize)",
                  "parameters": [
                    {
                      "name": "bufferSize",
                      "documentation": ": An integer specifying the number of elements to be\nprefetched.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Creates a `Dataset` that prefetches elements from this dataset.",
                  "fileName": "#312",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L312-L321",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.prefetch"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "repeat",
                  "paramStr": "(count?)",
                  "parameters": [
                    {
                      "name": "count",
                      "documentation": ": (Optional) An integer, representing the number of times\nthe dataset should be repeated. The default behavior (if `count` is\n`undefined` or negative) is for the dataset be repeated indefinitely.",
                      "type": "number",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Repeats this dataset `count` times.\n\nNOTE: If this dataset is a function of global state (e.g. a random number\ngenerator), then different repetitions may produce different elements.\n\n```js\nconst a = tf.data.array([1, 2, 3]).repeat(3);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#341",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L341-L365",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.repeat"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "skip",
                  "paramStr": "(count)",
                  "parameters": [
                    {
                      "name": "count",
                      "documentation": ": The number of elements of this dataset that should be skipped\nto form the new dataset.  If `count` is greater than the size of this\ndataset, the new dataset will contain no elements.  If `count`\nis `undefined` or negative, skips the entire dataset.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Creates a `Dataset` that skips `count` initial elements from this dataset.\n\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#384",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L384-L404",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.skip"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "shuffle",
                  "paramStr": "(bufferSize, seed?, reshuffleEachIteration?)",
                  "parameters": [
                    {
                      "name": "bufferSize",
                      "documentation": ": An integer specifying the number of elements from this\ndataset from which the new dataset will sample.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    },
                    {
                      "name": "seed",
                      "documentation": ": (Optional) An integer specifying the random seed that will\nbe used to create the distribution.",
                      "type": "string",
                      "optional": true,
                      "isConfigParam": false
                    },
                    {
                      "name": "reshuffleEachIteration",
                      "documentation": ": (Optional) A boolean, which if true\nindicates that the dataset should be pseudorandomly reshuffled each time\nit is iterated over. If false, elements will be returned in the same\nshuffled order on each iteration. (Defaults to `true`.)",
                      "type": "boolean",
                      "optional": true,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Pseudorandomly shuffles the elements of this dataset. This is done in a\nstreaming manner, by sampling from a given number of prefetched elements.\n\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#431",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L431-L454",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.shuffle"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "take",
                  "paramStr": "(count)",
                  "parameters": [
                    {
                      "name": "count",
                      "documentation": ": The number of elements of this dataset that should be taken\nto form the new dataset.  If `count` is `undefined` or negative, or if\n`count` is greater than the size of this dataset, the new dataset will\ncontain all elements of this dataset.",
                      "type": "number",
                      "optional": false,
                      "isConfigParam": false
                    }
                  ],
                  "returnType": "[tf.data.Dataset](#class:data.Dataset)",
                  "documentation": "Creates a `Dataset` with at most `count` initial elements from this\ndataset.\n\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);\nawait a.forEachAsync(e => console.log(e));\n```",
                  "fileName": "#473",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L473-L490",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.take"
                },
                {
                  "docInfo": {
                    "heading": "Data",
                    "subheading": "Classes"
                  },
                  "symbolName": "toArray",
                  "paramStr": "()",
                  "parameters": [],
                  "returnType": "Promise<T[]>",
                  "documentation": "Collect all elements of this dataset into an array.\n\nObviously this will succeed only for small datasets that fit in memory.\nUseful for testing and generally should be avoided if possible.\n\n```js\nconst a = tf.data.array([1, 2, 3, 4, 5, 6]);\nconsole.log(await a.toArray());\n```",
                  "fileName": "#508",
                  "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-data/src/dataset.ts#L508-L513",
                  "tags": [],
                  "isFunction": true,
                  "urlHash": "tf.data.Dataset.toArray"
                }
              ],
              "tags": [],
              "isClass": true,
              "displayName": "tf.data.Dataset",
              "urlHash": "class:data.Dataset"
            }
          ]
        }
      ]
    },
    {
      "name": "Visualization",
      "description": "<p>tfjs-vis is a companion library for TensorFlow.js that provides \nin-browser visualization capabilities for training and understanding \nmodels. <a href='/api_vis/latest/'>API docs for tfjs-vis are available here</a>",
      "subheadings": []
    },
    {
      "name": "Util",
      "description": "",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "assert",
              "namespace": "util",
              "paramStr": "(expr, msg)",
              "parameters": [
                {
                  "name": "expr",
                  "documentation": "The expression to assert (as a boolean).",
                  "type": "boolean",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "msg",
                  "documentation": "A function that returns the message to report when throwing an\nerror. We use a function for performance reasons.",
                  "type": "() => string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Asserts that the expression is true. Otherwise throws an error with the\nprovided message.\n\n```js\nconst x = 2;\ntf.util.assert(x === 2, 'x is not 2');\n```",
              "fileName": "#151",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util_base.ts#L151-L155",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.assert",
              "urlHash": "util.assert"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "createShuffledIndices",
              "namespace": "util",
              "paramStr": "(n)",
              "parameters": [
                {
                  "name": "n",
                  "documentation": "",
                  "type": "number",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Uint32Array",
              "documentation": "Creates a new array with randomized indices to a given quantity.\n\n```js\nconst randomTen = tf.util.createShuffledIndices(10);\nconsole.log(randomTen);\n```",
              "fileName": "#274",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util_base.ts#L274-L281",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.createShuffledIndices",
              "urlHash": "util.createShuffledIndices"
            },
            {
              "docInfo": {
                "heading": "Util"
              },
              "symbolName": "decodeString",
              "paramStr": "(bytes, encoding?)",
              "parameters": [
                {
                  "name": "bytes",
                  "documentation": "The bytes to decode.",
                  "type": "Uint8Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "encoding",
                  "documentation": "The encoding scheme. Defaults to utf-8.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "string",
              "documentation": "Decodes the provided bytes into a string using the provided encoding scheme.",
              "fileName": "#131",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util.ts#L131-L134",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.decodeString",
              "urlHash": "decodeString"
            },
            {
              "docInfo": {
                "heading": "Util"
              },
              "symbolName": "encodeString",
              "paramStr": "(s, encoding?)",
              "parameters": [
                {
                  "name": "s",
                  "documentation": "The string to encode.",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "encoding",
                  "documentation": "The encoding scheme. Defaults to utf-8.",
                  "type": "string",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Uint8Array",
              "documentation": "Encodes the provided string into bytes using the provided encoding scheme.",
              "fileName": "#118",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util.ts#L118-L121",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.encodeString",
              "urlHash": "encodeString"
            },
            {
              "docInfo": {
                "heading": "Util"
              },
              "symbolName": "fetch",
              "paramStr": "(path, requestInits?)",
              "parameters": [
                {
                  "name": "path",
                  "documentation": "",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "requestInits",
                  "documentation": "",
                  "type": "RequestInit",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<Response>",
              "documentation": "Returns a platform-specific implementation of\n[`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n\nIf `fetch` is defined on the global object (`window`, `process`, etc.),\n`tf.util.fetch` returns that function.\n\nIf not, `tf.util.fetch` returns a platform-specific solution.\n\n```js\nconst resource = await tf.util.fetch('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');\n// handle response\n```",
              "fileName": "#105",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util.ts#L105-L108",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.fetch",
              "urlHash": "fetch"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "flatten",
              "namespace": "util",
              "paramStr": "(arr, result?, skipTypedArray?)",
              "parameters": [
                {
                  "name": "arr",
                  "documentation": "The nested array to flatten.",
                  "type": "number|boolean|string|Promise<number>|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|RecursiveArray|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)>",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "result",
                  "documentation": "The destination array which holds the elements.",
                  "type": "number|boolean|string|Promise<number>|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)[]",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "skipTypedArray",
                  "documentation": "If true, avoids flattening the typed arrays. Defaults\nto false.",
                  "type": "boolean",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "number|boolean|string|Promise<number>|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)[]",
              "documentation": "Flattens an arbitrarily nested array.\n\n```js\nconst a = [[1, 2], [3, 4], [5, [6, [7]]]];\nconst flat = tf.util.flatten(a);\nconsole.log(flat);\n```",
              "fileName": "#165",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util.ts#L165-L193",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.flatten",
              "urlHash": "util.flatten"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "now",
              "namespace": "util",
              "paramStr": "()",
              "parameters": [],
              "returnType": "number",
              "documentation": "Returns the current high-resolution time in milliseconds relative to an\narbitrary time in the past. It works across different platforms (node.js,\nbrowsers).\n\n```js\nconsole.log(tf.util.now());\n```",
              "fileName": "#85",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util.ts#L85-L87",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.now",
              "urlHash": "util.now"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "shuffle",
              "namespace": "util",
              "paramStr": "(array)",
              "parameters": [
                {
                  "name": "array",
                  "documentation": "The array to shuffle in-place.",
                  "type": "[tf.any()](#any)[]|Uint32Array|Int32Array|\n                        Float32Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Shuffles the array in-place using Fisher-Yates algorithm.\n\n```js\nconst a = [1, 2, 3, 4, 5];\ntf.util.shuffle(a);\nconsole.log(a);\n```",
              "fileName": "#34",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util_base.ts#L34-L47",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.shuffle",
              "urlHash": "util.shuffle"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "shuffleCombo",
              "namespace": "util",
              "paramStr": "(array, array2)",
              "parameters": [
                {
                  "name": "array",
                  "documentation": "The first array to shuffle in-place.",
                  "type": "[tf.any()](#any)[]|Uint32Array|Int32Array|Float32Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "array2",
                  "documentation": "The second array to shuffle in-place with the same permutation\nas the first array.",
                  "type": "[tf.any()](#any)[]|Uint32Array|Int32Array|Float32Array",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Shuffles two arrays in-place the same way using Fisher-Yates algorithm.\n\n```js\nconst a = [1,2,3,4,5];\nconst b = [11,22,33,44,55];\ntf.util.shuffleCombo(a, b);\nconsole.log(a, b);\n```",
              "fileName": "#65",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util_base.ts#L65-L88",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.shuffleCombo",
              "urlHash": "util.shuffleCombo"
            },
            {
              "docInfo": {
                "heading": "Util",
                "namespace": "util"
              },
              "symbolName": "sizeFromShape",
              "namespace": "util",
              "paramStr": "(shape)",
              "parameters": [
                {
                  "name": "shape",
                  "documentation": "",
                  "type": "number[]",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "number",
              "documentation": "Returns the size (number of elements) of the tensor given its shape.\n\n```js\nconst shape = [3, 4, 2];\nconst size = tf.util.sizeFromShape(shape);\nconsole.log(size);\n```",
              "fileName": "#181",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/util_base.ts#L181-L191",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.util.sizeFromShape",
              "urlHash": "util.sizeFromShape"
            }
          ]
        }
      ]
    },
    {
      "name": "Backends",
      "description": "",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "backend",
              "paramStr": "()",
              "parameters": [],
              "returnType": "KernelBackend",
              "documentation": "Gets the current backend. If no backends have been initialized, this will\nattempt to initialize the best backend. Will throw an error if the highest\npriority backend has async initialization, in which case you should call\n'await tf.ready()' before running other code.",
              "fileName": "#372",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L372-L374",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.backend",
              "urlHash": "backend"
            },
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "getBackend",
              "paramStr": "()",
              "parameters": [],
              "returnType": "string",
              "documentation": "Returns the current backend name (cpu, webgl, etc). The backend is\nresponsible for creating tensors and executing operations on those tensors.",
              "fileName": "#312",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L312-L314",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.getBackend",
              "urlHash": "getBackend"
            },
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "ready",
              "paramStr": "()",
              "parameters": [],
              "returnType": "Promise<void>",
              "documentation": "Returns a promise that resolves when the currently selected backend (or the\nhighest priority one) has initialized. Await this promise when you are using\na backend that has async initialization.",
              "fileName": "#302",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L302-L304",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.ready",
              "urlHash": "ready"
            },
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "registerBackend",
              "paramStr": "(name, factory, priority?)",
              "parameters": [
                {
                  "name": "name",
                  "documentation": "",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "factory",
                  "documentation": "The backend factory function. When called, it should\nreturn a backend instance, or a promise of an instance.",
                  "type": "() => KernelBackend | Promise<KernelBackend>",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "priority",
                  "documentation": "The priority of the backend (higher = more important).\nIn case multiple backends are registered, the priority is used to find\nthe best backend. Defaults to 1.",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "boolean",
              "documentation": "Registers a global backend. The registration should happen when importing\na module file (e.g. when importing `backend_webgl.ts`), and is used for\nmodular builds (e.g. custom tfjs bundle with only webgl support).",
              "fileName": "#358",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L358-L362",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.registerBackend",
              "urlHash": "registerBackend"
            },
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "removeBackend",
              "paramStr": "(name)",
              "parameters": [
                {
                  "name": "name",
                  "documentation": "",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "void",
              "documentation": "Removes a backend and the registered factory.",
              "fileName": "#321",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L321-L323",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.removeBackend",
              "urlHash": "removeBackend"
            },
            {
              "docInfo": {
                "heading": "Backends"
              },
              "symbolName": "setBackend",
              "paramStr": "(backendName)",
              "parameters": [
                {
                  "name": "backendName",
                  "documentation": "The name of the backend. Currently supports\n`'webgl'|'cpu'` in the browser, `'tensorflow'` under node.js\n(requires tfjs-node), and `'wasm'` (requires tfjs-backend-wasm).",
                  "type": "string",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<boolean>",
              "documentation": "Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and\nexecuting operations on those tensors. Returns a promise that resolves\nto a boolean if the backend initialization was successful.\n\nNote this disposes the current backend, if any, as well as any tensors\nassociated with it. A new backend is initialized, even if it is of the\nsame type as the previous one.",
              "fileName": "#291",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/globals.ts#L291-L293",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.setBackend",
              "urlHash": "setBackend"
            }
          ]
        }
      ]
    },
    {
      "name": "Browser",
      "description": "",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Browser",
                "namespace": "browser"
              },
              "symbolName": "draw",
              "namespace": "browser",
              "paramStr": "(image, canvas, options?)",
              "parameters": [
                {
                  "name": "image",
                  "documentation": "The tensor to draw on the canvas. Must match one of\nthese shapes:\n- Rank-2 with shape `[height, width`]: Drawn as grayscale.\n- Rank-3 with shape `[height, width, 1]`: Drawn as grayscale.\n- Rank-3 with shape `[height, width, 3]`: Drawn as RGB with alpha set in\n`imageOptions` (defaults to 1, which is opaque).\n- Rank-3 with shape `[height, width, 4]`: Drawn as RGBA.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "canvas",
                  "documentation": "The canvas to draw to.",
                  "type": "[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "options",
                  "documentation": "The configuration arguments for image to be drawn and the\ncanvas to draw to.",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "imageOptions",
                  "type": "ImageOptions",
                  "documentation": "Optional. An object of options to customize the values of image tensor.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "contextOptions",
                  "type": "ContextOptions",
                  "documentation": "Optional. An object to configure the context of the canvas to draw to.",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "void",
              "documentation": "Draws a [tf.Tensor](#class:Tensor) to a canvas.\n\nWhen the dtype of the input is 'float32', we assume values in the range\n[0-1]. Otherwise, when input is 'int32', we assume values in the range\n[0-255].",
              "fileName": "#413",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/browser.ts#L413-L431",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.browser.draw",
              "urlHash": "browser.draw"
            },
            {
              "docInfo": {
                "heading": "Browser",
                "namespace": "browser",
                "ignoreCI": true
              },
              "symbolName": "fromPixels",
              "namespace": "browser",
              "paramStr": "(pixels, numChannels?)",
              "parameters": [
                {
                  "name": "pixels",
                  "documentation": "The input image to construct the tensor from. The\nsupported image types are all 4-channel. You can also pass in an image\nobject with following attributes:\n`{data: Uint8Array; width: number; height: number}`",
                  "type": "PixelData|[ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)|[HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)|[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement)|\n    [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)|ImageBitmap",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numChannels",
                  "documentation": "The number of channels of the output tensor. A\nnumChannels value less than 4 allows you to ignore channels. Defaults to\n3 (ignores alpha channel of input image).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor3D](#class:Tensor)",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) from an image.\n\n```js\nconst image = new ImageData(1, 1);\nimage.data[0] = 100;\nimage.data[1] = 150;\nimage.data[2] = 200;\nimage.data[3] = 255;\n\ntf.browser.fromPixels(image).print();\n```",
              "fileName": "#66",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/browser.ts#L66-L173",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.browser.fromPixels",
              "urlHash": "browser.fromPixels"
            },
            {
              "docInfo": {
                "heading": "Browser",
                "namespace": "browser",
                "ignoreCI": true
              },
              "symbolName": "fromPixelsAsync",
              "namespace": "browser",
              "paramStr": "(pixels, numChannels?)",
              "parameters": [
                {
                  "name": "pixels",
                  "documentation": "The input image to construct the tensor from. The\nsupported image types are all 4-channel. You can also pass in an image\nobject with following attributes:\n`{data: Uint8Array; width: number; height: number}`",
                  "type": "PixelData|[ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)|[HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)|[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement)|\n    [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)|ImageBitmap",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "numChannels",
                  "documentation": "The number of channels of the output tensor. A\nnumChannels value less than 4 allows you to ignore channels. Defaults to\n3 (ignores alpha channel of input image).",
                  "type": "number",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<[tf.Tensor](#class:Tensor)>",
              "documentation": "Creates a [tf.Tensor](#class:Tensor) from an image in async way.\n\n```js\nconst image = new ImageData(1, 1);\nimage.data[0] = 100;\nimage.data[1] = 150;\nimage.data[2] = 200;\nimage.data[3] = 255;\n\n(await tf.browser.fromPixelsAsync(image)).print();\n```\nThis API is the async version of fromPixels. The API will first\ncheck |WRAP_TO_IMAGEBITMAP| flag, and try to wrap the input to\nimageBitmap if the flag is set to true.",
              "fileName": "#227",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/browser.ts#L227-L270",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.browser.fromPixelsAsync",
              "urlHash": "browser.fromPixelsAsync"
            },
            {
              "docInfo": {
                "heading": "Browser",
                "namespace": "browser"
              },
              "symbolName": "toPixels",
              "namespace": "browser",
              "paramStr": "(img, canvas?)",
              "parameters": [
                {
                  "name": "img",
                  "documentation": "A rank-2 tensor with shape `[height, width]`, or a rank-3 tensor\nof shape `[height, width, numChannels]`. If rank-2, draws grayscale. If\nrank-3, must have depth of 1, 3 or 4. When depth of 1, draws\ngrayscale. When depth of 3, we draw with the first three components of\nthe depth dimension corresponding to r, g, b and alpha = 1. When depth of\n4, all four components of the depth dimension correspond to r, g, b, a.",
                  "type": "[tf.Tensor2D](#class:Tensor)|[tf.Tensor3D](#class:Tensor)|[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)|Array",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "canvas",
                  "documentation": "The canvas to draw to.",
                  "type": "[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement)",
                  "optional": true,
                  "isConfigParam": false
                }
              ],
              "returnType": "Promise<Uint8ClampedArray>",
              "documentation": "Draws a [tf.Tensor](#class:Tensor) of pixel values to a byte array or optionally a\ncanvas.\n\nWhen the dtype of the input is 'float32', we assume values in the range\n[0-1]. Otherwise, when input is 'int32', we assume values in the range\n[0-255].\n\nReturns a promise that resolves when the canvas has been drawn to.",
              "fileName": "#319",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-core/src/ops/browser.ts#L319-L391",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.browser.toPixels",
              "urlHash": "browser.toPixels"
            }
          ]
        }
      ]
    },
    {
      "name": "Metrics",
      "description": "",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "binaryAccuracy",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Binary Tensor of truth.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Binary Tensor of prediction.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Binary accuracy metric function.\n\n`yTrue` and `yPred` can have 0-1 values. Example:\n```js\nconst x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\nconst y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\nconst accuracy = tf.metrics.binaryAccuracy(x, y);\naccuracy.print();\n```\n\n`yTrue` and `yPred` can also have floating-number values between 0 and 1, in\nwhich case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\na value >= 0.5 and <= 1.0 is interpreted as 1).\n\nExample:\n```js\nconst x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\nconst y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\nconst accuracy = tf.metrics.binaryAccuracy(x, y);\naccuracy.print();\n```",
              "fileName": "#44",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L44-L46",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.binaryAccuracy",
              "urlHash": "metrics.binaryAccuracy"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "binaryCrossentropy",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Binary Tensor of truth.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Binary Tensor of prediction, probabilities for the `1` case.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Binary crossentropy metric function.\n\nExample:\n```js\nconst x = tf.tensor2d([[0], [1], [1], [1]]);\nconst y = tf.tensor2d([[0], [0], [0.5], [1]]);\nconst crossentropy = tf.metrics.binaryCrossentropy(x, y);\ncrossentropy.print();\n```",
              "fileName": "#65",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L65-L67",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.binaryCrossentropy",
              "urlHash": "metrics.binaryCrossentropy"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "categoricalAccuracy",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Binary Tensor of truth: one-hot encoding of categories.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Binary Tensor of prediction: probabilities or logits for the\nsame categories as in `yTrue`.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Categorical accuracy metric function.\n\nExample:\n```js\nconst x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\nconst y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\nconst accuracy = tf.metrics.categoricalAccuracy(x, y);\naccuracy.print();\n```",
              "fileName": "#111",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L111-L113",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.categoricalAccuracy",
              "urlHash": "metrics.categoricalAccuracy"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "categoricalCrossentropy",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Categorical crossentropy between an output tensor and a target tensor.",
              "fileName": "#126",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L126-L128",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.categoricalCrossentropy",
              "urlHash": "metrics.categoricalCrossentropy"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "cosineProximity",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Truth Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Prediction Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Loss or metric function: Cosine proximity.\n\nMathematically, cosine proximity is defined as:\n   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\nwherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\nrepresents element-wise multiplication.\n\n```js\nconst yTrue = tf.tensor2d([[1, 0], [1, 0]]);\nconst yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\nconst proximity = tf.metrics.cosineProximity(yTrue, yPred);\nproximity.print();\n```",
              "fileName": "#229",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L229-L231",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.cosineProximity",
              "urlHash": "metrics.cosineProximity"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "meanAbsoluteError",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Truth Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Prediction Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Loss or metric function: Mean absolute error.\n\nMathematically, mean absolute error is defined as:\n   `mean(abs(yPred - yTrue))`,\nwherein the `mean` is applied over feature dimensions.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\nconst yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\nconst mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\nmse.print();\n```",
              "fileName": "#253",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L253-L255",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.meanAbsoluteError",
              "urlHash": "metrics.meanAbsoluteError"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "meanAbsolutePercentageError",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Truth Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Prediction Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Loss or metric function: Mean absolute percentage error.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [10, 20]]);\nconst yPred = tf.tensor2d([[0, 1], [11, 24]]);\nconst mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\nmse.print();\n```\n\nAliases: `tf.metrics.MAPE`, `tf.metrics.mape`.",
              "fileName": "#275",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L275-L278",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.meanAbsolutePercentageError",
              "urlHash": "metrics.meanAbsolutePercentageError"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "meanSquaredError",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "Truth Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Prediction Tensor.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Loss or metric function: Mean squared error.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [3, 4]]);\nconst yPred = tf.tensor2d([[0, 1], [-3, -4]]);\nconst mse = tf.metrics.meanSquaredError(yTrue, yPred);\nmse.print();\n```\n\nAliases: `tf.metrics.MSE`, `tf.metrics.mse`.",
              "fileName": "#306",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L306-L308",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.meanSquaredError",
              "urlHash": "metrics.meanSquaredError"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "precision",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "The ground truth values. Expected to contain only 0-1 values.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "The predicted values. Expected to contain only 0-1 values.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the precision of the predictions with respect to the labels.\n\nExample:\n```js\nconst x = tf.tensor2d(\n    [\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 0, 1, 0]\n    ]\n);\n\nconst y = tf.tensor2d(\n    [\n      [0, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0]\n    ]\n);\n\nconst precision = tf.metrics.precision(x, y);\nprecision.print();\n```",
              "fileName": "#165",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L165-L167",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.precision",
              "urlHash": "metrics.precision"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "recall",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "The ground truth values. Expected to contain only 0-1 values.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "The predicted values. Expected to contain only 0-1 values.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Computes the recall of the predictions with respect to the labels.\n\nExample:\n```js\nconst x = tf.tensor2d(\n    [\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 0, 1, 0]\n    ]\n);\n\nconst y = tf.tensor2d(\n    [\n      [0, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0]\n    ]\n);\n\nconst recall = tf.metrics.recall(x, y);\nrecall.print();\n```",
              "fileName": "#204",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L204-L206",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.recall",
              "urlHash": "metrics.recall"
            },
            {
              "docInfo": {
                "heading": "Metrics",
                "namespace": "metrics"
              },
              "symbolName": "sparseCategoricalAccuracy",
              "namespace": "metrics",
              "paramStr": "(yTrue, yPred)",
              "parameters": [
                {
                  "name": "yTrue",
                  "documentation": "True labels: indices.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                },
                {
                  "name": "yPred",
                  "documentation": "Predicted probabilities or logits.",
                  "type": "[tf.Tensor](#class:Tensor)",
                  "optional": false,
                  "isConfigParam": false
                }
              ],
              "returnType": "[tf.Tensor](#class:Tensor)",
              "documentation": "Sparse categorical accuracy metric function.\n\nExample:\n```js\n\nconst yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\nconst yPred = tf.tensor2d(\n      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\nconst crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\ncrossentropy.print();\n```",
              "fileName": "#88",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L88-L91",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.metrics.sparseCategoricalAccuracy",
              "urlHash": "metrics.sparseCategoricalAccuracy"
            }
          ]
        }
      ]
    },
    {
      "name": "Callbacks",
      "description": "",
      "subheadings": [
        {
          "symbols": [
            {
              "docInfo": {
                "heading": "Callbacks",
                "namespace": "callbacks"
              },
              "symbolName": "earlyStopping",
              "namespace": "callbacks",
              "paramStr": "(args?)",
              "parameters": [
                {
                  "name": "args",
                  "documentation": "",
                  "type": "Object",
                  "optional": true,
                  "isConfigParam": false
                },
                {
                  "name": "monitor",
                  "type": "string",
                  "documentation": "Quantity to be monitored.\n\nDefaults to 'val_loss'.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "minDelta",
                  "type": "number",
                  "documentation": "Minimum change in the monitored quantity to qualify as improvement,\ni.e., an absolute change of less than `minDelta` will count as no\nimprovement.\n\nDefaults to 0.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "patience",
                  "type": "number",
                  "documentation": "Number of epochs with no improvement after which training will be stopped.\n\nDefaults to 0.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "verbose",
                  "type": "number",
                  "documentation": "Verbosity mode.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "mode",
                  "type": "'auto'|'min'|'max'",
                  "documentation": "Mode: one of 'min', 'max', and 'auto'.\n- In 'min' mode, training will be stopped when the quantity monitored has\n   stopped decreasing.\n- In 'max' mode, training will be stopped when the quantity monitored has\n   stopped increasing.\n- In 'auto' mode, the direction is inferred automatically from the name of\n   the monitored quantity.\n\nDefaults to 'auto'.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "baseline",
                  "type": "number",
                  "documentation": "Baseline value of the monitored quantity.\n\nIf specified, training will be stopped if the model doesn't show\nimprovement over the baseline.",
                  "optional": false,
                  "isConfigParam": true
                },
                {
                  "name": "restoreBestWeights",
                  "type": "boolean",
                  "documentation": "Whether to restore model weights from the epoch with the best value\nof the monitored quantity. If `False`, the model weights obtained at the\nlast step of training are used.\n\n**`True` is not supported yet.**",
                  "optional": false,
                  "isConfigParam": true
                }
              ],
              "returnType": "EarlyStopping",
              "documentation": "Factory function for a Callback that stops training when a monitored\nquantity has stopped improving.\n\nEarly stopping is a type of regularization, and protects model against\noverfitting.\n\nThe following example based on fake data illustrates how this callback\ncan be used during `tf.LayersModel.fit()`:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.dense({\n   units: 3,\n   activation: 'softmax',\n   kernelInitializer: 'ones',\n   inputShape: [2]\n}));\nconst xs = tf.tensor2d([1, 2, 3, 4], [2, 2]);\nconst ys = tf.tensor2d([[1, 0, 0], [0, 1, 0]], [2, 3]);\nconst xsVal = tf.tensor2d([4, 3, 2, 1], [2, 2]);\nconst ysVal = tf.tensor2d([[0, 0, 1], [0, 1, 0]], [2, 3]);\nmodel.compile(\n     {loss: 'categoricalCrossentropy', optimizer: 'sgd', metrics: ['acc']});\n\n// Without the EarlyStopping callback, the val_acc value would be:\n//   0.5, 0.5, 0.5, 0.5, ...\n// With val_acc being monitored, training should stop after the 2nd epoch.\nconst history = await model.fit(xs, ys, {\n   epochs: 10,\n   validationData: [xsVal, ysVal],\n   callbacks: tf.callbacks.earlyStopping({monitor: 'val_acc'})\n});\n\n// Expect to see a length-2 array.\nconsole.log(history.history.val_acc);\n```",
              "fileName": "#251",
              "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/callbacks.ts#L251-L253",
              "tags": [],
              "isFunction": true,
              "displayName": "tf.callbacks.earlyStopping",
              "urlHash": "callbacks.earlyStopping"
            }
          ]
        }
      ]
    }
  ]
}