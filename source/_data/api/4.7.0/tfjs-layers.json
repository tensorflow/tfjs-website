{
  "docs": {
    "headings": [
      {
        "name": "Constraints",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Constraints",
                  "subheading": "Classes",
                  "namespace": "constraints"
                },
                "symbolName": "Constraint",
                "namespace": "constraints",
                "documentation": "Base class for functions that impose constraints on weight values",
                "fileName": "#34",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/constraints.ts#L34-L40",
                "methods": [],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "serialization.Serializable"
              }
            ]
          },
          {
            "symbols": [
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints"
                },
                "symbolName": "maxNorm",
                "namespace": "constraints",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "MaxNormArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Constraint",
                "documentation": "MaxNorm weight constraint.\n\nConstrains the weights incident to each hidden unit\nto have a norm less than or equal to a desired value.\n\nReferences\n       - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting\nSrivastava, Hinton, et al.\n2014](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
                "fileName": "#26",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L26-L28",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints"
                },
                "symbolName": "unitNorm",
                "namespace": "constraints",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "UnitNormArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Constraint",
                "documentation": "Constrains the weights incident to each hidden unit to have unit norm.",
                "fileName": "#35",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L35-L37",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints"
                },
                "symbolName": "nonNeg",
                "namespace": "constraints",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Constraint",
                "documentation": "Constrains the weight to be non-negative.",
                "fileName": "#44",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L44-L46",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Constraints",
                  "namespace": "constraints"
                },
                "symbolName": "minMaxNorm",
                "namespace": "constraints",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "MinMaxNormArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Constraint",
                "documentation": "",
                "fileName": "#49",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_constraints.ts#L49-L51",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Initializers",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Initializers",
                  "subheading": "Classes",
                  "namespace": "initializers"
                },
                "symbolName": "Initializer",
                "namespace": "initializers",
                "documentation": "Initializer base class.",
                "fileName": "#35",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/initializers.ts#L35-L50",
                "methods": [],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "serialization.Serializable"
              }
            ]
          },
          {
            "symbols": [
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "zeros",
                "namespace": "initializers",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Zeros",
                "documentation": "Initializer that generates tensors initialized to 0.",
                "fileName": "#18",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L18-L20",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "ones",
                "namespace": "initializers",
                "paramStr": "()",
                "parameters": [],
                "returnType": "Initializer",
                "documentation": "Initializer that generates tensors initialized to 1.",
                "fileName": "#27",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L27-L29",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "constant",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConstantArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates values initialized to some constant.",
                "fileName": "#36",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L36-L38",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "randomUniform",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RandomUniformArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a uniform\ndistribution.\n\nValues will be distributed uniformly between the configured minval and\nmaxval.",
                "fileName": "#49",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L49-L51",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "randomNormal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RandomNormalArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a normal\ndistribution.",
                "fileName": "#59",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L59-L61",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "truncatedNormal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "TruncatedNormalArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates random values initialized to a truncated normal\ndistribution.\n\nThese values are similar to values from a `RandomNormal` except that values\nmore than two standard deviations from the mean are discarded and re-drawn.\nThis is the recommended initializer for neural network weights and filters.",
                "fileName": "#73",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L73-L75",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "identity",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "IdentityArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates the identity matrix.\nOnly use for square 2D matrices.",
                "fileName": "#83",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L83-L85",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "varianceScaling",
                "namespace": "initializers",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "VarianceScalingArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer capable of adapting its scale to the shape of weights.\nWith distribution=NORMAL, samples are drawn from a truncated normal\ndistribution centered on zero, with `stddev = sqrt(scale / n)` where n is:\n   - number of input units in the weight tensor, if mode = FAN_IN.\n   - number of output units, if mode = FAN_OUT.\n   - average of the numbers of input and output units, if mode = FAN_AVG.\nWith distribution=UNIFORM,\nsamples are drawn from a uniform distribution\nwithin [-limit, limit], with `limit = sqrt(3 * scale / n)`.",
                "fileName": "#100",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L100-L102",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "glorotUniform",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Glorot uniform initializer, also called Xavier uniform initializer.\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.",
                "fileName": "#117",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L117-L119",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "glorotNormal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Glorot normal initializer, also called Xavier normal initializer.\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / (fan_in + fan_out))`\nwhere `fan_in` is the number of input units in the weight tensor\nand `fan_out` is the number of output units in the weight tensor.\n\nReference:\n   Glorot & Bengio, AISTATS 2010\n       http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf",
                "fileName": "#134",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L134-L136",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "heNormal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "He normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(2 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
                "fileName": "#150",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L150-L152",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "heUniform",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "He uniform initializer.\n\nIt draws samples from a uniform distribution within [-limit, limit]\nwhere `limit` is `sqrt(6 / fan_in)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReference:\n     He et al., http://arxiv.org/abs/1502.01852",
                "fileName": "#166",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L166-L168",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "leCunNormal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "LeCun normal initializer.\n\nIt draws samples from a truncated normal distribution centered on 0\nwith `stddev = sqrt(1 / fanIn)`\nwhere `fanIn` is the number of input units in the weight tensor.\n\nReferences:\n   [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)\n   [Efficient Backprop](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf)",
                "fileName": "#183",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L183-L185",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "leCunUniform",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeedOnlyInitializerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "LeCun uniform initializer.\n\nIt draws samples from a uniform distribution in the interval\n`[-limit, limit]` with `limit = sqrt(3 / fanIn)`,\nwhere `fanIn` is the number of input units in the weight tensor.",
                "fileName": "#196",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L196-L198",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Initializers",
                  "namespace": "initializers"
                },
                "symbolName": "orthogonal",
                "namespace": "initializers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "OrthogonalArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Initializer",
                "documentation": "Initializer that generates a random orthogonal matrix.\n\nReference:\n[Saxe et al., http://arxiv.org/abs/1312.6120](http://arxiv.org/abs/1312.6120)",
                "fileName": "#208",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_initializers.ts#L208-L210",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Models",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "SymbolicTensor",
                "documentation": "`tf.SymbolicTensor` is a placeholder for a Tensor without any concrete value.\n\nThey are most often encountered when building a graph of `Layer`s for a\n`tf.LayersModel` and the input data's shape, but not values are known.",
                "fileName": "#98",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L98-L145",
                "methods": [],
                "tags": [],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "LayersModel",
                "documentation": "A `tf.LayersModel` is a directed, acyclic graph of `tf.Layer`s plus methods\nfor training, evaluation, prediction and saving.\n\n`tf.LayersModel` is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a `tf.LayersModel`, use `tf.LayersModel`.\n\nSee also:\n   `tf.Sequential`, `tf.loadLayersModel`.",
                "fileName": "#475",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L475-L2195",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "summary",
                    "paramStr": "(lineLength?, positions?, printFn?)",
                    "parameters": [
                      {
                        "name": "lineLength",
                        "documentation": "Custom line length, in number of characters.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "positions",
                        "documentation": "Custom widths of each of the columns, as either\nfractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\nof characters (e.g., `[30, 50, 65]`). Each number corresponds to\nright-most (i.e., ending) position of a column.",
                        "type": "number[]",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "printFn",
                        "documentation": "Custom print function. Can be used to replace the default\n`console.log`. For example, you can use `x => {}` to mute the printed\nmessages in the console.",
                        "type": "(message?: any, ...optionalParams: any[]) => void",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Print a text summary of the model's layers.\n\nThe summary includes\n- Name and type of all layers that comprise the model.\n- Output shape(s) of the layers\n- Number of weight parameters of each layer\n- If the model has non-sequential-like topology, the inputs each layer\n   receives\n- The total number of trainable and non-trainable parameters of the model.\n\n```js\nconst input1 = tf.input({shape: [10]});\nconst input2 = tf.input({shape: [20]});\nconst dense1 = tf.layers.dense({units: 4}).apply(input1);\nconst dense2 = tf.layers.dense({units: 8}).apply(input2);\nconst concat = tf.layers.concatenate().apply([dense1, dense2]);\nconst output =\n     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);\n\nconst model = tf.model({inputs: [input1, input2], outputs: output});\nmodel.summary();\n```",
                    "fileName": "#559",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L559-L571",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "compile",
                    "paramStr": "(args)",
                    "parameters": [
                      {
                        "name": "args",
                        "documentation": "a `ModelCompileArgs` specifying the loss, optimizer, and\nmetrics to be used for fitting and evaluating this model.",
                        "type": "ModelCompileArgs",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Configures and prepares the model for training and evaluation.  Compiling\noutfits the model with an optimizer, loss, and/or metrics.  Calling `fit`\nor `evaluate` on an un-compiled model will throw an error.",
                    "fileName": "#583",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L583-L785",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluate",
                    "paramStr": "(x, y, args?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "`tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\nmodel has multiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "`tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\nmodel has multiple outputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "args",
                        "documentation": "A `ModelEvaluateArgs`, containing optional fields.",
                        "type": "ModelEvaluateArgs",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Scalar|Scalar[]",
                    "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nconst result = model.evaluate(\n     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});\nresult.print();\n```",
                    "fileName": "#840",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L840-L864",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluateDataset",
                    "paramStr": "(dataset, args?)",
                    "parameters": [
                      {
                        "name": "dataset",
                        "documentation": "A dataset object. Its `iterator()` method is expected\nto generate a dataset iterator object, the `next()` method of which\nis expected to produce data batches for evaluation. The return value\nof the `next()` call ought to contain a boolean `done` field and a\n`value` field. The `value` field is expected to be an array of two\n`tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\ncase is for models with exactly one input and one output (e.g.\na sequential model). The latter case is for models with multiple\ninputs and/or multiple outputs. Of the two items in the array, the\nfirst is the input feature(s) and the second is the output target(s).",
                        "type": "Dataset",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "args",
                        "documentation": "A configuration object for the dataset-based evaluation.",
                        "type": "ModelEvaluateDatasetArgs",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise<Scalar|Scalar[]>",
                    "documentation": "Evaluate model using a dataset object.\n\nNote: Unlike `evaluate()`, this method is asynchronous (`async`).",
                    "fileName": "#888",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L888-L892",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predict",
                    "paramStr": "(x, args?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\nthe model has multiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "args",
                        "documentation": "A `ModelPredictArgs` object containing optional fields.",
                        "type": "ModelPredictArgs",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]",
                    "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nNote: the \"step\" mode of predict() is currently not supported.\n   This is because the TensorFlow.js core backend is imperative only.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predict(tf.ones([8, 10]), {batchSize: 4}).print();\n```",
                    "fileName": "#1105",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1105-L1120",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predictOnBatch",
                    "paramStr": "(x)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": ": Input samples, as a Tensor (for models with exactly one\ninput) or an array of Tensors (for models with more than one input).",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]",
                    "documentation": "Returns predictions for a single batch of samples.\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.predictOnBatch(tf.ones([8, 10])).print();\n```",
                    "fileName": "#1137",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1137-L1143",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fit",
                    "paramStr": "(x, y, args?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "`tf.Tensor` of training data, or an array of `tf.Tensor`s if the\nmodel has multiple inputs. If all inputs in the model are named, you\ncan also pass a dictionary mapping input names to `tf.Tensor`s.",
                        "type": "Tensor|Tensor[]|{[inputName: string]: Tensor}",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "`tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\nthe model has multiple outputs. If all outputs in the model are named,\nyou can also pass a dictionary mapping output names to `tf.Tensor`s.",
                        "type": "Tensor|Tensor[]|{[inputName: string]: Tensor}",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "args",
                        "documentation": "A `ModelFitArgs`, containing optional fields.",
                        "type": "ModelFitArgs",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise<History>",
                    "documentation": "Trains the model for a fixed number of epochs (iterations on a\ndataset).\n\n```js\nconst model = tf.sequential({\n     layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n});\nmodel.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\nfor (let i = 1; i < 5 ; ++i) {\n   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n       batchSize: 4,\n       epochs: 3\n   });\n   console.log(\"Loss after Epoch \" + i + \" : \" + h.history.loss[0]);\n}\n```",
                    "fileName": "#1464",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1464-L1602",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fitDataset",
                    "paramStr": "(dataset, args)",
                    "parameters": [
                      {
                        "name": "dataset",
                        "documentation": "A dataset object. Its `iterator()` method is expected\nto generate a dataset iterator object, the `next()` method of which\nis expected to produce data batches for training. The return value\nof the `next()` call ought to contain a boolean `done` field and a\n`value` field. The `value` field is expected to be an array of two\n`tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\ncase is for models with exactly one input and one output (e.g.\na sequential model). The latter case is for models with multiple\ninputs and/or multiple outputs.\nOf the two items in the array, the first is the input feature(s) and\nthe second is the output target(s).",
                        "type": "Dataset",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "args",
                        "documentation": "A `ModelFitDatasetArgs`, containing optional fields.",
                        "type": "ModelFitDatasetArgs",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise<History>",
                    "documentation": "Trains the model using a dataset object.",
                    "fileName": "#1791",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1791-L1794",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "trainOnBatch",
                    "paramStr": "(x, y)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "Input data. It could be one of the following:\n- A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\nmultiple inputs).\n- An Object mapping input names to corresponding `tf.Tensor` (if the\nmodel has named inputs).",
                        "type": "Tensor|Tensor[]|{[inputName: string]: Tensor}",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "Target data. It could be either a `tf.Tensor` or multiple\n`tf.Tensor`s. It should be consistent with `x`.",
                        "type": "Tensor|Tensor[]|\n      {[inputName: string]: Tensor}",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise<number|number[]>",
                    "documentation": "Runs a single gradient update on a single batch of data.\n\nThis method differs from `fit()` and `fitDataset()` in the following\nregards:\n   - It operates on exactly one batch of data.\n   - It returns only the loss and metric values, instead of\n     returning the batch-by-batch loss and metric values.\n   - It doesn't support fine-grained options such as verbosity and\n     callbacks.",
                    "fileName": "#1819",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L1819-L1839",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes",
                      "ignoreCI": true
                    },
                    "symbolName": "save",
                    "paramStr": "(handlerOrURL, config?)",
                    "parameters": [
                      {
                        "name": "handlerOrURL",
                        "documentation": "An instance of `IOHandler` or a URL-like,\nscheme-based string shortcut for `IOHandler`.",
                        "type": "io.IOHandler|string",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "config",
                        "documentation": "Options for saving the model.",
                        "type": "io.SaveConfig",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise<io.SaveResult>",
                    "documentation": "Save the configuration and/or weights of the LayersModel.\n\nAn `IOHandler` is an object that has a `save` method of the proper\nsignature defined. The `save` method manages the storing or\ntransmission of serialized data (\"artifacts\") that represent the\nmodel's topology and weights onto or via a specific medium, such as\nfile downloads, local storage, IndexedDB in the web browser and HTTP\nrequests to a server. TensorFlow.js provides `IOHandler`\nimplementations for a number of frequently used saving mediums, such as\n`tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`\nfor more details.\n\nThis method also allows you to refer to certain types of `IOHandler`s\nas URL-like string shortcuts, such as 'localstorage://' and\n'indexeddb://'.\n\nExample 1: Save `model`'s topology and weights to browser [local\nstorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('localstorage://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 2. Saving `model`'s topology and weights to browser\n[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('indexeddb://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 3. Saving `model`'s topology and weights as two files\n(`my-model-1.json` and `my-model-1.weights.bin`) downloaded from\nbrowser.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconst saveResults = await model.save('downloads://my-model-1');\n```\n\nExample 4. Send  `model`'s topology and weights to an HTTP server.\nSee the documentation of `tf.io.http` for more details\nincluding specifying request parameters and implementation of the\nserver.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconst saveResults = await model.save('http://my-server/model/upload');\n```",
                    "fileName": "#2112",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L2112-L2166",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Layers",
                      "subheading": "Classes",
                      "namespace": "layers",
                      "subclasses": [
                        "LayersModel"
                      ]
                    },
                    "symbolName": "getLayer",
                    "namespace": "layers",
                    "paramStr": "(name)",
                    "parameters": [
                      {
                        "name": "name",
                        "documentation": "Name of layer.",
                        "type": "string",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Layer",
                    "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                    "fileName": "#975",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L975-L975",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Layers",
                      "subheading": "Classes",
                      "namespace": "layers",
                      "subclasses": [
                        "LayersModel"
                      ]
                    },
                    "symbolName": "getLayer",
                    "namespace": "layers",
                    "paramStr": "(name)",
                    "parameters": [
                      {
                        "name": "name",
                        "documentation": "Name of layer.",
                        "type": "string",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Layer",
                    "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                    "fileName": "#976",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L976-L976",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Layers",
                      "subheading": "Classes",
                      "namespace": "layers",
                      "subclasses": [
                        "LayersModel"
                      ]
                    },
                    "symbolName": "getLayer",
                    "namespace": "layers",
                    "paramStr": "(name)",
                    "parameters": [
                      {
                        "name": "name",
                        "documentation": "Name of layer.",
                        "type": "string",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Layer",
                    "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                    "fileName": "#977",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L977-L977",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Layers",
                      "subheading": "Classes",
                      "namespace": "layers",
                      "subclasses": [
                        "LayersModel"
                      ]
                    },
                    "symbolName": "getLayer",
                    "namespace": "layers",
                    "paramStr": "(name)",
                    "parameters": [
                      {
                        "name": "name",
                        "documentation": "Name of layer.",
                        "type": "string",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Layer",
                    "documentation": "Retrieves a layer based on either its name (unique) or index.\n\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nIf both `name` and `index` are specified, `index` takes precedence.",
                    "fileName": "#978",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/container.ts#L978-L996",
                    "tags": [],
                    "isFunction": true
                  }
                ],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "Container|tfc.InferenceModel"
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Functional",
                "documentation": "A `tf.Functional` is an alias to `tf.LayersModel`.\n\nSee also:\n   `tf.LayersModel`, `tf.Sequential`, `tf.loadLayersModel`.",
                "fileName": "#2205",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/training.ts#L2205-L2207",
                "methods": [],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "LayersModel"
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Sequential",
                "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n`tf.sequential` is a factory function that creates an instance of\n`tf.Sequential`.\n\n```js\n  // Define a model for linear regression.\n  const model = tf.sequential();\n  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n\n  // Prepare the model for training: Specify the loss and the optimizer.\n  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n\n  // Generate some synthetic data for training.\n  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n\n  // Train the model using the data then do inference on a data point the\n  // model hasn't seen:\n  await model.fit(xs, ys);\n  model.predict(tf.tensor2d([5], [1, 1])).print();\n```",
                "fileName": "#397",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L397-L1113",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "add",
                    "paramStr": "(layer)",
                    "parameters": [
                      {
                        "name": "layer",
                        "documentation": "Layer instance.",
                        "type": "Layer",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Adds a layer instance on top of the layer stack.\n\n```js\n  const model = tf.sequential();\n  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n  // Note that the untrained model is random at this point.\n  model.predict(tf.randomNormal([10, 1])).print();\n```",
                    "fileName": "#452",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L452-L555",
                    "tags": [],
                    "isFunction": true
                  }
                ],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "LayersModel"
              }
            ]
          },
          {
            "name": "Loading",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Loading"
                },
                "symbolName": "loadLayersModel",
                "paramStr": "(pathOrIOHandler, options?)",
                "parameters": [
                  {
                    "name": "pathOrIOHandler",
                    "documentation": "Can be either of the two formats\n1. A string path to the `ModelAndWeightsConfig` JSON describing\nthe model in the canonical TensorFlow.js format. For file://\n(tfjs-node-only), http:// and https:// schemas, the path can be\neither absolute or relative. The content of the JSON file is assumed to\nbe a JSON object with the following fields and values:\n- 'modelTopology': A JSON object that can be either of:\n1. a model architecture JSON consistent with the format of the return\nvalue of `keras.Model.to_json()`\n2. a full model JSON in the format of `keras.models.save_model()`.\n- 'weightsManifest': A TensorFlow.js weights manifest.\nSee the Python converter function `save_model()` for more details.\nIt is also assumed that model weights can be accessed from relative\npaths described by the `paths` fields in weights manifest.\n2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\nmethod.",
                    "type": "string|io.IOHandler",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "options",
                    "documentation": "Optional configuration arguments for the model loading,\nincluding:\n- `strict`: Require that the provided weights exactly match those required\nby the layers.  Default true.  Passing false means that both extra\nweights and missing weights will be silently ignored.\n- `onProgress`: A progress callback of the form:\n`(fraction: number) => void`. This callback can be used to monitor the\nmodel-loading process.",
                    "type": "io.LoadOptions",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Promise<LayersModel>",
                "documentation": "Load a model composed of Layer objects, including its topology and optionally\nweights. See the Tutorial named \"How to import a Keras Model\" for usage\nexamples.\n\nThis method is applicable to:\n\n1. Models created with the `tf.layers.*`, `tf.sequential`, and\n`tf.model` APIs of TensorFlow.js and later saved with the\n`tf.LayersModel.save` method.\n2. Models converted from Keras or TensorFlow tf.keras using the\n[tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n\nThis mode is *not* applicable to TensorFlow `SavedModel`s or their converted\nforms. For those models, use `tf.loadGraphModel`.\n\nExample 1. Load a model from an HTTP server.\n\n```js\nconst model = await tf.loadLayersModel(\n     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\nmodel.summary();\n```\n\nExample 2: Save `model`'s topology and weights to browser [local\nstorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('localstorage://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 3. Saving `model`'s topology and weights to browser\n[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\nthen load it back.\n\n```js\nconst model = tf.sequential(\n     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\nconsole.log('Prediction from original model:');\nmodel.predict(tf.ones([1, 3])).print();\n\nconst saveResults = await model.save('indexeddb://my-model-1');\n\nconst loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\nconsole.log('Prediction from loaded model:');\nloadedModel.predict(tf.ones([1, 3])).print();\n```\n\nExample 4. Load a model from user-selected files from HTML\n[file input\nelements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n\n```js\n// Note: this code snippet will not work without the HTML elements in the\n//   page\nconst jsonUpload = document.getElementById('json-upload');\nconst weightsUpload = document.getElementById('weights-upload');\n\nconst model = await tf.loadLayersModel(\n     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n```",
                "fileName": "#248",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/models.ts#L248-L270",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Creation",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation"
                },
                "symbolName": "model",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ContainerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "LayersModel",
                "documentation": "A model is a data structure that consists of `Layers` and defines inputs\nand outputs.\n\nThe key difference between `tf.model` and `tf.sequential` is that\n`tf.model` is more generic, supporting an arbitrary graph (without\ncycles) of layers. `tf.sequential` is less generic and supports only a linear\nstack of layers.\n\nWhen creating a `tf.LayersModel`, specify its input(s) and output(s). Layers\nare used to wire input(s) to output(s).\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 4, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\nSee also:\n   `tf.sequential`, `tf.loadLayersModel`.",
                "fileName": "#70",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L70-L72",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation"
                },
                "symbolName": "sequential",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "SequentialArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Sequential",
                "documentation": "Creates a `tf.Sequential` model.  A sequential model is any model where the\noutputs of one layer are the inputs to the next layer, i.e. the model\ntopology is a simple 'stack' of layers, with no branching or skipping.\n\nThis means that the first layer passed to a `tf.Sequential` model should have\na defined input shape. What that means is that it should have received an\n`inputShape` or `batchInputShape` argument, or for some type of layers\n(recurrent, Dense...) an `inputDim` argument.\n\nThe key difference between `tf.model` and `tf.sequential` is that\n`tf.sequential` is less generic, supporting only a linear stack of layers.\n`tf.model` is more generic and supports an arbitrary graph (without\ncycles) of layers.\n\nExamples:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have an input shape defined.\nmodel.add(tf.layers.dense({units: 32, inputShape: [50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output, which equals\n// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the\n// 2nd is the output size of the model's last layer.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nIt is also possible to specify a batch size (with potentially undetermined\nbatch dimension, denoted by \"null\") for the first layer using the\n`batchInputShape` key. The following example is equivalent to the above:\n\n```js\nconst model = tf.sequential();\n\n// First layer must have a defined input shape\nmodel.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));\n// Afterwards, TF.js does automatic shape inference.\nmodel.add(tf.layers.dense({units: 4}));\n\n// Inspect the inferred shape of the model's output.\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```\n\nYou can also use an `Array` of already-constructed `Layer`s to create\na `tf.Sequential` model:\n\n```js\nconst model = tf.sequential({\n   layers: [tf.layers.dense({units: 32, inputShape: [50]}),\n            tf.layers.dense({units: 4})]\n});\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
                "fileName": "#134",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L134-L136",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Inputs",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Inputs"
                },
                "symbolName": "input",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "InputConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SymbolicTensor",
                "documentation": "Used to instantiate an input to a model as a `tf.SymbolicTensor`.\n\nUsers should call the `input` factory function for\nconsistency with other generator functions.\n\nExample:\n\n```js\n// Defines a simple logistic regression model with 32 dimensional input\n// and 3 dimensional output.\nconst x = tf.input({shape: [32]});\nconst y = tf.layers.dense({units: 3, activation: 'softmax'}).apply(x);\nconst model = tf.model({inputs: x, outputs: y});\nmodel.predict(tf.ones([2, 32])).print();\n```\n\nNote: `input` is only necessary when using `model`. When using\n`sequential`, specify `inputShape` for the first layer or use `inputLayer`\nas the first layer.",
                "fileName": "#161",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports.ts#L161-L163",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Layers",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Classes",
                  "namespace": "layers"
                },
                "symbolName": "Layer",
                "namespace": "layers",
                "documentation": "A layer is a grouping of operations and weights that can be composed to\ncreate a `tf.LayersModel`.\n\nLayers are constructed by using the functions under the\n[tf.layers](#Layers-Basic) namespace.",
                "fileName": "#405",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L405-L1566",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "apply",
                    "paramStr": "(inputs, kwargs?)",
                    "parameters": [
                      {
                        "name": "inputs",
                        "documentation": "a `tf.Tensor` or `tf.SymbolicTensor` or an Array of them.",
                        "type": "Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "kwargs",
                        "documentation": "Additional keyword arguments to be passed to `call()`.",
                        "type": "Kwargs",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[]",
                    "documentation": "Builds or executes a `Layer`'s logic.\n\nWhen called with `tf.Tensor`(s), execute the `Layer`'s computation and\nreturn Tensor(s). For example:\n\n```js\nconst denseLayer = tf.layers.dense({\n   units: 1,\n   kernelInitializer: 'zeros',\n   useBias: false\n});\n\n// Invoke the layer's apply() method with a `tf.Tensor` (with concrete\n// numeric values).\nconst input = tf.ones([2, 2]);\nconst output = denseLayer.apply(input);\n\n// The output's value is expected to be [[0], [0]], due to the fact that\n// the dense layer has a kernel initialized to all-zeros and does not have\n// a bias.\noutput.print();\n```\n\nWhen called with `tf.SymbolicTensor`(s), this will prepare the layer for\nfuture execution.  This entails internal book-keeping on shapes of\nexpected Tensors, wiring layers together, and initializing weights.\n\nCalling `apply` with `tf.SymbolicTensor`s are typically used during the\nbuilding of non-`tf.Sequential` models. For example:\n\n```js\nconst flattenLayer = tf.layers.flatten();\nconst denseLayer = tf.layers.dense({units: 1});\n\n// Use tf.layers.input() to obtain a SymbolicTensor as input to apply().\nconst input = tf.input({shape: [2, 2]});\nconst output1 = flattenLayer.apply(input);\n\n// output1.shape is [null, 4]. The first dimension is the undetermined\n// batch size. The second dimension comes from flattening the [2, 2]\n// shape.\nconsole.log(JSON.stringify(output1.shape));\n\n// The output SymbolicTensor of the flatten layer can be used to call\n// the apply() of the dense layer:\nconst output2 = denseLayer.apply(output1);\n\n// output2.shape is [null, 1]. The first dimension is the undetermined\n// batch size. The second dimension matches the number of units of the\n// dense layer.\nconsole.log(JSON.stringify(output2.shape));\n\n// The input and output can be used to construct a model that consists\n// of the flatten and dense layers.\nconst model = tf.model({inputs: input, outputs: output2});\n```",
                    "fileName": "#947",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L947-L1090",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "countParams",
                    "paramStr": "()",
                    "parameters": [],
                    "returnType": "number",
                    "documentation": "Counts the total number of numbers (e.g., float32, int32) in the\nweights.",
                    "fileName": "#1179",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1179-L1187",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "build",
                    "paramStr": "(inputShape)",
                    "parameters": [
                      {
                        "name": "inputShape",
                        "documentation": "A `Shape` or array of `Shape` (unused).",
                        "type": "Shape|Shape[]",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Creates the layer weights.\n\nMust be implemented on all layers that have weights.\n\nCalled when apply() is called to construct the weights.",
                    "fileName": "#1200",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1200-L1202",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "getWeights",
                    "paramStr": "(trainableOnly?)",
                    "parameters": [
                      {
                        "name": "trainableOnly",
                        "documentation": "Whether to get the values of only trainable weights.",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor[]",
                    "documentation": "Returns the current values of the weights of the layer.",
                    "fileName": "#1212",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1212-L1214",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "setWeights",
                    "paramStr": "(weights)",
                    "parameters": [
                      {
                        "name": "weights",
                        "documentation": "a list of Tensors. The number of arrays and their shape\nmust match number of the dimensions of the weights of the layer (i.e.\nit should match the output of `getWeights`).",
                        "type": "Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Sets the weights of the layer, from Tensors.",
                    "fileName": "#1228",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1228-L1260",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "addWeight",
                    "paramStr": "(name, shape, dtype?, initializer?, regularizer?, trainable?, constraint?, getInitializerFunc?)",
                    "parameters": [
                      {
                        "name": "name",
                        "documentation": "Name of the new weight variable.",
                        "type": "string",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "shape",
                        "documentation": "The shape of the weight.",
                        "type": "Shape",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "dtype",
                        "documentation": "The dtype of the weight.",
                        "type": "DataType",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "initializer",
                        "documentation": "An initializer instance.",
                        "type": "Initializer",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "regularizer",
                        "documentation": "A regularizer instance.",
                        "type": "Regularizer",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "trainable",
                        "documentation": "Whether the weight should be trained via backprop or not\n(assuming that the layer itself is also trainable).",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "constraint",
                        "documentation": "An optional trainable.",
                        "type": "Constraint",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "getInitializerFunc",
                        "documentation": "",
                        "type": "Function",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "LayerVariable",
                    "documentation": "Adds a weight variable to the layer.",
                    "fileName": "#1277",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1277-L1313",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "addLoss",
                    "paramStr": "(losses)",
                    "parameters": [
                      {
                        "name": "losses",
                        "documentation": "",
                        "type": "RegularizerFn|RegularizerFn[]",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Add losses to the layer.\n\nThe loss may potentially be conditional on some inputs tensors,\nfor instance activity losses are conditional on the layer's inputs.",
                    "fileName": "#1337",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1337-L1346",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "computeOutputShape",
                    "paramStr": "(inputShape)",
                    "parameters": [
                      {
                        "name": "inputShape",
                        "documentation": "A shape (tuple of integers) or a list of shape tuples\n(one per output tensor of the layer). Shape tuples can include null for\nfree dimensions, instead of an integer.",
                        "type": "Shape|Shape[]",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Shape|Shape[]",
                    "documentation": "Computes the output shape of the layer.\n\nAssumes that the layer will be built to match that input shape provided.",
                    "fileName": "#1359",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1359-L1361",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "getConfig",
                    "paramStr": "()",
                    "parameters": [],
                    "returnType": "serialization.ConfigDict",
                    "documentation": "Returns the config of the layer.\n\nA layer config is a TS dictionary (serializable)\ncontaining the configuration of a layer.\nThe same layer can be reinstantiated later\n(without its trained weights) from this configuration.\n\nThe config of a layer does not include connectivity\ninformation, nor the layer class name.  These are handled\nby 'Container' (one layer of abstraction above).\n\nPorting Note: The TS dictionary follows TS naming standards for\nkeys, and uses tfjs-layers type-safe Enums.  Serialization methods\nshould use a helper function to convert to the pythonic storage\nstandard. (see serialization_utils.convertTsToPythonic)",
                    "fileName": "#1486",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1486-L1496",
                    "tags": [],
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "dispose",
                    "paramStr": "()",
                    "parameters": [],
                    "returnType": "DisposeResult",
                    "documentation": "Attempt to dispose layer's weights.\n\nThis method decreases the reference count of the Layer object by 1.\n\nA Layer is reference-counted. Its reference count is incremented by 1\nthe first item its `apply()` method is called and when it becomes a part\nof a new `Node` (through calling the `apply()` method on a\n`tf.SymbolicTensor`).\n\nIf the reference count of a Layer becomes 0, all the weights will be\ndisposed and the underlying memory (e.g., the textures allocated in WebGL)\nwill be freed.\n\nNote: If the reference count is greater than 0 after the decrement, the\nweights of the Layer will *not* be disposed.\n\nAfter a Layer is disposed, it cannot be used in calls such as `apply()`,\n`getWeights()` or `setWeights()` anymore.",
                    "fileName": "#1544",
                    "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/engine/topology.ts#L1544-L1565",
                    "tags": [],
                    "isFunction": true
                  }
                ],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "serialization.Serializable"
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Classes"
                },
                "symbolName": "RNNCell",
                "documentation": "An RNNCell layer.",
                "fileName": "#861",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/layers/recurrent.ts#L861-L871",
                "methods": [],
                "tags": [],
                "isClass": true,
                "inheritsFrom": "Layer"
              }
            ]
          },
          {
            "name": "Inputs",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Inputs",
                  "namespace": "layers"
                },
                "symbolName": "inputLayer",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "InputLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "InputLayer",
                "documentation": "An input layer is an entry point into a `tf.LayersModel`.\n\n`InputLayer` is generated automatically for `tf.Sequential` models by\nspecifying the `inputshape` or `batchInputShape` for the first layer.  It\nshould not be specified explicitly. However, it can be useful sometimes,\ne.g., when constructing a sequential model from a subset of another\nsequential model's layers. Like the code snippet below shows.\n\n```js\n// Define a model which simply adds two inputs.\nconst model1 = tf.sequential();\nmodel1.add(tf.layers.dense({inputShape: [4], units: 3, activation: 'relu'}));\nmodel1.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\nmodel1.summary();\nmodel1.predict(tf.zeros([1, 4])).print();\n\n// Construct another model, reusing the second layer of `model1` while\n// not using the first layer of `model1`. Note that you cannot add the second\n// layer of `model` directly as the first layer of the new sequential model,\n// because doing so will lead to an error related to the fact that the layer\n// is not an input layer. Instead, you need to create an `inputLayer` and add\n// it to the new sequential model before adding the reused layer.\nconst model2 = tf.sequential();\n// Use an inputShape that matches the input shape of `model1`'s second\n// layer.\nmodel2.add(tf.layers.inputLayer({inputShape: [3]}));\nmodel2.add(model1.layers[1]);\nmodel2.summary();\nmodel2.predict(tf.zeros([1, 3])).print();\n```",
                "fileName": "#72",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L72-L74",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Advanced Activation",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "elu",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ELULayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ELU",
                "documentation": "Exponential Linear Unit (ELU).\n\nIt follows:\n`f(x) =  alpha * (exp(x) - 1.) for x < 0`,\n`f(x) = x for x >= 0`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Fast and Accurate Deep Network Learning by Exponential Linear Units\n(ELUs)](https://arxiv.org/abs/1511.07289v1)",
                "fileName": "#102",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L102-L104",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "reLU",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ReLULayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ReLU",
                "documentation": "Rectified Linear Unit activation function.\n\nInput shape:\n   Arbitrary. Use the config field `inputShape` (Array of integers, does\n   not include the sample axis) when using this layer as the first layer\n   in a model.\n\nOutput shape:\n   Same shape as the input.",
                "fileName": "#123",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L123-L125",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "leakyReLU",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LeakyReLULayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "LeakyReLU",
                "documentation": "Leaky version of a rectified linear unit.\n\nIt allows a small gradient when the unit is not active:\n`f(x) = alpha * x for x < 0.`\n`f(x) = x for x >= 0.`\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
                "fileName": "#147",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L147-L149",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "prelu",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "PReLULayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "PReLU",
                "documentation": "Parameterized version of a leaky rectified linear unit.\n\nIt follows\n`f(x) = alpha * x for x < 0.`\n`f(x) = x for x >= 0.`\nwherein `alpha` is a trainable weight.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
                "fileName": "#172",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L172-L174",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "softmax",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SoftmaxLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Softmax",
                "documentation": "Softmax activation layer.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.",
                "fileName": "#192",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L192-L194",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Advanced Activation",
                  "namespace": "layers"
                },
                "symbolName": "thresholdedReLU",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ThresholdedReLULayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ThresholdedReLU",
                "documentation": "Thresholded Rectified Linear Unit.\n\nIt follows:\n`f(x) = x for x > theta`,\n`f(x) = 0 otherwise`.\n\nInput shape:\n   Arbitrary. Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\nOutput shape:\n   Same shape as the input.\n\nReferences:\n   - [Zero-Bias Autoencoders and the Benefits of Co-Adapting\nFeatures](http://arxiv.org/abs/1402.3337)",
                "fileName": "#220",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L220-L222",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Convolutional",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "conv1d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Conv1D",
                "documentation": "1D convolution layer (e.g., temporal convolution).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input over a single spatial (or temporal) dimension\nto produce a tensor of outputs.\n\nIf `use_bias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model, provide an\n`inputShape` argument `Array` or `null`.\n\nFor example, `inputShape` would be:\n- `[10, 128]` for sequences of 10 vectors of 128-dimensional vectors\n- `[null, 128]` for variable-length sequences of 128-dimensional vectors.",
                "fileName": "#246",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L246-L248",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "conv2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Conv2D",
                "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat='channelsLast'`.",
                "fileName": "#268",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L268-L270",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "conv2dTranspose",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Conv2DTranspose",
                "documentation": "Transposed convolutional layer (sometimes called Deconvolution).\n\nThe need for transposed convolutions generally arises\nfrom the desire to use a transformation going in the opposite direction of\na normal convolution, i.e., from something that has the shape of the output\nof some convolution to something that has the shape of its input while\nmaintaining a connectivity pattern that is compatible with said\nconvolution.\n\nWhen using this layer as the first layer in a model, provide the\nconfiguration `inputShape` (`Array` of integers, does not include the\nsample axis), e.g., `inputShape: [128, 128, 3]` for 128x128 RGB pictures in\n`dataFormat: 'channelsLast'`.\n\nInput shape:\n   4D tensor with shape:\n   `[batch, channels, rows, cols]` if `dataFormat` is `'channelsFirst'`.\n   or 4D tensor with shape\n   `[batch, rows, cols, channels]` if `dataFormat` is `'channelsLast'`.\n\nOutput shape:\n   4D tensor with shape:\n   `[batch, filters, newRows, newCols]` if `dataFormat` is\n`'channelsFirst'`. or 4D tensor with shape:\n   `[batch, newRows, newCols, filters]` if `dataFormat` is `'channelsLast'`.\n\nReferences:\n   - [A guide to convolution arithmetic for deep\nlearning](https://arxiv.org/abs/1603.07285v1)\n   - [Deconvolutional\nNetworks](http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf)",
                "fileName": "#307",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L307-L309",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "conv3d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Conv3D",
                "documentation": "3D convolution layer (e.g. spatial convolution over volumes).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `null`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 128, 1]` for 128x128x128 grayscale volumes\nin `dataFormat='channelsLast'`.",
                "fileName": "#329",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L329-L331",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "separableConv2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SeparableConvLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SeparableConv2D",
                "documentation": "Depthwise separable 2D convolution.\n\nSeparable convolution consists of first performing\na depthwise spatial convolution\n(which acts on each input channel separately)\nfollowed by a pointwise convolution which mixes together the resulting\noutput channels. The `depthMultiplier` argument controls how many\noutput channels are generated per input channel in the depthwise step.\n\nIntuitively, separable convolutions can be understood as\na way to factorize a convolution kernel into two smaller kernels,\nor as an extreme version of an Inception block.\n\nInput shape:\n   4D tensor with shape:\n     `[batch, channels, rows, cols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, rows, cols, channels]` if data_format='channelsLast'.\n\nOutput shape:\n   4D tensor with shape:\n     `[batch, filters, newRows, newCols]` if data_format='channelsFirst'\n   or 4D tensor with shape:\n     `[batch, newRows, newCols, filters]` if data_format='channelsLast'.\n     `rows` and `cols` values might have changed due to padding.",
                "fileName": "#366",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L366-L368",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "cropping2D",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Cropping2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Cropping2D",
                "documentation": "Cropping layer for 2D input (e.g., image).\n\nThis layer can crop an input\nat the top, bottom, left and right side of an image tensor.\n\nInput shape:\n   4D tensor with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, rows, cols, channels]`\n   - If `data_format` is `\"channels_first\"`:\n     `[batch, channels, rows, cols]`.\n\nOutput shape:\n   4D with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, croppedRows, croppedCols, channels]`\n    - If `dataFormat` is `\"channelsFirst\"`:\n     `[batch, channels, croppedRows, croppedCols]`.\n\nExamples\n```js\n\nconst model = tf.sequential();\nmodel.add(tf.layers.cropping2D({cropping:[[2, 2], [2, 2]],\n                                inputShape: [128, 128, 3]}));\n//now output shape is [batch, 124, 124, 3]\n```",
                "fileName": "#401",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L401-L403",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "upSampling2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "UpSampling2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "UpSampling2D",
                "documentation": "Upsampling layer for 2D inputs.\n\nRepeats the rows and columns of the data\nby size[0] and size[1] respectively.\n\n\nInput shape:\n    4D tensor with shape:\n     - If `dataFormat` is `\"channelsLast\"`:\n         `[batch, rows, cols, channels]`\n     - If `dataFormat` is `\"channelsFirst\"`:\n        `[batch, channels, rows, cols]`\n\nOutput shape:\n     4D tensor with shape:\n     - If `dataFormat` is `\"channelsLast\"`:\n        `[batch, upsampledRows, upsampledCols, channels]`\n     - If `dataFormat` is `\"channelsFirst\"`:\n         `[batch, channels, upsampledRows, upsampledCols]`",
                "fileName": "#429",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L429-L431",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers"
                },
                "symbolName": "depthwiseConv2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "DepthwiseConv2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "DepthwiseConv2D",
                "documentation": "Depthwise separable 2D convolution.\n\nDepthwise Separable convolutions consists in performing just the first step\nin a depthwise spatial convolution (which acts on each input channel\nseparately). The `depthMultiplier` argument controls how many output channels\nare generated per input channel in the depthwise step.",
                "fileName": "#445",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L445-L447",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Basic",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "activation",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ActivationLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Activation",
                "documentation": "Applies an activation function to an output.\n\nThis layer applies element-wise activation function.  Other layers, notably\n`dense` can also apply activation functions.  Use this isolated activation\nfunction to extract the values before and after the\nactivation. For instance:\n\n```js\nconst input = tf.input({shape: [5]});\nconst denseLayer = tf.layers.dense({units: 1});\nconst activationLayer = tf.layers.activation({activation: 'relu6'});\n\n// Obtain the output symbolic tensors by applying the layers in order.\nconst denseOutput = denseLayer.apply(input);\nconst activationOutput = activationLayer.apply(denseOutput);\n\n// Create the model based on the inputs.\nconst model = tf.model({\n     inputs: input,\n     outputs: [denseOutput, activationOutput]\n});\n\n// Collect both outputs and print separately.\nconst [denseOut, activationOut] = model.predict(tf.randomNormal([6, 5]));\ndenseOut.print();\nactivationOut.print();\n```",
                "fileName": "#482",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L482-L484",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "dense",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "DenseLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Dense",
                "documentation": "Creates a dense (fully connected) layer.\n\nThis layer implements the operation:\n   `output = activation(dot(input, kernel) + bias)`\n\n`activation` is the element-wise activation function\n   passed as the `activation` argument.\n\n`kernel` is a weights matrix created by the layer.\n\n`bias` is a bias vector created by the layer (only applicable if `useBias`\nis `true`).\n\n*Input shape:**\n\n   nD `tf.Tensor` with shape: `(batchSize, ..., inputDim)`.\n\n   The most common situation would be\n   a 2D input with shape `(batchSize, inputDim)`.\n\n*Output shape:**\n\n   nD tensor with shape: `(batchSize, ..., units)`.\n\n   For instance, for a 2D input with shape `(batchSize, inputDim)`,\n   the output would have shape `(batchSize, units)`.\n\nNote: if the input to the layer has a rank greater than 2, then it is\nflattened prior to the initial dot product with the kernel.",
                "fileName": "#519",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L519-L521",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "dropout",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "DropoutLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Dropout",
                "documentation": "Applies\n[dropout](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf) to\nthe input.\n\nDropout consists in randomly setting a fraction `rate` of input units to 0 at\neach update during training time, which helps prevent overfitting.",
                "fileName": "#533",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L533-L535",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "spatialDropout1d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SpatialDropout1DLayerConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SpatialDropout1D",
                "documentation": "Spatial 1D version of Dropout.\n\nThis Layer type performs the same function as the Dropout layer, but it drops\nentire 1D feature maps instead of individual elements. For example, if an\ninput example consists of 3 timesteps and the feature map for each timestep\nhas a size of 4, a `spatialDropout1d` layer may zero out the feature maps\nof the 1st timesteps and 2nd timesteps completely while sparing all feature\nelements of the 3rd timestep.\n\nIf adjacent frames (timesteps) are strongly correlated (as is normally the\ncase in early convolution layers), regular dropout will not regularize the\nactivation and will otherwise just result in merely an effective learning\nrate decrease. In this case, `spatialDropout1d` will help promote\nindependence among feature maps and should be used instead.\n\n*Arguments:**\n   rate: A floating-point number >=0 and <=1. Fraction of the input elements\n     to drop.\n\n*Input shape:**\n   3D tensor with shape `(samples, timesteps, channels)`.\n\n*Output shape:**\n   Same as the input shape.\n\nReferences:\n   - [Efficient Object Localization Using Convolutional\n      Networks](https://arxiv.org/abs/1411.4280)",
                "fileName": "#569",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L569-L571",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "flatten",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "FlattenLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Flatten",
                "documentation": "Flattens the input. Does not affect the batch size.\n\nA `Flatten` layer flattens each batch in its inputs to 1D (making the output\n2D).\n\nFor example:\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst flattenLayer = tf.layers.flatten();\n// Inspect the inferred output shape of the flatten layer, which\n// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the\n// flattening. (The 1st dimension is the undermined batch size.)\nconsole.log(JSON.stringify(flattenLayer.apply(input).shape));\n```",
                "fileName": "#592",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L592-L594",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "repeatVector",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RepeatVectorLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "RepeatVector",
                "documentation": "Repeats the input n times in a new dimension.\n\n```js\n  const model = tf.sequential();\n  model.add(tf.layers.repeatVector({n: 4, inputShape: [2]}));\n  const x = tf.tensor2d([[10, 20]]);\n  // Use the model to do inference on a data point the model hasn't seen\n  model.predict(x).print();\n  // output shape is now [batch, 2, 4]\n```",
                "fileName": "#610",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L610-L612",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "reshape",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ReshapeLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Reshape",
                "documentation": "Reshapes an input to a certain shape.\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst reshapeLayer = tf.layers.reshape({targetShape: [2, 6]});\n// Inspect the inferred output shape of the Reshape layer, which\n// equals `[null, 2, 6]`. (The 1st dimension is the undermined batch size.)\nconsole.log(JSON.stringify(reshapeLayer.apply(input).shape));\n```\n\nInput shape:\n   Arbitrary, although all dimensions in the input shape must be fixed.\n   Use the configuration `inputShape` when using this layer as the\n   first layer in a model.\n\n\nOutput shape:\n   [batchSize, targetShape[0], targetShape[1], ...,\n    targetShape[targetShape.length - 1]].",
                "fileName": "#637",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L637-L639",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "permute",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "PermuteLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Permute",
                "documentation": "Permutes the dimensions of the input according to a given pattern.\n\nUseful for, e.g., connecting RNNs and convnets together.\n\nExample:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.permute({\n   dims: [2, 1],\n   inputShape: [10, 64]\n}));\nconsole.log(model.outputShape);\n// Now model's output shape is [null, 64, 10], where null is the\n// unpermuted sample (batch) dimension.\n```\n\nInput shape:\n   Arbitrary. Use the configuration field `inputShape` when using this\n   layer as the first layer in a model.\n\nOutput shape:\n   Same rank as the input shape, but with the dimensions re-ordered (i.e.,\n   permuted) according to the `dims` configuration of this layer.",
                "fileName": "#669",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L669-L671",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Basic",
                  "namespace": "layers"
                },
                "symbolName": "embedding",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "EmbeddingLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Embedding",
                "documentation": "Maps positive integers (indices) into dense vectors of fixed size.\nE.g. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]\n\n*Input shape:** 2D tensor with shape: `[batchSize, sequenceLength]`.\n\n*Output shape:** 3D tensor with shape: `[batchSize, sequenceLength,\noutputDim]`.",
                "fileName": "#684",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L684-L686",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Merge",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "add",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Add",
                "documentation": "Layer that performs element-wise addition on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). The inputs are specified as an\n`Array` when the `apply` method of the `Add` layer instance is called. For\nexample:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst addLayer = tf.layers.add();\nconst sum = addLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(sum.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
                "fileName": "#710",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L710-L712",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "average",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Average",
                "documentation": "Layer that performs element-wise averaging on an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst averageLayer = tf.layers.average();\nconst average = averageLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(average.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
                "fileName": "#732",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L732-L734",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "concatenate",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConcatenateLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Concatenate",
                "documentation": "Layer that concatenates an `Array` of inputs.\n\nIt takes a list of tensors, all of the same shape except for the\nconcatenation axis, and returns a single tensor, the concatenation\nof all inputs. For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 3]});\nconst concatLayer = tf.layers.concatenate();\nconst output = concatLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(output.shape));\n// You get [null, 2, 5], with the first dimension as the undetermined batch\n// dimension. The last dimension (5) is the result of concatenating the\n// last dimensions of the inputs (2 and 3).\n```",
                "fileName": "#756",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L756-L758",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "maximum",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Maximum",
                "documentation": "Layer that computes the element-wise maximum of an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst maxLayer = tf.layers.maximum();\nconst max = maxLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(max.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
                "fileName": "#778",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L778-L780",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "minimum",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Minimum",
                "documentation": "Layer that computes the element-wise minimum of an `Array` of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape). For example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst minLayer = tf.layers.minimum();\nconst min = minLayer.apply([input1, input2]);\nconsole.log(JSON.stringify(min.shape));\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.\n```",
                "fileName": "#800",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L800-L802",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "multiply",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Multiply",
                "documentation": "Layer that multiplies (element-wise) an `Array` of inputs.\n\nIt takes as input an Array of tensors, all of the same\nshape, and returns a single tensor (also of the same shape).\nFor example:\n\n```js\nconst input1 = tf.input({shape: [2, 2]});\nconst input2 = tf.input({shape: [2, 2]});\nconst input3 = tf.input({shape: [2, 2]});\nconst multiplyLayer = tf.layers.multiply();\nconst product = multiplyLayer.apply([input1, input2, input3]);\nconsole.log(product.shape);\n// You get [null, 2, 2], with the first dimension as the undetermined batch\n// dimension.",
                "fileName": "#823",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L823-L825",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers"
                },
                "symbolName": "dot",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "DotLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Dot",
                "documentation": "Layer that computes a dot product between samples in two tensors.\n\nE.g., if applied to a list of two tensors `a` and `b` both of shape\n`[batchSize, n]`, the output will be a tensor of shape `[batchSize, 1]`,\nwhere each entry at index `[i, 0]` will be the dot product between\n`a[i, :]` and `b[i, :]`.\n\nExample:\n\n```js\nconst dotLayer = tf.layers.dot({axes: -1});\nconst x1 = tf.tensor2d([[10, 20], [30, 40]]);\nconst x2 = tf.tensor2d([[-1, -2], [-3, -4]]);\n\n// Invoke the layer's apply() method in eager (imperative) mode.\nconst y = dotLayer.apply([x1, x2]);\ny.print();\n```",
                "fileName": "#849",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L849-L851",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Normalization",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Normalization",
                  "namespace": "layers"
                },
                "symbolName": "batchNormalization",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "BatchNormalizationLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "BatchNormalization",
                "documentation": "Batch normalization layer (Ioffe and Szegedy, 2014).\n\nNormalize the activations of the previous layer at each batch,\ni.e. applies a transformation that maintains the mean activation\nclose to 0 and the activation standard deviation close to 1.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape` (Array of integers, does\n   not include the sample axis) when calling the constructor of this class,\n   if this layer is used as a first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Batch Normalization: Accelerating Deep Network Training by Reducing\nInternal Covariate Shift](https://arxiv.org/abs/1502.03167)",
                "fileName": "#876",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L876-L878",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Normalization",
                  "namespace": "layers"
                },
                "symbolName": "layerNormalization",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerNormalizationLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "LayerNormalization",
                "documentation": "Layer-normalization layer (Ba et al., 2016).\n\nNormalizes the activations of the previous layer for each given example in a\nbatch independently, instead of across a batch like in `batchNormalization`.\nIn other words, this layer applies a transformation that maintains the mean\nactivation within each example close to 0 and activation variance close to 1.\n\nInput shape:\n   Arbitrary. Use the argument `inputShape` when using this layer as the first\n   layer in a model.\n\nOutput shape:\n   Same as input.\n\nReferences:\n   - [Layer Normalization](https://arxiv.org/abs/1607.06450)",
                "fileName": "#900",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L900-L902",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Padding",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Padding",
                  "namespace": "layers"
                },
                "symbolName": "zeroPadding2d",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ZeroPadding2DLayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ZeroPadding2D",
                "documentation": "Zero-padding layer for 2D input (e.g., image).\n\nThis layer can add rows and columns of zeros\nat the top, bottom, left and right side of an image tensor.\n\nInput shape:\n   4D tensor with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, rows, cols, channels]`\n   - If `data_format` is `\"channels_first\"`:\n     `[batch, channels, rows, cols]`.\n\nOutput shape:\n   4D with shape:\n   - If `dataFormat` is `\"channelsLast\"`:\n     `[batch, paddedRows, paddedCols, channels]`\n    - If `dataFormat` is `\"channelsFirst\"`:\n     `[batch, channels, paddedRows, paddedCols]`.",
                "fileName": "#928",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L928-L930",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Pooling",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "averagePooling1d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling1DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "AveragePooling1D",
                "documentation": "Average pooling operation for spatial data.\n\nInput shape: `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`\n\n`tf.avgPool1d` is an alias.",
                "fileName": "#945",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L945-L947",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "averagePooling2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "AveragePooling2D",
                "documentation": "Average pooling operation for spatial data.\n\nInput shape:\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, rows, cols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, rows, cols]`\n\nOutput shape\n  - If `dataFormat === CHANNEL_LAST`:\n      4D tensor with shape:\n      `[batchSize, pooledRows, pooledCols, channels]`\n  - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n      `[batchSize, channels, pooledRows, pooledCols]`\n\n`tf.avgPool2d` is an alias.",
                "fileName": "#980",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L980-L982",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "averagePooling3d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling3DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "AveragePooling3D",
                "documentation": "Average pooling operation for 3D data.\n\nInput shape\n   - If `dataFormat === channelsLast`:\n       5D tensor with shape:\n       `[batchSize, depths, rows, cols, channels]`\n   - If `dataFormat === channelsFirst`:\n      4D tensor with shape:\n       `[batchSize, channels, depths, rows, cols]`\n\nOutput shape\n   - If `dataFormat=channelsLast`:\n       5D tensor with shape:\n       `[batchSize, pooledDepths, pooledRows, pooledCols, channels]`\n   - If `dataFormat=channelsFirst`:\n       5D tensor with shape:\n       `[batchSize, channels, pooledDepths, pooledRows, pooledCols]`",
                "fileName": "#1013",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1013-L1015",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "globalAveragePooling1d",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GlobalAveragePooling1D",
                "documentation": "Global average pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape: 2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#1034",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1034-L1036",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "globalAveragePooling2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GlobalPooling2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GlobalAveragePooling2D",
                "documentation": "Global average pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#1052",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1052-L1054",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "globalMaxPooling1d",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LayerArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GlobalMaxPooling1D",
                "documentation": "Global max pooling operation for temporal data.\n\nInput Shape: 3D tensor with shape: `[batchSize, steps, features]`.\n\nOutput Shape: 2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#1065",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1065-L1067",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "globalMaxPooling2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GlobalPooling2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GlobalMaxPooling2D",
                "documentation": "Global max pooling operation for spatial data.\n\nInput shape:\n   - If `dataFormat` is `CHANNEL_LAST`:\n       4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   - If `dataFormat` is `CHANNEL_FIRST`:\n       4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#1083",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1083-L1085",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "maxPooling1d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling1DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "MaxPooling1D",
                "documentation": "Max pooling operation for temporal data.\n\nInput shape:  `[batchSize, inLength, channels]`\n\nOutput shape: `[batchSize, pooledLength, channels]`",
                "fileName": "#1096",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1096-L1098",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "maxPooling2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling2DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "MaxPooling2D",
                "documentation": "Max pooling operation for spatial data.\n\nInput shape\n   - If `dataFormat === CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, rows, cols, channels]`\n   - If `dataFormat === CHANNEL_FIRST`:\n      4D tensor with shape:\n       `[batchSize, channels, rows, cols]`\n\nOutput shape\n   - If `dataFormat=CHANNEL_LAST`:\n       4D tensor with shape:\n       `[batchSize, pooledRows, pooledCols, channels]`\n   - If `dataFormat=CHANNEL_FIRST`:\n       4D tensor with shape:\n       `[batchSize, channels, pooledRows, pooledCols]`",
                "fileName": "#1121",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1121-L1123",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers"
                },
                "symbolName": "maxPooling3d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "Pooling3DLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "MaxPooling3D",
                "documentation": "Max pooling operation for 3D data.\n\nInput shape\n   - If `dataFormat === channelsLast`:\n       5D tensor with shape:\n       `[batchSize, depths, rows, cols, channels]`\n   - If `dataFormat === channelsFirst`:\n      5D tensor with shape:\n       `[batchSize, channels, depths, rows, cols]`\n\nOutput shape\n   - If `dataFormat=channelsLast`:\n       5D tensor with shape:\n       `[batchSize, pooledDepths, pooledRows, pooledCols, channels]`\n   - If `dataFormat=channelsFirst`:\n       5D tensor with shape:\n       `[batchSize, channels, pooledDepths, pooledRows, pooledCols]`",
                "fileName": "#1146",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1146-L1148",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Recurrent",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "gru",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GRULayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GRU",
                "documentation": "Gated Recurrent Unit - Cho et al. 2014.\n\nThis is an `RNN` layer consisting of one `GRUCell`. However, unlike\nthe underlying `GRUCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.gru({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `GRUCell`'s number of units.",
                "fileName": "#1175",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1175-L1177",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "gruCell",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GRUCellLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GRUCell",
                "documentation": "Cell class for `GRU`.\n\n`GRUCell` is distinct from the `RNN` subclass `GRU` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `GRU` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.gruCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `GRUCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.gruCell({units: 4}),\n   tf.layers.gruCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `gruCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `GRUCell`, use the\n`tf.layers.gru`.",
                "fileName": "#1224",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1224-L1226",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "lstm",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LSTMLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "LSTM",
                "documentation": "Long-Short Term Memory layer - Hochreiter 1997.\n\nThis is an `RNN` layer consisting of one `LSTMCell`. However, unlike\nthe underlying `LSTMCell`, the `apply` method of `LSTM` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst lstm = tf.layers.lstm({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = lstm.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `LSTMCell`'s number of units.",
                "fileName": "#1251",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1251-L1253",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "lstmCell",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "LSTMCellLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "LSTMCell",
                "documentation": "Cell class for `LSTM`.\n\n`LSTMCell` is distinct from the `RNN` subclass `LSTM` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `LSTM` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.lstmCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `LSTMCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.lstmCell({units: 4}),\n   tf.layers.lstmCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `lstmCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `LSTMCell`, use the\n`tf.layers.lstm`.",
                "fileName": "#1300",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1300-L1302",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "simpleRNN",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SimpleRNNLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SimpleRNN",
                "documentation": "Fully-connected RNN where the output is to be fed back to input.\n\nThis is an `RNN` layer consisting of one `SimpleRNNCell`. However, unlike\nthe underlying `SimpleRNNCell`, the `apply` method of `SimpleRNN` operates\non a sequence of inputs. The shape of the input (not including the first,\nbatch dimension) needs to be at least 2-D, with the first dimension being\ntime steps. For example:\n\n```js\nconst rnn = tf.layers.simpleRNN({units: 8, returnSequences: true});\n\n// Create an input with 10 time steps.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the `SimpleRNNCell`'s number of units.\n```",
                "fileName": "#1328",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1328-L1330",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "simpleRNNCell",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "SimpleRNNCellLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SimpleRNNCell",
                "documentation": "Cell class for `SimpleRNN`.\n\n`SimpleRNNCell` is distinct from the `RNN` subclass `SimpleRNN` in that its\n`apply` method takes the input data of only a single time step and returns\nthe cell's output at the time step, while `SimpleRNN` takes the input data\nover a number of time steps. For example:\n\n```js\nconst cell = tf.layers.simpleRNNCell({units: 2});\nconst input = tf.input({shape: [10]});\nconst output = cell.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10]: This is the cell's output at a single time step. The 1st\n// dimension is the unknown batch size.\n```\n\nInstance(s) of `SimpleRNNCell` can be used to construct `RNN` layers. The\nmost typical use of this workflow is to combine a number of cells into a\nstacked RNN cell (i.e., `StackedRNNCell` internally) and use it to create an\nRNN. For example:\n\n```js\nconst cells = [\n   tf.layers.simpleRNNCell({units: 4}),\n   tf.layers.simpleRNNCell({units: 8}),\n];\nconst rnn = tf.layers.rnn({cell: cells, returnSequences: true});\n\n// Create an input with 10 time steps and a length-20 vector at each step.\nconst input = tf.input({shape: [10, 20]});\nconst output = rnn.apply(input);\n\nconsole.log(JSON.stringify(output.shape));\n// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the\n// same as the sequence length of `input`, due to `returnSequences`: `true`;\n// 3rd dimension is the last `SimpleRNNCell`'s number of units.\n```\n\nTo create an `RNN` consisting of only *one* `SimpleRNNCell`, use the\n`tf.layers.simpleRNN`.",
                "fileName": "#1377",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1377-L1379",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "convLstm2d",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLSTM2DArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ConvLSTM2D",
                "documentation": "Convolutional LSTM layer - Xingjian Shi 2015.\n\nThis is a `ConvRNN2D` layer consisting of one `ConvLSTM2DCell`. However,\nunlike the underlying `ConvLSTM2DCell`, the `apply` method of `ConvLSTM2D`\noperates on a sequence of inputs. The shape of the input (not including the\nfirst, batch dimension) needs to be 4-D, with the first dimension being time\nsteps. For example:\n\n```js\nconst filters = 3;\nconst kernelSize = 3;\n\nconst batchSize = 4;\nconst sequenceLength = 2;\nconst size = 5;\nconst channels = 3;\n\nconst inputShape = [batchSize, sequenceLength, size, size, channels];\nconst input = tf.ones(inputShape);\n\nconst layer = tf.layers.convLstm2d({filters, kernelSize});\n\nconst output = layer.apply(input);\n```",
                "fileName": "#1408",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1408-L1410",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "convLstm2dCell",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ConvLSTM2DCellArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "ConvLSTM2DCell",
                "documentation": "Cell class for `ConvLSTM2D`.\n\n`ConvLSTM2DCell` is distinct from the `ConvRNN2D` subclass `ConvLSTM2D` in\nthat its `call` method takes the input data of only a single time step and\nreturns the cell's output at the time step, while `ConvLSTM2D` takes the\ninput data over a number of time steps. For example:\n\n```js\nconst filters = 3;\nconst kernelSize = 3;\n\nconst sequenceLength = 1;\nconst size = 5;\nconst channels = 3;\n\nconst inputShape = [sequenceLength, size, size, channels];\nconst input = tf.ones(inputShape);\n\nconst cell = tf.layers.convLstm2dCell({filters, kernelSize});\n\ncell.build(input.shape);\n\nconst outputSize = size - kernelSize + 1;\nconst outShape = [sequenceLength, outputSize, outputSize, filters];\n\nconst initialH = tf.zeros(outShape);\nconst initialC = tf.zeros(outShape);\n\nconst [o, h, c] = cell.call([input, initialH, initialC], {});\n```",
                "fileName": "#1445",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1445-L1447",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "rnn",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RNNLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "RNN",
                "documentation": "Base class for recurrent layers.\n\nInput shape:\n   3D tensor with shape `[batchSize, timeSteps, inputDim]`.\n\nOutput shape:\n   - if `returnState`, an Array of tensors (i.e., `tf.Tensor`s). The first\n     tensor is the output. The remaining tensors are the states at the\n     last time step, each with shape `[batchSize, units]`.\n   - if `returnSequences`, the output will have shape\n     `[batchSize, timeSteps, units]`.\n   - else, the output will have shape `[batchSize, units]`.\n\nMasking:\n   This layer supports masking for input data with a variable number\n   of timesteps. To introduce masks to your data,\n   use an embedding layer with the `mask_zero` parameter\n   set to `True`.\n\nNotes on using statefulness in RNNs:\n   You can set RNN layers to be 'stateful', which means that the states\n   computed for the samples in one batch will be reused as initial states\n   for the samples in the next batch. This assumes a one-to-one mapping\n   between samples in different successive batches.\n\n   To enable statefulness:\n     - specify `stateful: true` in the layer constructor.\n     - specify a fixed batch size for your model, by passing\n       if sequential model:\n         `batchInputShape=[...]` to the first layer in your model.\n       else for functional model with 1 or more Input layers:\n         `batchShape=[...]` to all the first layers in your model.\n       This is the expected shape of your inputs *including the batch size*.\n       It should be a tuple of integers, e.g. `(32, 10, 100)`.\n     - specify `shuffle=False` when calling fit().\n\n   To reset the states of your model, call `.resetStates()` on either\n   a specific layer, or on your entire model.\n\nNote on specifying the initial state of RNNs\n   You can specify the initial state of RNN layers symbolically by\n   calling them with the option `initialState`. The value of\n   `initialState` should be a tensor or list of tensors representing\n   the initial state of the RNN layer.\n\n   You can specify the initial state of RNN layers numerically by\n   calling `resetStates` with the keyword argument `states`. The value of\n   `states` should be a numpy array or list of numpy arrays representing\n   the initial state of the RNN layer.\n\nNote on passing external constants to RNNs\n   You can pass \"external\" constants to the cell using the `constants`\n   keyword argument of `RNN.call` method. This requires that the `cell.call`\n   method accepts the same keyword argument `constants`. Such constants\n   can be used to condition the cell transformation on additional static\n   inputs (not changing over time), a.k.a. an attention mechanism.",
                "fileName": "#1509",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1509-L1511",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers"
                },
                "symbolName": "stackedRNNCells",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "StackedRNNCellsArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "StackedRNNCells",
                "documentation": "Wrapper allowing a stack of RNN cells to behave as a single cell.\n\nUsed to implement efficient stacked RNNs.",
                "fileName": "#1520",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1520-L1522",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Wrapper",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers"
                },
                "symbolName": "bidirectional",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "BidirectionalLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Bidirectional",
                "documentation": "",
                "fileName": "#1527",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1527-L1529",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers"
                },
                "symbolName": "timeDistributed",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "WrapperLayerArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "TimeDistributed",
                "documentation": "This wrapper applies a layer to every temporal slice of an input.\n\nThe input should be at least 3D,  and the dimension of the index `1` will be\nconsidered to be the temporal dimension.\n\nConsider a batch of 32 samples, where each sample is a sequence of 10 vectors\nof 16 dimensions. The batch input shape of the layer is then `[32,  10,\n16]`, and the `inputShape`, not including the sample dimension, is\n`[10, 16]`.\n\nYou can then use `TimeDistributed` to apply a `Dense` layer to each of the 10\ntimesteps, independently:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.dense({units: 8}),\n   inputShape: [10, 16],\n}));\n\n// Now model.outputShape = [null, 10, 8].\n// The output will then have shape `[32, 10, 8]`.\n\n// In subsequent layers, there is no need for `inputShape`:\nmodel.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: 32})}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n// Now model.outputShape = [null, 10, 32].\n```\n\nThe output will then have shape `[32, 10, 32]`.\n\n`TimeDistributed` can be used with arbitrary layers, not just `Dense`, for\ninstance a `Conv2D` layer.\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.timeDistributed({\n   layer: tf.layers.conv2d({filters: 64, kernelSize: [3, 3]}),\n   inputShape: [10, 299, 299, 3],\n}));\nconsole.log(JSON.stringify(model.outputs[0].shape));\n```",
                "fileName": "#1577",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1577-L1579",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Noise",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Noise",
                  "namespace": "layers"
                },
                "symbolName": "gaussianNoise",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GaussianNoiseArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GaussianNoise",
                "documentation": "Apply additive zero-centered Gaussian noise.\n\nAs it is a regularization layer, it is only active at training time.\n\nThis is useful to mitigate overfitting\n(you could see it as a form of random data augmentation).\nGaussian Noise (GS) is a natural choice as corruption process\nfor real valued inputs.\n\n# Arguments\nstddev: float, standard deviation of the noise distribution.\n\n# Input shape\nArbitrary. Use the keyword argument `input_shape`\n(tuple of integers, does not include the samples axis)\nwhen using this layer as the first layer in a model.\n\n# Output shape\nSame shape as input.",
                "fileName": "#1612",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1612-L1614",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Noise",
                  "namespace": "layers"
                },
                "symbolName": "gaussianDropout",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "GaussianDropoutArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "GaussianDropout",
                "documentation": "Apply multiplicative 1-centered Gaussian noise.\n\nAs it is a regularization layer, it is only active at training time.\n\nArguments:\n   - `rate`: float, drop probability (as with `Dropout`).\n     The multiplicative noise will have\n     standard deviation `sqrt(rate / (1 - rate))`.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting](\n      http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
                "fileName": "#1640",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1640-L1642",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Noise",
                  "namespace": "layers"
                },
                "symbolName": "alphaDropout",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "AlphaDropoutArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "AlphaDropout",
                "documentation": "Applies Alpha Dropout to the input.\n\nAs it is a regularization layer, it is only active at training time.\n\nAlpha Dropout is a `Dropout` that keeps mean and variance of inputs\nto their original values, in order to ensure the self-normalizing property\neven after this dropout.\nAlpha Dropout fits well to Scaled Exponential Linear Units\nby randomly setting activations to the negative saturation value.\n\nArguments:\n   - `rate`: float, drop probability (as with `Dropout`).\n     The multiplicative noise will have\n     standard deviation `sqrt(rate / (1 - rate))`.\n   - `noise_shape`: A 1-D `Tensor` of type `int32`, representing the\n     shape for randomly generated keep/drop flags.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)",
                "fileName": "#1675",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1675-L1677",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Mask",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Mask",
                  "namespace": "layers"
                },
                "symbolName": "masking",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "MaskingArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Masking",
                "documentation": "Masks a sequence by using a mask value to skip timesteps.\n\nIf all features for a given sample timestep are equal to `mask_value`,\nthen the sample timestep will be masked (skipped) in all downstream layers\n(as long as they support masking).\n\nIf any downstream layer does not support masking yet receives such\nan input mask, an exception will be raised.\n\nArguments:\n   - `maskValue`: Either None or mask value to skip.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape`\n   (tuple of integers, does not include the samples axis)\n   when using this layer as the first layer in a model.\n\nOutput shape:\n   Same shape as input.",
                "fileName": "#1702",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1702-L1704",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Rescaling",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Rescaling",
                  "namespace": "layers"
                },
                "symbolName": "rescaling",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RescalingArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Rescaling",
                "documentation": "A preprocessing layer which rescales input values to a new range.\n\nThis layer rescales every value of an input (often an image) by multiplying\nby `scale` and adding `offset`.\n\nFor instance:\n1. To rescale an input in the ``[0, 255]`` range\nto be in the `[0, 1]` range, you would pass `scale=1/255`.\n2. To rescale an input in the ``[0, 255]`` range to be in the `[-1, 1]`\nrange, you would pass `scale=1./127.5, offset=-1`.\nThe rescaling is applied both during training and inference. Inputs can be\nof integer or floating point dtype, and by default the layer will output\nfloats.\n\nArguments:\n   - `scale`: Float, the scale to apply to the inputs.\n   - `offset`: Float, the offset to apply to the inputs.\n\nInput shape:\n   Arbitrary.\n\nOutput shape:\n   Same as input.",
                "fileName": "#1733",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1733-L1735",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "CenterCrop",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "CenterCrop",
                  "namespace": "layers"
                },
                "symbolName": "centerCrop",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "CenterCropArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "CenterCrop",
                "documentation": "A preprocessing layer which center crops images.\n\n  This layers crops the central portion of the images to a target size. If an\n  image is smaller than the target size, it will be resized and cropped so as\n  to return the largest possible window in the image that matches the target\n  aspect ratio.\n\n  Input pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\n  of integer or floating point dtype.\n\n  If the input height/width is even and the target height/width is odd (or\n  inversely), the input image is left-padded by 1 pixel.\n\n  Arguments:\n    `height`: Integer, the height of the output shape.\n    `width`: Integer, the width of the output shape.\n\n  Input shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `channelsLast` format.\n\n  Output shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., targetHeight, targetWidth, channels)`.",
                "fileName": "#1766",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1766-L1768",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "Resizing",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Resizing",
                  "namespace": "layers"
                },
                "symbolName": "resizing",
                "namespace": "layers",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "ResizingArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Resizing",
                "documentation": "A preprocessing layer which resizes images.\nThis layer resizes an image input to a target height and width. The input\nshould be a 4D (batched) or 3D (unbatched) tensor in `\"channels_last\"`\nformat.  Input pixel values can be of any range (e.g. `[0., 1.)` or `[0,\n255]`) and of interger or floating point dtype. By default, the layer will\noutput floats.\n\nArguments:\n   - `height`: number, the height for the output tensor.\n   - `width`: number, the width for the output tensor.\n   - `interpolation`: string, the method for image resizing interpolation.\n   - `cropToAspectRatio`: boolean, whether to keep image aspect ratio.\n\nInput shape:\n   Arbitrary.\n\nOutput shape:\n   height, width, num channels.",
                "fileName": "#1792",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1792-L1794",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "CategoryEncoding",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "CategoryEncoding",
                  "namespace": "layers"
                },
                "symbolName": "categoryEncoding",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "CategoryEncodingArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "CategoryEncoding",
                "documentation": "A preprocessing layer which encodes integer features.\n\nThis layer provides options for condensing data into a categorical encoding\nwhen the total number of tokens are known in advance. It accepts integer\nvalues as inputs, and it outputs a dense representation of those\ninputs.\n\nArguments:\n\nnumTokens: The total number of tokens the layer should support. All\n  inputs to the layer must integers in the range `0 <= value <\n  numTokens`, or an error will be thrown.\n\noutputMode: Specification for the output of the layer.\n  Defaults to `multiHot`. Values can be `oneHot`, `multiHot` or\n  `count`, configuring the layer as follows:\n\n    oneHot: Encodes each individual element in the input into an\n      array of `numTokens` size, containing a 1 at the element index. If\n      the last dimension is size 1, will encode on that dimension. If the\n      last dimension is not size 1, will append a new dimension for the\n      encoded output.\n\n    multiHot: Encodes each sample in the input into a single array\n     of `numTokens` size, containing a 1 for each vocabulary term\n     present in the sample. Treats the last dimension as the sample\n     dimension, if input shape is `(..., sampleLength)`, output shape\n     will be `(..., numTokens)`.\n\n    count: Like `multiHot`, but the int array contains a count of\n     the number of times the token at that index appeared in the sample.\n\n  For all output modes, currently only output up to rank 2 is supported.\n   Call arguments:\n    inputs: A 1D or 2D tensor of integer inputs.\n    countWeights: A tensor in the same shape as `inputs` indicating the\n    weight for each sample value when summing up in `count` mode. Not used\n    in `multiHot` or `oneHot` modes.",
                "fileName": "#1839",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1839-L1841",
                "tags": [],
                "isFunction": true
              }
            ]
          },
          {
            "name": "RandomWidth",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "RandomWidth",
                  "namespace": "layers"
                },
                "symbolName": "randomWidth",
                "namespace": "layers",
                "paramStr": "(args)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "RandomWidthArgs",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "RandomWidth",
                "documentation": "A preprocessing layer which randomly varies image width during training.\n\nThis layer will randomly adjusts the width of a batch of images of a batch\nof images by a random factor.\n\nThe input should be a 3D (unbatched) or 4D (batched) tensor in\nthe `\"channels_last\"` image data format. Input pixel values can be of any\nrange (e.g. `[0., 1.)` or `[0, 255]`) and of integer or floating point\ndtype. By default, the layer will output floats. By default, this layer is\ninactive during inference. For an overview and full list of preprocessing\nlayers, see the preprocessing [guide]\n(https://www.tensorflow.org/guide/keras/preprocessing_layers).\n\nArguments:\n\nfactor:\n   A positive float (fraction of original width), or a tuple of size 2\n   representing lower and upper bound for resizing vertically.\n   When represented as a single float, this value is used for both the upper\n   and lower bound. For instance, `factor=(0.2, 0.3)` results in an output\n   with width changed by a random amount in the range `[20%, 30%]`.\n   `factor=(-0.2, 0.3)` results in an output with width changed by a random\n   amount in the range `[-20%, +30%]`. `factor=0.2` results in an output\n   with width changed by a random amount in the range `[-20%, +20%]`.\ninterpolation:\n   String, the interpolation method.\n   Defaults to `bilinear`.\n   Supports `\"bilinear\"`, `\"nearest\"`.\n   The tf methods `\"bicubic\"`, `\"area\"`, `\"lanczos3\"`, `\"lanczos5\"`,\n   `\"gaussian\"`, `\"mitchellcubic\"` are unimplemented in tfjs.\nseed:\n   Integer. Used to create a random seed.\n\nInput shape:\n     3D (unbatched) or 4D (batched) tensor with shape:\n     `(..., height, width, channels)`, in `\"channels_last\"` format.\nOutput shape:\n     3D (unbatched) or 4D (batched) tensor with shape:\n     `(..., height, random_width, channels)`.",
                "fileName": "#1887",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_layers.ts#L1887-L1889",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Metrics",
        "description": "",
        "subheadings": [
          {
            "symbols": [
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "binaryAccuracy",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Binary Tensor of truth.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Binary Tensor of prediction.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Binary accuracy metric function.\n\n`yTrue` and `yPred` can have 0-1 values. Example:\n```js\nconst x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\nconst y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\nconst accuracy = tf.metrics.binaryAccuracy(x, y);\naccuracy.print();\n```\n\n`yTrue` and `yPred` can also have floating-number values between 0 and 1, in\nwhich case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\na value >= 0.5 and <= 1.0 is interpreted as 1).\n\nExample:\n```js\nconst x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\nconst y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\nconst accuracy = tf.metrics.binaryAccuracy(x, y);\naccuracy.print();\n```",
                "fileName": "#44",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L44-L46",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "binaryCrossentropy",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Binary Tensor of truth.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Binary Tensor of prediction, probabilities for the `1` case.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Binary crossentropy metric function.\n\nExample:\n```js\nconst x = tf.tensor2d([[0], [1], [1], [1]]);\nconst y = tf.tensor2d([[0], [0], [0.5], [1]]);\nconst crossentropy = tf.metrics.binaryCrossentropy(x, y);\ncrossentropy.print();\n```",
                "fileName": "#65",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L65-L67",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "sparseCategoricalAccuracy",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "True labels: indices.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Predicted probabilities or logits.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Sparse categorical accuracy metric function.\n\nExample:\n```js\n\nconst yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\nconst yPred = tf.tensor2d(\n      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\nconst crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\ncrossentropy.print();\n```",
                "fileName": "#88",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L88-L91",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "categoricalAccuracy",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Binary Tensor of truth: one-hot encoding of categories.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Binary Tensor of prediction: probabilities or logits for the\nsame categories as in `yTrue`.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Categorical accuracy metric function.\n\nExample:\n```js\nconst x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\nconst y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\nconst accuracy = tf.metrics.categoricalAccuracy(x, y);\naccuracy.print();\n```",
                "fileName": "#111",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L111-L113",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "categoricalCrossentropy",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Categorical crossentropy between an output tensor and a target tensor.",
                "fileName": "#126",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L126-L128",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "precision",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "The ground truth values. Expected to contain only 0-1 values.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "The predicted values. Expected to contain only 0-1 values.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Computes the precision of the predictions with respect to the labels.\n\nExample:\n```js\nconst x = tf.tensor2d(\n    [\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 0, 1, 0]\n    ]\n);\n\nconst y = tf.tensor2d(\n    [\n      [0, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0]\n    ]\n);\n\nconst precision = tf.metrics.precision(x, y);\nprecision.print();\n```",
                "fileName": "#165",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L165-L167",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "recall",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "The ground truth values. Expected to contain only 0-1 values.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "The predicted values. Expected to contain only 0-1 values.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Computes the recall of the predictions with respect to the labels.\n\nExample:\n```js\nconst x = tf.tensor2d(\n    [\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 0, 1, 0]\n    ]\n);\n\nconst y = tf.tensor2d(\n    [\n      [0, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0]\n    ]\n);\n\nconst recall = tf.metrics.recall(x, y);\nrecall.print();\n```",
                "fileName": "#204",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L204-L206",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "cosineProximity",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Truth Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Prediction Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Loss or metric function: Cosine proximity.\n\nMathematically, cosine proximity is defined as:\n   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\nwherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\nrepresents element-wise multiplication.\n\n```js\nconst yTrue = tf.tensor2d([[1, 0], [1, 0]]);\nconst yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\nconst proximity = tf.metrics.cosineProximity(yTrue, yPred);\nproximity.print();\n```",
                "fileName": "#229",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L229-L231",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "meanAbsoluteError",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Truth Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Prediction Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Loss or metric function: Mean absolute error.\n\nMathematically, mean absolute error is defined as:\n   `mean(abs(yPred - yTrue))`,\nwherein the `mean` is applied over feature dimensions.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\nconst yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\nconst mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\nmse.print();\n```",
                "fileName": "#253",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L253-L255",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "meanAbsolutePercentageError",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Truth Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Prediction Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Loss or metric function: Mean absolute percentage error.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [10, 20]]);\nconst yPred = tf.tensor2d([[0, 1], [11, 24]]);\nconst mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\nmse.print();\n```\n\nAliases: `tf.metrics.MAPE`, `tf.metrics.mape`.",
                "fileName": "#275",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L275-L278",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Metrics",
                  "namespace": "metrics"
                },
                "symbolName": "meanSquaredError",
                "namespace": "metrics",
                "paramStr": "(yTrue, yPred)",
                "parameters": [
                  {
                    "name": "yTrue",
                    "documentation": "Truth Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  },
                  {
                    "name": "yPred",
                    "documentation": "Prediction Tensor.",
                    "type": "Tensor",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Tensor",
                "documentation": "Loss or metric function: Mean squared error.\n\n```js\nconst yTrue = tf.tensor2d([[0, 1], [3, 4]]);\nconst yPred = tf.tensor2d([[0, 1], [-3, -4]]);\nconst mse = tf.metrics.meanSquaredError(yTrue, yPred);\nmse.print();\n```\n\nAliases: `tf.metrics.MSE`, `tf.metrics.mse`.",
                "fileName": "#306",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_metrics.ts#L306-L308",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Regularizers",
        "description": "",
        "subheadings": [
          {
            "symbols": [
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers"
                },
                "symbolName": "l1l2",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L1L2Args",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Regularizer",
                "documentation": "Regularizer for L1 and L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x)) + sum(l2 * x^2)",
                "fileName": "#22",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L22-L24",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers"
                },
                "symbolName": "l1",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L1Args",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Regularizer",
                "documentation": "Regularizer for L1 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l1 * abs(x))",
                "fileName": "#35",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L35-L37",
                "tags": [],
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Regularizers",
                  "namespace": "regularizers"
                },
                "symbolName": "l2",
                "namespace": "regularizers",
                "paramStr": "(config?)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "L2Args",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Regularizer",
                "documentation": "Regularizer for L2 regularization.\n\nAdds a term to the loss to penalize large weights:\nloss += sum(l2 * x^2)",
                "fileName": "#48",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/exports_regularizers.ts#L48-L50",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Callbacks",
        "description": "",
        "subheadings": [
          {
            "symbols": [
              {
                "docInfo": {
                  "heading": "Callbacks",
                  "namespace": "callbacks"
                },
                "symbolName": "earlyStopping",
                "namespace": "callbacks",
                "paramStr": "(args?)",
                "parameters": [
                  {
                    "name": "args",
                    "documentation": "",
                    "type": "EarlyStoppingCallbackArgs",
                    "optional": true,
                    "isConfigParam": false
                  }
                ],
                "returnType": "EarlyStopping",
                "documentation": "Factory function for a Callback that stops training when a monitored\nquantity has stopped improving.\n\nEarly stopping is a type of regularization, and protects model against\noverfitting.\n\nThe following example based on fake data illustrates how this callback\ncan be used during `tf.LayersModel.fit()`:\n\n```js\nconst model = tf.sequential();\nmodel.add(tf.layers.dense({\n   units: 3,\n   activation: 'softmax',\n   kernelInitializer: 'ones',\n   inputShape: [2]\n}));\nconst xs = tf.tensor2d([1, 2, 3, 4], [2, 2]);\nconst ys = tf.tensor2d([[1, 0, 0], [0, 1, 0]], [2, 3]);\nconst xsVal = tf.tensor2d([4, 3, 2, 1], [2, 2]);\nconst ysVal = tf.tensor2d([[0, 0, 1], [0, 1, 0]], [2, 3]);\nmodel.compile(\n     {loss: 'categoricalCrossentropy', optimizer: 'sgd', metrics: ['acc']});\n\n// Without the EarlyStopping callback, the val_acc value would be:\n//   0.5, 0.5, 0.5, 0.5, ...\n// With val_acc being monitored, training should stop after the 2nd epoch.\nconst history = await model.fit(xs, ys, {\n   epochs: 10,\n   validationData: [xsVal, ysVal],\n   callbacks: tf.callbacks.earlyStopping({monitor: 'val_acc'})\n});\n\n// Expect to see a length-2 array.\nconsole.log(history.history.val_acc);\n```",
                "fileName": "#251",
                "githubUrl": "https://github.com/tensorflow/tfjs/tree/tfjs-v4.7.0/tfjs-layers/src/callbacks.ts#L251-L253",
                "tags": [],
                "isFunction": true
              }
            ]
          }
        ]
      }
    ]
  },
  "docLinkAliases": {},
  "configInterfaceParamMap": {
    "NamedTensor": [
      {
        "name": "name",
        "type": "string",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "tensor",
        "type": "Tensor",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "MaxNormArgs": [
      {
        "name": "maxValue",
        "type": "number",
        "documentation": "Maximum norm for incoming weights",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "axis",
        "type": "number",
        "documentation": "Axis along which to calculate norms.\n\n  For instance, in a `Dense` layer the weight matrix\n  has shape `[inputDim, outputDim]`,\n  set `axis` to `0` to constrain each weight vector\n  of length `[inputDim,]`.\n  In a `Conv2D` layer with `dataFormat=\"channels_last\"`,\n  the weight tensor has shape\n  `[rows, cols, inputDepth, outputDepth]`,\n  set `axis` to `[0, 1, 2]`\n  to constrain the weights of each filter tensor of size\n  `[rows, cols, inputDepth]`.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "UnitNormArgs": [
      {
        "name": "axis",
        "type": "number",
        "documentation": "Axis along which to calculate norms.\n\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "MinMaxNormArgs": [
      {
        "name": "minValue",
        "type": "number",
        "documentation": "Minimum norm for incoming weights",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "maxValue",
        "type": "number",
        "documentation": "Maximum norm for incoming weights",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "axis",
        "type": "number",
        "documentation": "Axis along which to calculate norms.\nFor instance, in a `Dense` layer the weight matrix\nhas shape `[inputDim, outputDim]`,\nset `axis` to `0` to constrain each weight vector\nof length `[inputDim,]`.\nIn a `Conv2D` layer with `dataFormat=\"channels_last\"`,\nthe weight tensor has shape\n`[rows, cols, inputDepth, outputDepth]`,\nset `axis` to `[0, 1, 2]`\nto constrain the weights of each filter tensor of size\n`[rows, cols, inputDepth]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "rate",
        "type": "number",
        "documentation": "Rate for enforcing the constraint: weights will be rescaled to yield:\n`(1 - rate) * norm + rate * norm.clip(minValue, maxValue)`.\nEffectively, this means that rate=1.0 stands for strict\nenforcement of the constraint, while rate<1.0 means that\nweights will be rescaled at each step to slowly move\ntowards a value inside the desired interval.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "PyJsonDict": [],
    "PyJsonArray": [
      {
        "name": "length",
        "type": "number",
        "documentation": "Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "toString",
        "type": "string",
        "documentation": "Returns a string representation of an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "toLocaleString",
        "type": "string",
        "documentation": "Returns a string representation of an array. The elements are converted to string using their toLocalString methods.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "pop",
        "type": "T | undefined",
        "documentation": "Removes the last element from an array and returns it.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "push",
        "type": "number",
        "documentation": "Appends new elements to an array, and returns the new length of the array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "concat",
        "type": "T[]",
        "documentation": "Combines two or more arrays.\nCombines two or more arrays.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "join",
        "type": "string",
        "documentation": "Adds all the elements of an array separated by the specified separator string.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "reverse",
        "type": "T[]",
        "documentation": "Reverses the elements in an Array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "shift",
        "type": "T | undefined",
        "documentation": "Removes the first element from an array and returns it.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "slice",
        "type": "T[]",
        "documentation": "Returns a section of an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sort",
        "type": "this",
        "documentation": "Sorts an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "splice",
        "type": "T[]",
        "documentation": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\nRemoves elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unshift",
        "type": "number",
        "documentation": "Inserts new elements at the start of an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "indexOf",
        "type": "number",
        "documentation": "Returns the index of the first occurrence of a value in an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "lastIndexOf",
        "type": "number",
        "documentation": "Returns the index of the last occurrence of a specified value in an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "every",
        "type": "boolean",
        "documentation": "Determines whether all the members of an array satisfy the specified test.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "some",
        "type": "boolean",
        "documentation": "Determines whether the specified callback function returns true for any element of an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "forEach",
        "type": "void",
        "documentation": "Performs the specified action for each element in an array.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "map",
        "type": "U[]",
        "documentation": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "filter",
        "type": "S[]",
        "documentation": "Returns the elements of an array that meet the condition specified in a callback function.\nReturns the elements of an array that meet the condition specified in a callback function.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "reduce",
        "type": "T",
        "documentation": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\nCalls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "reduceRight",
        "type": "T",
        "documentation": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\nCalls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BaseSerialization": [
      {
        "name": "class_name",
        "type": "N",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "config",
        "type": "T",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConstantArgs": [
      {
        "name": "value",
        "type": "number",
        "documentation": "The value for each element in the variable.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RandomUniformArgs": [
      {
        "name": "minval",
        "type": "number",
        "documentation": "Lower bound of the range of random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "maxval",
        "type": "number",
        "documentation": "Upper bound of the range of random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "Used to seed the random generator.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RandomNormalArgs": [
      {
        "name": "mean",
        "type": "number",
        "documentation": "Mean of the random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stddev",
        "type": "number",
        "documentation": "Standard deviation of the random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "Used to seed the random generator.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "TruncatedNormalArgs": [
      {
        "name": "mean",
        "type": "number",
        "documentation": "Mean of the random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stddev",
        "type": "number",
        "documentation": "Standard deviation of the random values to generate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "Used to seed the random generator.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "IdentityArgs": [
      {
        "name": "gain",
        "type": "number",
        "documentation": "Multiplicative factor to apply to the identity matrix.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "VarianceScalingArgs": [
      {
        "name": "scale",
        "type": "number",
        "documentation": "Scaling factor (positive float).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "mode",
        "type": "FanMode",
        "documentation": "Fanning mode for inputs and outputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "distribution",
        "type": "Distribution",
        "documentation": "Probabilistic distribution of the values.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "Random number generator seed.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SeedOnlyInitializerArgs": [
      {
        "name": "seed",
        "type": "number",
        "documentation": "Random number generator seed.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "OrthogonalArgs": [
      {
        "name": "gain",
        "type": "number",
        "documentation": "Multiplicative factor to apply to the orthogonal matrix. Defaults to 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "Random number generator seed.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "L1L2Args": [
      {
        "name": "l1",
        "type": "number",
        "documentation": "L1 regularization rate. Defaults to 0.01.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "l2",
        "type": "number",
        "documentation": "L2 regularization rate. Defaults to 0.01.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "L1Args": [
      {
        "name": "l1",
        "type": "number",
        "documentation": "L1 regularization rate. Defaults to 0.01.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "L2Args": [
      {
        "name": "l2",
        "type": "number",
        "documentation": "L2 regularization rate. Defaults to 0.01.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "InputSpecArgs": [
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "Expected datatype of the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "shape",
        "type": "Shape",
        "documentation": "Expected shape of the input (may include null for unchecked axes).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "ndim",
        "type": "number",
        "documentation": "Expected rank of the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "maxNDim",
        "type": "number",
        "documentation": "Maximum rank of the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "minNDim",
        "type": "number",
        "documentation": "Minimum rank of the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "axes",
        "type": "{[axis: number]: number}",
        "documentation": "Dictionary mapping integer axes to a specific dimension value.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "NodeArgs": [],
    "DisposeResult": [
      {
        "name": "refCountAfterDispose",
        "type": "number",
        "documentation": "Reference count after the dispose call.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "numDisposedVariables",
        "type": "number",
        "documentation": "Number of variables dispose in this dispose call.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LayerArgs": [
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "InputLayerArgs": [
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "Input shape, not including the batch axis.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "Optional input batch size (integer or null).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "Batch input shape, including the batch axis.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "Datatype of the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sparse",
        "type": "boolean",
        "documentation": "Whether the placeholder created is meant to be sparse.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name of the layer.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "InputConfig": [
      {
        "name": "shape",
        "type": "Shape",
        "documentation": "A shape, not including the batch size. For instance, `shape=[32]`\nindicates that the expected input will be batches of 32-dimensional\nvectors.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchShape",
        "type": "Shape",
        "documentation": "A shape tuple (integer), including the batch size. For instance,\n`batchShape=[10, 32]` indicates that the expected input will be batches of\n10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\narbitrary number of 32-dimensional vectors.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "An optional name string for the layer. Should be unique in a model (do not\nreuse the same name twice). It will be autogenerated if it isn't provided.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sparse",
        "type": "boolean",
        "documentation": "A boolean specifying whether the placeholder to be created is sparse.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "Feed": [
      {
        "name": "key",
        "type": "SymbolicTensor",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "value",
        "type": "Tensor",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ExecutionProbe": [
      {
        "name": "maxNumTensors",
        "type": "number",
        "documentation": "Maximum number of tensors that exist during all steps of the\nexecution. Tensor counts are measured at the beginning of every\nstep.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "minNumTensors",
        "type": "number",
        "documentation": "Minimum number of tensors that exist during all steps of the\nexecution. Tensor counts are measured at the beginning of every\nstep.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ContainerArgs": [
      {
        "name": "inputs",
        "type": "SymbolicTensor|SymbolicTensor[]",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "outputs",
        "type": "SymbolicTensor|SymbolicTensor[]",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "CustomCallbackArgs": [
      {
        "name": "onTrainBegin",
        "type": "(logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onTrainEnd",
        "type": "(logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onEpochBegin",
        "type": "(epoch: number, logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onEpochEnd",
        "type": "(epoch: number, logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onBatchBegin",
        "type": "(batch: number, logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onBatchEnd",
        "type": "(batch: number, logs?: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "onYield",
        "type": "(epoch: number, batch: number, logs: Logs) => void | Promise<void>",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "nowFunc",
        "type": "Function",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "nextFrameFunc",
        "type": "Function",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "TrainingConfig": [
      {
        "name": "optimizer_config",
        "type": "OptimizerSerialization",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "loss",
        "type": "LossIdentifier|LossIdentifier[]|{[key: string]: LossIdentifier}",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "metrics",
        "type": "MetricsIdentifier[]|{[key: string]: MetricsIdentifier}",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weighted_metrics",
        "type": "MetricsIdentifier[]",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sample_weight_mode",
        "type": "SampleWeightMode",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "loss_weights",
        "type": "LossWeights",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelFitDatasetArgs": [
      {
        "name": "batchesPerEpoch",
        "type": "number",
        "documentation": "(Optional) Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. It should\ntypically be equal to the number of samples of your dataset divided by\nthe batch size, so that `fitDataset`() call can utilize the entire dataset.\nIf it is not provided, use `done` return value in `iterator.next()` as\nsignal to finish an epoch.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "epochs",
        "type": "number",
        "documentation": "Integer number of times to iterate over the training dataset.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "ModelLoggingVerbosity",
        "documentation": "Verbosity level.\n\nExpected to be 0, 1, or 2. Default: 1.\n\n0 - No printed message during fit() call.\n1 - In Node.js (tfjs-node), prints the progress bar, together with\n     real-time updates of loss and metric values and training speed.\n     In the browser: no action. This is the default.\n2 - Not implemented yet.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "callbacks",
        "type": "BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]",
        "documentation": "List of callbacks to be called during training.\nCan have one or more of the following callbacks:\n   - `onTrainBegin(logs)`: called when training starts.\n   - `onTrainEnd(logs)`: called when training ends.\n   - `onEpochBegin(epoch, logs)`: called at the start of every epoch.\n   - `onEpochEnd(epoch, logs)`: called at the end of every epoch.\n   - `onBatchBegin(batch, logs)`: called at the start of every batch.\n   - `onBatchEnd(batch, logs)`: called at the end of every batch.\n   - `onYield(epoch, batch, logs)`: called every `yieldEvery` milliseconds\n      with the current epoch, batch and logs. The logs are the same\n      as in `onBatchEnd()`. Note that `onYield` can skip batches or\n      epochs. See also docs for `yieldEvery` below.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationData",
        "type": "[\n    TensorOrArrayOrMap, TensorOrArrayOrMap\n  ]|[TensorOrArrayOrMap, TensorOrArrayOrMap, TensorOrArrayOrMap]|Dataset",
        "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be any of the following:\n\n   - An array `[xVal, yVal]`, where the two values may be `tf.Tensor`,\n     an array of Tensors, or a map of string to Tensor.\n   - Similarly, an array ` [xVal, yVal, valSampleWeights]`\n     (not implemented yet).\n   - a `Dataset` object with elements of the form `{xs: xVal, ys: yVal}`,\n     where `xs` and `ys` are the feature and label tensors, respectively.\n\nIf `validationData` is an Array of Tensor objects, each `tf.Tensor` will be\nsliced into batches during validation, using the parameter\n`validationBatchSize` (which defaults to 32). The entirety of the\n`tf.Tensor` objects will be used in the validation.\n\nIf `validationData` is a dataset object, and the `validationBatches`\nparameter is specified, the validation will use `validationBatches` batches\ndrawn from the dataset object. If `validationBatches` parameter is not\nspecified, the validation will stop when the dataset is exhausted.\n\nThe model will not be trained on this data.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationBatchSize",
        "type": "number",
        "documentation": "Optional batch size for validation.\n\nUsed only if `validationData` is an array of `tf.Tensor` objects, i.e., not\na dataset object.\n\nIf not specified, its value defaults to 32.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationBatches",
        "type": "number",
        "documentation": "(Optional) Only relevant if `validationData` is specified and is a dataset\nobject.\n\nTotal number of batches of samples to draw from `validationData` for\nvalidation purpose before stopping at the end of every epoch. If not\nspecified, `evaluateDataset` will use `iterator.next().done` as signal to\nstop validation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "yieldEvery",
        "type": "YieldEveryOptions",
        "documentation": "Configures the frequency of yielding the main thread to other tasks.\n\nIn the browser environment, yielding the main thread can improve the\nresponsiveness of the page during training. In the Node.js environment,\nit can ensure tasks queued in the event loop can be handled in a timely\nmanner.\n\nThe value can be one of the following:\n   - `'auto'`: The yielding happens at a certain frame rate (currently set\n               at 125ms). This is the default.\n   - `'batch'`: yield every batch.\n   - `'epoch'`: yield every epoch.\n   - a `number`: Will yield every `number` milliseconds.\n   - `'never'`: never yield. (But yielding can still happen through `await\n      nextFrame()` calls in custom callbacks.)",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "initialEpoch",
        "type": "number",
        "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun). When this is used, `epochs` is the index of the \"final epoch\".\nThe model is not trained for a number of iterations given by `epochs`,\nbut merely until the epoch of index `epochs` is reached.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "classWeight",
        "type": "ClassWeight|ClassWeight[]|ClassWeightMap",
        "documentation": "Optional object mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.\n\nIf the model has multiple outputs, a class weight can be specified for\neach of the outputs by setting this field an array of weight object\nor an object that maps model output names (e.g., `model.outputNames[0]`)\nto weight objects.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "FitDatasetElement": [
      {
        "name": "xs",
        "type": "TensorOrArrayOrMap",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "ys",
        "type": "TensorOrArrayOrMap",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelEvaluateDatasetArgs": [
      {
        "name": "batches",
        "type": "number",
        "documentation": "Number of batches to draw from the dataset object before ending the\nevaluation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "ModelLoggingVerbosity",
        "documentation": "Verbosity mode.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelFitArgs": [
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "Number of samples per gradient update. If unspecified, it\nwill default to 32.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "epochs",
        "type": "number",
        "documentation": "Integer number of times to iterate over the training data arrays.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "ModelLoggingVerbosity",
        "documentation": "Verbosity level.\n\nExpected to be 0, 1, or 2. Default: 1.\n\n0 - No printed message during fit() call.\n1 - In Node.js (tfjs-node), prints the progress bar, together with\n     real-time updates of loss and metric values and training speed.\n     In the browser: no action. This is the default.\n2 - Not implemented yet.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "callbacks",
        "type": "BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]",
        "documentation": "List of callbacks to be called during training.\nCan have one or more of the following callbacks:\n   - `onTrainBegin(logs)`: called when training starts.\n   - `onTrainEnd(logs)`: called when training ends.\n   - `onEpochBegin(epoch, logs)`: called at the start of every epoch.\n   - `onEpochEnd(epoch, logs)`: called at the end of every epoch.\n   - `onBatchBegin(batch, logs)`: called at the start of every batch.\n   - `onBatchEnd(batch, logs)`: called at the end of every batch.\n   - `onYield(epoch, batch, logs)`: called every `yieldEvery` milliseconds\n      with the current epoch, batch and logs. The logs are the same\n      as in `onBatchEnd()`. Note that `onYield` can skip batches or\n      epochs. See also docs for `yieldEvery` below.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationSplit",
        "type": "number",
        "documentation": "Float between 0 and 1: fraction of the training data\nto be used as validation data. The model will set apart this fraction of\nthe training data, will not train on it, and will evaluate the loss and\nany model metrics on this data at the end of each epoch.\nThe validation data is selected from the last samples in the `x` and `y`\ndata provided, before shuffling.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationData",
        "type": "[\n    Tensor|Tensor[], Tensor|Tensor[]\n  ]|[Tensor | Tensor[], Tensor|Tensor[], Tensor|Tensor[]]",
        "documentation": "Data on which to evaluate the loss and any model\nmetrics at the end of each epoch. The model will not be trained on this\ndata. This could be a tuple [xVal, yVal] or a tuple [xVal, yVal,\nvalSampleWeights]. The model will not be trained on this data.\n`validationData` will override `validationSplit`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "shuffle",
        "type": "boolean",
        "documentation": "Whether to shuffle the training data before each epoch. Has\nno effect when `stepsPerEpoch` is not `null`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "classWeight",
        "type": "ClassWeight|ClassWeight[]|ClassWeightMap",
        "documentation": "Optional object mapping class indices (integers) to\na weight (float) to apply to the model's loss for the samples from this\nclass during training. This can be useful to tell the model to \"pay more\nattention\" to samples from an under-represented class.\n\nIf the model has multiple outputs, a class weight can be specified for\neach of the outputs by setting this field an array of weight object\nor an object that maps model output names (e.g., `model.outputNames[0]`)\nto weight objects.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sampleWeight",
        "type": "Tensor",
        "documentation": "Optional array of the same length as x, containing\nweights to apply to the model's loss for each sample. In the case of\ntemporal data, you can pass a 2D array with shape (samples,\nsequenceLength), to apply a different weight to every timestep of every\nsample. In this case you should make sure to specify\nsampleWeightMode=\"temporal\" in compile().",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "initialEpoch",
        "type": "number",
        "documentation": "Epoch at which to start training (useful for resuming a previous training\nrun). When this is used, `epochs` is the index of the \"final epoch\".\nThe model is not trained for a number of iterations given by `epochs`,\nbut merely until the epoch of index `epochs` is reached.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stepsPerEpoch",
        "type": "number",
        "documentation": "Total number of steps (batches of samples) before\ndeclaring one epoch finished and starting the next epoch. When training\nwith Input Tensors such as TensorFlow data tensors, the default `null` is\nequal to the number of unique samples in your dataset divided by the\nbatch size, or 1 if that cannot be determined.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "validationSteps",
        "type": "number",
        "documentation": "Only relevant if `stepsPerEpoch` is specified. Total number of steps\n(batches of samples) to validate before stopping.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "yieldEvery",
        "type": "YieldEveryOptions",
        "documentation": "Configures the frequency of yielding the main thread to other tasks.\n\nIn the browser environment, yielding the main thread can improve the\nresponsiveness of the page during training. In the Node.js environment,\nit can ensure tasks queued in the event loop can be handled in a timely\nmanner.\n\nThe value can be one of the following:\n   - `'auto'`: The yielding happens at a certain frame rate (currently set\n               at 125ms). This is the default.\n   - `'batch'`: yield every batch.\n   - `'epoch'`: yield every epoch.\n   - any `number`: yield every `number` milliseconds.\n   - `'never'`: never yield. (yielding can still happen through `await\n      nextFrame()` calls in custom callbacks.)",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelEvaluateArgs": [
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "Batch size (Integer). If unspecified, it will default to 32.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "ModelLoggingVerbosity",
        "documentation": "Verbosity mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sampleWeight",
        "type": "Tensor",
        "documentation": "Tensor of weights to weight the contribution of different samples to the\nloss and metrics.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "steps",
        "type": "number",
        "documentation": "integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelCompileArgs": [
      {
        "name": "optimizer",
        "type": "string|Optimizer",
        "documentation": "An instance of `tf.train.Optimizer` or a string name for an Optimizer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "loss",
        "type": "string|string[]|{[outputName: string]: string}|LossOrMetricFn|\n      LossOrMetricFn[]|{[outputName: string]: LossOrMetricFn}",
        "documentation": "Object function(s) or name(s) of object function(s).\nIf the model has multiple outputs, you can use a different loss\non each output by passing a dictionary or an Array of losses.\nThe loss value that will be minimized by the model will then be the sum\nof all individual losses.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "metrics",
        "type": "string|LossOrMetricFn|Array|\n      {[outputName: string]: string | LossOrMetricFn}",
        "documentation": "List of metrics to be evaluated by the model during training and testing.\nTypically you will use `metrics=['accuracy']`.\nTo specify different metrics for different outputs of a multi-output\nmodel, you could also pass a dictionary.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelAndWeightsConfig": [
      {
        "name": "modelTopology",
        "type": "PyJsonDict",
        "documentation": "A JSON object or JSON string containing the model config.\n\nThis can be either of the following two formats:\n   - A model archiecture-only config,  i.e., a format consistent with the\n     return value of`keras.Model.to_json()`.\n   - A full model config, containing not only model architecture, but also\n     training options and state, i.e., a format consistent with the return\n     value of `keras.models.save_model()`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weightsManifest",
        "type": "io.WeightsManifestConfig",
        "documentation": "A weights manifest in TensorFlow.js format.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "pathPrefix",
        "type": "string",
        "documentation": "Path to prepend to the paths in `weightManifest` before fetching.\n\nThe path may optionally end in a slash ('/').",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ModelPredictArgs": [
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "Optional. Batch size (Integer). If unspecified, it will default to 32.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "boolean",
        "documentation": "Optional. Verbosity mode. Defaults to false.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SequentialArgs": [
      {
        "name": "layers",
        "type": "Layer[]",
        "documentation": "Stack of layers for the model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "The name of this model.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ReLULayerArgs": [
      {
        "name": "maxValue",
        "type": "number",
        "documentation": "Float, the maximum output value.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LeakyReLULayerArgs": [
      {
        "name": "alpha",
        "type": "number",
        "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `0.3`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "PReLULayerArgs": [
      {
        "name": "alphaInitializer",
        "type": "Initializer|InitializerIdentifier",
        "documentation": "Initializer for the learnable alpha.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "alphaRegularizer",
        "type": "Regularizer",
        "documentation": "Regularizer for the learnable alpha.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "alphaConstraint",
        "type": "Constraint",
        "documentation": "Constraint for the learnable alpha.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "sharedAxes",
        "type": "number|number[]",
        "documentation": "The axes along which to share learnable parameters for the activation\nfunction. For example, if the incoming feature maps are from a 2D\nconvolution with output shape `[numExamples, height, width, channels]`,\nand you wish to share parameters across space (height and width) so that\neach filter channels has only one set of parameters, set\n`shared_axes: [1, 2]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ELULayerArgs": [
      {
        "name": "alpha",
        "type": "number",
        "documentation": "Float `>= 0`. Negative slope coefficient. Defaults to `1.0`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ThresholdedReLULayerArgs": [
      {
        "name": "theta",
        "type": "number",
        "documentation": "Float >= 0. Threshold location of activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SoftmaxLayerArgs": [
      {
        "name": "axis",
        "type": "number",
        "documentation": "Integer, axis along which the softmax normalization is applied.\nDefaults to `-1` (i.e., the last axis).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BaseConvLayerArgs": [
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]|[number, number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the convolutional kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the convolutional kernel weights.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConvLayerArgs": [
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]|[number, number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the convolutional kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the convolutional kernel weights.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SeparableConvLayerArgs": [
      {
        "name": "depthMultiplier",
        "type": "number",
        "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal\nto `filtersIn * depthMultiplier`. Default: 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the depthwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "pointwiseInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the pointwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the depthwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "pointwiseRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the pointwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the depthwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "pointwiseConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the pointwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]|[number, number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the convolutional kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the convolutional kernel weights.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "Cropping2DLayerArgs": [
      {
        "name": "cropping",
        "type": "number|[number, number]|[[number, number], [number, number]]",
        "documentation": "Dimension of the cropping along the width and the height.\n- If integer: the same symmetric cropping\n  is applied to width and height.\n- If list of 2 integers:\n   interpreted as two different\n   symmetric cropping values for height and width:\n   `[symmetric_height_crop, symmetric_width_crop]`.\n- If a list of 2 lists of 2 integers:\n   interpreted as\n   `[[top_crop, bottom_crop], [left_crop, right_crop]]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n`channels_first` corresponds to inputs with shape\n   `(batch, channels, ...)`\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "UpSampling2DLayerArgs": [
      {
        "name": "size",
        "type": "number[]",
        "documentation": "The upsampling factors for rows and columns.\n\nDefaults to `[2, 2]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`\"channelsLast\"` corresponds to inputs with shape\n   `[batch, ..., channels]`\n\n  `\"channelsFirst\"` corresponds to inputs with shape `[batch, channels,\n...]`.\n\nDefaults to `\"channelsLast\"`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "interpolation",
        "type": "InterpolationFormat",
        "documentation": "The interpolation mechanism, one of `\"nearest\"` or `\"bilinear\"`, default\nto `\"nearest\"`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "DepthwiseConv2DLayerArgs": [
      {
        "name": "kernelSize",
        "type": "number|[number, number]",
        "documentation": "An integer or Array of 2 integers, specifying the width and height of the\n2D convolution window. Can be a single integer to specify the same value\nfor all spatial dimensions.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthMultiplier",
        "type": "number",
        "documentation": "The number of depthwise convolution output channels for each input\nchannel.\nThe total number of depthwise convolution output channels will be equal to\n`filtersIn * depthMultiplier`.\nDefault: 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the depthwise kernel matrix.\nDefault: GlorotNormal.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the depthwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "depthwiseRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function for the depthwise kernel matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]|[number, number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function of the layer.\n\nIf you don't specify the activation, none is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector. Defaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the convolutional kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the convolutional kernel weights.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BaseRNNLayerArgs": [
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SimpleRNNCellLayerArgs": [
      {
        "name": "units",
        "type": "number",
        "documentation": "units: Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SimpleRNNLayerArgs": [
      {
        "name": "units",
        "type": "number",
        "documentation": "Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RNNLayerArgs": [
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "GRUCellLayerArgs": [
      {
        "name": "recurrentActivation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "number",
        "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "resetAfter",
        "type": "boolean",
        "documentation": "GRU convention (whether to apply reset gate after or before matrix\nmultiplication). false = \"before\", true = \"after\" (only false is\nsupported).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "units",
        "type": "number",
        "documentation": "units: Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "GRULayerArgs": [
      {
        "name": "recurrentActivation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "number",
        "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "units",
        "type": "number",
        "documentation": "Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LSTMCellLayerArgs": [
      {
        "name": "recurrentActivation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unitForgetBias",
        "type": "boolean",
        "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "number",
        "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "units",
        "type": "number",
        "documentation": "units: Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LSTMLayerArgs": [
      {
        "name": "recurrentActivation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unitForgetBias",
        "type": "boolean",
        "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "number",
        "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this config field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "units",
        "type": "number",
        "documentation": "Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "number",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "Function",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "StackedRNNCellsArgs": [
      {
        "name": "cells",
        "type": "RNNCell[]",
        "documentation": "An `Array` of `RNNCell` instances.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConvRNN2DCellArgs": [
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "any",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "any",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "any",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "any",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "any",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "any",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "any",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "any",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "any",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "any",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "any",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "any",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConvRNN2DLayerArgs": [
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "boolean",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "boolean",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "boolean",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "boolean",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "boolean",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "any",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "any",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "any",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "any",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "any",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "any",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConvLSTM2DCellArgs": [
      {
        "name": "activation",
        "type": "any",
        "documentation": "Activation function to use.\nDefault: hyperbolic tangent ('tanh').\nIf you pass `null`,  'linear' activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "any",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "any",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "any",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "any",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the `recurrent_kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `kernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the `recurrentKernel` weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "any",
        "documentation": "Float number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "any",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "any",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "any",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "any",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "any",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "any",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "any",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentActivation",
        "type": "any",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unitForgetBias",
        "type": "any",
        "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "any",
        "documentation": "Implementation mode, either 1 or 2.\n\nMode 1 will structure its operations as a larger number of\n   smaller dot products and additions.\n\nMode 2 will batch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this configuration field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConvLSTM2DArgs": [
      {
        "name": "activation",
        "type": "any",
        "documentation": "Activation function to use.\n\nDefaults to  hyperbolic tangent (`tanh`)\n\nIf you pass `null`, no activation will be applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "any",
        "documentation": "Whether the layer uses a bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "any",
        "documentation": "Initializer for the `kernel` weights matrix, used for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentInitializer",
        "type": "any",
        "documentation": "Initializer for the `recurrentKernel` weights matrix, used for\nlinear transformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "any",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "any",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the recurrentKernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "any",
        "documentation": "Constraint function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropout",
        "type": "any",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentDropout",
        "type": "any",
        "documentation": "Number between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the recurrent state.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dropoutFunc",
        "type": "any",
        "documentation": "This is added for test DI purpose.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "any",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "any",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "any",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "any",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "any",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "any",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "any",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "recurrentActivation",
        "type": "any",
        "documentation": "Activation function to use for the recurrent step.\n\nDefaults to hard sigmoid (`hardSigmoid`).\n\nIf `null`, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unitForgetBias",
        "type": "any",
        "documentation": "If `true`, add 1 to the bias of the forget gate at initialization.\nSetting it to `true` will also force `biasInitializer = 'zeros'`.\nThis is recommended in\n[Jozefowicz et\nal.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "implementation",
        "type": "any",
        "documentation": "Implementation mode, either 1 or 2.\n   Mode 1 will structure its operations as a larger number of\n   smaller dot products and additions, whereas mode 2 will\n   batch them into fewer, larger operations. These modes will\n   have different performance profiles on different hardware and\n   for different applications.\n\nNote: For superior performance, TensorFlow.js always uses implementation\n2, regardless of the actual value of this config field.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnSequences",
        "type": "any",
        "documentation": "Whether to return the last output in the output sequence, or the full\nsequence.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "returnState",
        "type": "any",
        "documentation": "Whether to return the last state in addition to the output.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "goBackwards",
        "type": "any",
        "documentation": "If `true`, process the input sequence backwards and return the reversed\nsequence (default: `false`).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "stateful",
        "type": "any",
        "documentation": "If `true`, the last state for each sample at index i in a batch will be\nused as initial state of the sample of index i in the following batch\n(default: `false`).\n\nYou can set RNN layers to be \"stateful\", which means that the states\ncomputed for the samples in one batch will be reused as initial states\nfor the samples in the next batch. This assumes a one-to-one mapping\nbetween samples in different successive batches.\n\nTo enable \"statefulness\":\n   - specify `stateful: true` in the layer constructor.\n   - specify a fixed batch size for your model, by passing\n     - if sequential model:\n       `batchInputShape: [...]` to the first layer in your model.\n     - else for functional model with 1 or more Input layers:\n       `batchShape: [...]` to all the first layers in your model.\n     This is the expected shape of your inputs\n     *including the batch size*.\n     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   - specify `shuffle: false` when calling `LayersModel.fit()`.\n\nTo reset the state of your model, call `resetStates()` on either the\nspecific layer or on the entire model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "unroll",
        "type": "any",
        "documentation": "If `true`, the network will be unrolled, else a symbolic loop will be\nused. Unrolling can speed up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences (default:\n`false`).\nPorting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   normal TypeScript control flow. Hence this property is inapplicable and\n   ignored in tfjs-layers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "any",
        "documentation": "Dimensionality of the input (integer).\n   This option (or alternatively, the option `inputShape`) is required when\n   this layer is used as the first layer in a model.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "any",
        "documentation": "Length of the input sequences, to be specified when it is constant.\nThis argument is required if you are going to connect `Flatten` then\n`Dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed). Note that if the recurrent layer is not the first layer in\nyour model, you would need to specify the input length at the level of the\nfirst layer (e.g., via the `inputShape` option).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "cell",
        "type": "RNNCell|RNNCell[]",
        "documentation": "A RNN cell instance. A RNN cell is a class that has:\n   - a `call()` method, which takes `[Tensor, Tensor]` as the\n     first input argument. The first item is the input at time t, and\n     second item is the cell state at time t.\n     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n     The `call()` method of the cell can also take the argument `constants`,\n     see section \"Note on passing external constants\" below.\n     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n       which are Layer subtypes, to accept two arguments. tfjs-layers does\n       not do such overriding. Instead we preseve the `call()` signature,\n       which due to its `Tensor|Tensor[]` argument and return value is\n       flexible enough to handle the inputs and states.\n   - a `stateSize` attribute. This can be a single integer (single state)\n     in which case it is the size of the recurrent state (which should be\n     the same as the size of the cell output). This can also be an Array of\n     integers (one size per state). In this case, the first entry\n     (`stateSize[0]`) should be the same as the size of the cell output.\nIt is also possible for `cell` to be a list of RNN cell instances, in which\ncase the cells get stacked on after the other in the RNN, implementing an\nefficient stacked RNN.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "filters",
        "type": "number",
        "documentation": "The dimensionality of the output space (i.e. the number of filters in the\nconvolution).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelSize",
        "type": "number|number[]",
        "documentation": "The dimensions of the convolution window. If kernelSize is a number, the\nconvolutional window will be square.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|number[]",
        "documentation": "The strides of the convolution in each dimension. If strides is a number,\nstrides in both dimensions are equal.\n\nSpecifying any stride value != 1 is incompatible with specifying any\n`dilationRate` value != 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "Padding mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Format of the data, which determines the ordering of the dimensions in\nthe inputs.\n\n`channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)`\n\n  `channels_first` corresponds to inputs with shape `(batch, channels,\n...)`.\n\nDefaults to `channels_last`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dilationRate",
        "type": "number|[number]|[number, number]",
        "documentation": "The dilation rate to use for the dilated convolution in each dimension.\nShould be an integer or array of two or three integers.\n\nCurrently, specifying any `dilationRate` value != 1 is incompatible with\nspecifying any `strides` value != 1.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LayerConfig": [
      {
        "name": "input_shape",
        "type": "Shape",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batch_input_shape",
        "type": "Shape",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batch_size",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "input_dtype",
        "type": "DataType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BaseLayerSerialization": [
      {
        "name": "name",
        "type": "string",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inbound_nodes",
        "type": "NodeConfig[]",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "class_name",
        "type": "N",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "config",
        "type": "T",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "DropoutLayerArgs": [
      {
        "name": "rate",
        "type": "number",
        "documentation": "Float between 0 and 1. Fraction of the input units to drop.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "noiseShape",
        "type": "number[]",
        "documentation": "Integer array representing the shape of the binary dropout mask that will\nbe multiplied with the input.\n\nFor instance, if your inputs have shape `(batchSize, timesteps, features)`\nand you want the dropout mask to be the same for all timesteps, you can use\n`noise_shape=(batch_size, 1, features)`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "An integer to use as random seed.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "DenseLayerArgs": [
      {
        "name": "units",
        "type": "number",
        "documentation": "Positive integer, dimensionality of the output space.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Activation function to use.\n\nIf unspecified, no activation is applied.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "useBias",
        "type": "boolean",
        "documentation": "Whether to apply a bias.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the dense kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "If specified, defines inputShape as `[inputDim]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the kernel weights.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "kernelRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the dense kernel weights matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "biasRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the bias vector.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "SpatialDropout1DLayerConfig": [
      {
        "name": "rate",
        "type": "number",
        "documentation": "Float between 0 and 1. Fraction of the input units to drop.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "An integer to use as random seed.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "input_shape",
        "type": "Shape",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batch_input_shape",
        "type": "Shape",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batch_size",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "input_dtype",
        "type": "DataType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "FlattenLayerArgs": [
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "Image data format: channelsLast (default) or channelsFirst.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ActivationLayerArgs": [
      {
        "name": "activation",
        "type": "ActivationIdentifier",
        "documentation": "Name of the activation function to use.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ReshapeLayerArgs": [
      {
        "name": "targetShape",
        "type": "Shape",
        "documentation": "The target shape. Does not include the batch axis.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RepeatVectorLayerArgs": [
      {
        "name": "n",
        "type": "number",
        "documentation": "The integer number of times to repeat the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "PermuteLayerArgs": [
      {
        "name": "dims",
        "type": "number[]",
        "documentation": "Array of integers. Permutation pattern. Does not include the\nsample (batch) dimension. Index starts at 1.\nFor instance, `[2, 1]` permutes the first and second dimensions\nof the input.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "MaskingArgs": [
      {
        "name": "maskValue",
        "type": "number",
        "documentation": "Masking Value. Defaults to `0.0`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "EmbeddingLayerArgs": [
      {
        "name": "inputDim",
        "type": "number",
        "documentation": "Integer > 0. Size of the vocabulary, i.e. maximum integer index + 1.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "outputDim",
        "type": "number",
        "documentation": "Integer >= 0. Dimension of the dense embedding.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "embeddingsInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the `embeddings` matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "embeddingsRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the `embeddings` matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "activityRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer function applied to the activation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "embeddingsConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint function applied to the `embeddings` matrix.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "maskZero",
        "type": "boolean",
        "documentation": "Whether the input value 0 is a special \"padding\" value that should be\nmasked out. This is useful when using recurrent layers which may take\nvariable length input.\n\nIf this is `True` then all subsequent layers in the model need to support\nmasking or an exception will be raised. If maskZero is set to `True`, as a\nconsequence, index 0 cannot be used in the vocabulary (inputDim should\nequal size of vocabulary + 1).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputLength",
        "type": "number|number[]",
        "documentation": "Length of input sequences, when it is constant.\n\nThis argument is required if you are going to connect `flatten` then\n`dense` layers upstream (without it, the shape of the dense outputs cannot\nbe computed).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ConcatenateLayerArgs": [
      {
        "name": "axis",
        "type": "number",
        "documentation": "Axis along which to concatenate.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "DotLayerArgs": [
      {
        "name": "axes",
        "type": "number|[number, number]",
        "documentation": "Axis or axes along which the dot product will be taken.\n\nInteger or an Array of integers.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "normalize",
        "type": "boolean",
        "documentation": "Whether to L2-normalize samples along the dot product axis\nbefore taking the dot product.\n\nIf set to `true`, the output of the dot product is the cosine\nproximity between the two samples.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "GaussianNoiseArgs": [
      {
        "name": "stddev",
        "type": "number",
        "documentation": "Standard Deviation.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "GaussianDropoutArgs": [
      {
        "name": "rate",
        "type": "number",
        "documentation": "drop probability.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "AlphaDropoutArgs": [
      {
        "name": "rate",
        "type": "number",
        "documentation": "drop probability.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "noiseShape",
        "type": "Shape",
        "documentation": "A 1-D `Tensor` of type `int32`, representing the\nshape for randomly generated keep/drop flags.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BatchNormalizationLayerArgs": [
      {
        "name": "axis",
        "type": "number",
        "documentation": "The integer axis that should be normalized (typically the features axis).\nDefaults to -1.\n\nFor instance, after a `Conv2D` layer with `data_format=\"channels_first\"`,\nset `axis=1` in `batchNormalization`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "momentum",
        "type": "number",
        "documentation": "Momentum of the moving average. Defaults to 0.99.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "epsilon",
        "type": "number",
        "documentation": "Small float added to the variance to avoid dividing by zero. Defaults to\n1e-3.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "center",
        "type": "boolean",
        "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "scale",
        "type": "boolean",
        "documentation": "If `true`, multiply by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear (also e.g. `nn.relu`),\nthis can be disabled since the scaling will be done by the next layer.\nDefaults to `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "betaInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the beta weight.\n  Defaults to 'zeros'.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "gammaInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the gamma weight.\n  Defaults to `ones`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "movingMeanInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the moving mean.\nDefaults to `zeros`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "movingVarianceInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the moving variance.\n  Defaults to 'Ones'.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "betaConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for the beta weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "gammaConstraint",
        "type": "ConstraintIdentifier|Constraint",
        "documentation": "Constraint for gamma weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "betaRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer for the beta weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "gammaRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer for the gamma weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "LayerNormalizationLayerArgs": [
      {
        "name": "axis",
        "type": "number|number[]",
        "documentation": "The axis or axes that should be normalized (typically, the feature axis).\nDefaults to -1 (the last axis).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "epsilon",
        "type": "number",
        "documentation": "A small positive float added to variance to avoid divison by zero.\nDefaults to 1e-3.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "center",
        "type": "boolean",
        "documentation": "If `true`, add offset of `beta` to normalized tensor.\nIf `false`, `beta` is ignored.\nDefault: `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "scale",
        "type": "boolean",
        "documentation": "If `true`, multiply output by `gamma`.\nIf `false`, `gamma` is not used.\nWhen the next layer is linear, this can be disabled since scaling will\nbe done by the next layer.\nDefault: `true`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "betaInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the beta weight.\nDefault: `'zeros'`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "gammaInitializer",
        "type": "InitializerIdentifier|Initializer",
        "documentation": "Initializer for the gamma weight.\nDefault: `'ones'`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "betaRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer for the beta weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "gammaRegularizer",
        "type": "RegularizerIdentifier|Regularizer",
        "documentation": "Regularizer for the gamma weight.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ZeroPadding2DLayerArgs": [
      {
        "name": "padding",
        "type": "number|[number, number]|[[number, number], [number, number]]",
        "documentation": "Integer, or `Array` of 2 integers, or `Array` of 2 `Array`s, each of\nwhich is an `Array` of 2 integers.\n- If integer, the same symmetric padding is applied to width and height.\n- If `Array` of 2 integers, interpreted as two different symmetric values\n   for height and width:\n   `[symmetricHeightPad, symmetricWidthPad]`.\n- If `Array` of 2 `Array`s, interpreted as:\n   `[[topPad, bottomPad], [leftPad, rightPad]]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "One of `'channelsLast'` (default) and `'channelsFirst'`.\n\nThe ordering of the dimensions in the inputs.\n`channelsLast` corresponds to inputs with shape\n`[batch, height, width, channels]` while `channelsFirst`\ncorresponds to inputs with shape\n`[batch, channels, height, width]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "Pooling1DLayerArgs": [
      {
        "name": "poolSize",
        "type": "number|[number]",
        "documentation": "Size of the window to pool over, should be an integer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|[number]",
        "documentation": "Period at which to sample the pooled values.\n\nIf `null`, defaults to `poolSize`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "How to fill in data that's not an integer multiple of poolSize.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "Pooling2DLayerArgs": [
      {
        "name": "poolSize",
        "type": "number|[number, number]",
        "documentation": "Factors by which to downscale in each dimension [vertical, horizontal].\nExpects an integer or an array of 2 integers.\n\nFor example, `[2, 2]` will halve the input in both spatial dimensions.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|[number, number]",
        "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 2 integers. Integer, tuple of 2 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "The padding type to use for the pooling layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "The data format to use for the pooling layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "Pooling3DLayerArgs": [
      {
        "name": "poolSize",
        "type": "number|[number, number, number]",
        "documentation": "Factors by which to downscale in each dimension [depth, height, width].\nExpects an integer or an array of 3 integers.\n\nFor example, `[2, 2, 2]` will halve the input in three dimensions.\nIf only one integer is specified, the same window length\nwill be used for all dimensions.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "strides",
        "type": "number|[number, number, number]",
        "documentation": "The size of the stride in each dimension of the pooling window. Expects\nan integer or an array of 3 integers. Integer, tuple of 3 integers, or\nNone.\n\nIf `null`, defaults to `poolSize`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "padding",
        "type": "PaddingMode",
        "documentation": "The padding type to use for the pooling layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "The data format to use for the pooling layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "GlobalPooling2DLayerArgs": [
      {
        "name": "dataFormat",
        "type": "DataFormat",
        "documentation": "One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n\nThe ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\nto inputs with shape `[batch, height, width, channels]` while\n`CHANNEL_FIRST` corresponds to inputs with shape\n`[batch, channels, height, width]`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "WrapperLayerArgs": [
      {
        "name": "layer",
        "type": "Layer",
        "documentation": "The layer to be wrapped.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BidirectionalLayerArgs": [
      {
        "name": "layer",
        "type": "RNN",
        "documentation": "The instance of an `RNN` layer to be wrapped.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "mergeMode",
        "type": "BidirectionalMergeMode",
        "documentation": "Mode by which outputs of the forward and backward RNNs are\ncombined. If `null` or `undefined`, the output will not be\ncombined, they will be returned as an `Array`.\n\nIf `undefined` (i.e., not provided), defaults to `'concat'`.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RescalingArgs": [
      {
        "name": "scale",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "offset",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "CenterCropArgs": [
      {
        "name": "height",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "width",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "CategoryEncodingArgs": [
      {
        "name": "numTokens",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "outputMode",
        "type": "OutputMode",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "ResizingArgs": [
      {
        "name": "height",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "width",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "interpolation",
        "type": "InterpolationType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "cropToAspectRatio",
        "type": "boolean",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "BaseRandomLayerArgs": [
      {
        "name": "seed",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "RandomWidthArgs": [
      {
        "name": "factor",
        "type": "number | [number, number]",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "interpolation",
        "type": "InterpolationType",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "seed",
        "type": "number",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "autoVectorize",
        "type": "boolean",
        "documentation": "",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchInputShape",
        "type": "Shape",
        "documentation": "If defined, will be used to create an input layer to insert before this\nlayer. If both `inputShape` and `batchInputShape` are defined,\n`batchInputShape` will be used. This argument is only applicable to input\nlayers (the first layer of a model).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "batchSize",
        "type": "number",
        "documentation": "If `inputShape` is specified and `batchInputShape` is *not* specified,\n`batchSize` is used to construct the `batchInputShape`: `[batchSize,\n...inputShape]`",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "dtype",
        "type": "DataType",
        "documentation": "The data-type for this layer. Defaults to 'float32'.\nThis argument is only applicable to input layers (the first layer of a\nmodel).",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "trainable",
        "type": "boolean",
        "documentation": "Whether the weights of this layer are updatable by `fit`.\nDefaults to true.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "weights",
        "type": "Tensor[]",
        "documentation": "Initial weight values of the layer.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "inputDType",
        "type": "DataType",
        "documentation": "Legacy support. Do not use for new code.",
        "optional": false,
        "isConfigParam": true
      }
    ],
    "EarlyStoppingCallbackArgs": [
      {
        "name": "monitor",
        "type": "string",
        "documentation": "Quantity to be monitored.\n\nDefaults to 'val_loss'.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "minDelta",
        "type": "number",
        "documentation": "Minimum change in the monitored quantity to qualify as improvement,\ni.e., an absolute change of less than `minDelta` will count as no\nimprovement.\n\nDefaults to 0.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "patience",
        "type": "number",
        "documentation": "Number of epochs with no improvement after which training will be stopped.\n\nDefaults to 0.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "verbose",
        "type": "number",
        "documentation": "Verbosity mode.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "mode",
        "type": "'auto'|'min'|'max'",
        "documentation": "Mode: one of 'min', 'max', and 'auto'.\n- In 'min' mode, training will be stopped when the quantity monitored has\n   stopped decreasing.\n- In 'max' mode, training will be stopped when the quantity monitored has\n   stopped increasing.\n- In 'auto' mode, the direction is inferred automatically from the name of\n   the monitored quantity.\n\nDefaults to 'auto'.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "baseline",
        "type": "number",
        "documentation": "Baseline value of the monitored quantity.\n\nIf specified, training will be stopped if the model doesn't show\nimprovement over the baseline.",
        "optional": false,
        "isConfigParam": true
      },
      {
        "name": "restoreBestWeights",
        "type": "boolean",
        "documentation": "Whether to restore model weights from the epoch with the best value\nof the monitored quantity. If `False`, the model weights obtained at the\nlast step of training are used.\n\n**`True` is not supported yet.**",
        "optional": false,
        "isConfigParam": true
      }
    ]
  },
  "inlineTypes": {
    "DataFormat": "'channelsFirst'|'channelsLast'",
    "PaddingMode": "'valid'|'same'|'causal'",
    "PoolMode": "'max'|'avg'",
    "BidirectionalMergeMode": "'sum'|'mul'|'concat'|'ave'",
    "SampleWeightMode": "'temporal'",
    "ConstraintIdentifier": "'maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string",
    "FanMode": "'fanIn'|'fanOut'|'fanAvg'",
    "Distribution": "'normal'|'uniform'|'truncatedNormal'",
    "InitializerIdentifier": "'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'|\n    'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'|\n    'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string",
    "RegularizerIdentifier": "'l1l2'|string",
    "ActivationIdentifier": "'elu'|'hardSigmoid'|'linear'|'relu'|'relu6'|\n    'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'"
  },
  "docTypeAliases": {
    "Shape": "(null | number)[]"
  }
}